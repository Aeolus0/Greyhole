#!/usr/bin/php
<?php
/*
Copyright 2009 Guillaume Boudreau

This file is part of Greyhole.

Greyhole is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Greyhole is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Greyhole.  If not, see <http://www.gnu.org/licenses/>.
*/

include('includes/common.php');
parse_config();

mysql_connect($db_host, $db_user, $db_pass) or gh_log(CRITICAL, "Can't connect to MySQL.");
mysql_select_db($db_name);

$action = 'unknown';
$options = array();
for ($i=1; $i<$argc; $i++) {
	switch ($argv[$i]) {
		case '--daemon':
		case '--fsck':
		case '--prerotate':
		case '--postrotate':
		case '--stats':
		case '--empty-attic':
		$action = substr($argv[$i], 2);
		break;

		case '--email-report':
		$options[substr($argv[$i], 2)] = TRUE;
		break;

		case '--gone':
		case '--gone-ok':
		$action = substr($argv[$i], 2);
		// Fall through --dir to fetch the path to the Gone/Gone-But-OK drive

		case '--dir':
		$options['dir'] = $argv[$i+1];
		$i++;
		break;

		case '--debug':
		$action = 'debug';
		if (isset($argv[$i+1])) {
			$options['debug_filename'] = $argv[$i+1];
			$i++;
		}
		break;
		
		default:
		print_usage();
	}
}

if ($action == 'unknown') {
	print_usage();
}

function print_usage() {
	echo "Invalid command line options.\n";
	echo "Usage: Start the daemon:        greyhole-executer --daemon\n";
	echo "       Schedule a fsck:         greyhole-executer --fsck [--email-report] [--dir <path>]\n";
	echo "       Display statistics:      greyhole-executer --stats\n";
	echo "       Empty attic:             greyhole-executer --empty-attic\n";
	echo "       Debug file operations:   greyhole-executer --debug <filename>\n";
	echo "\n";
	echo "       Pre-rotate task:         greyhole-executer --prerotate\n";
	echo "       Post-rotate task:        greyhole-executer --postrotate\n";
	echo "\n";
	echo "     When <path>, one of your storage pool directories, is unavailable:\n";
	echo "       <path> will return soon: greyhole-executer --gone-ok <path>\n";
	echo "       <path> is gone for good: greyhole-executer --gone <path>\n";
	exit(1);
}

if ($action == 'debug') {
	if (!isset($options['debug_filename'])) {
		print_usage();
	}
	$filename = $options['debug_filename'];

	echo "Debugging file operations for file named \"$filename\"\n";

	echo "\nFrom DB\n=======\n";
	$debug_tasks = array();
	$query = sprintf("SELECT id, action, share, full_path, additional_info, event_date FROM tasks_completed WHERE full_path LIKE '%%%s%%' ORDER BY id ASC",
		mysql_escape_string($filename)
	);
	$result = mysql_query($query) or die("Can't query tasks_completed with query: $query - Error: " . mysql_error());
	while ($row = mysql_fetch_object($result)) {
		$debug_tasks[$row->id] = $row;
	}

	// Renames
	$query = sprintf("SELECT id, action, share, full_path, additional_info, event_date FROM tasks_completed WHERE additional_info LIKE '%%%s%%' ORDER BY id ASC",
		mysql_escape_string($filename)
	);
	do {
		$result = mysql_query($query) or die("Can't query tasks_completed for renames with query: $query - Error: " . mysql_error());
		while ($row = mysql_fetch_object($result)) {
			$debug_tasks[$row->id] = $row;
			$query = sprintf("SELECT id, action, share, full_path, additional_info, event_date FROM tasks_completed WHERE additional_info = '%s' ORDER BY id ASC",
				mysql_escape_string($row->full_path)
			);
		}
	} while (mysql_num_rows($result) > 0);
	
	ksort($debug_tasks);
	$to_grep = array();
	foreach ($debug_tasks as $task) {
		echo "  [$task->event_date] Task ID $task->id: $task->action $task->share/$task->full_path" . ($task->action == 'rename' ? " -> $task->share/$task->additional_info" : '') . "\n";
		$to_grep["$task->share/$task->full_path"] = 1;
		if ($task->action == 'rename') {
			$to_grep["$task->share/$task->additional_info"] = 1;
		}
	}

	echo "\nFrom logs\n=========\n";
	$to_grep = array_keys($to_grep);
	$to_grep = implode("|", $to_grep);
	$commands = array();
	$commands[] = "zgrep -E -A 1 -h " . quoted_form($to_grep) . " /var/log/greyhole.log-*";
	$commands[] = "grep -E -A 1 -h " . quoted_form($to_grep) . " /var/log/greyhole.log";
	foreach ($commands as $command) {
		exec($command, $result);
	}
	foreach ($result as $rline) {
		echo preg_replace('@^/var/log/greyhole.log[0-9\.gz-]*:@', '', $rline) . "\n";
	}
	
	echo "\nFrom filesystem\n===============\n";

	$last_task = array_pop($debug_tasks);
	$share = $last_task->share;
	if ($last_task->action == 'rename') {
		$full_path = $last_task->additional_info;
	} else {
		$full_path = $last_task->full_path;
	}
	list($path, $filename) = explode_full_path($full_path);
	echo "Landing Zone:\n";
	echo "  "; passthru("ls -l " . quoted_form(get_share_landing_zone($share) . "/" . $full_path));

	echo "\nGraveyard:\n";
	foreach ($storage_pool_directories as $target_drive) {
		$graveyard = clean_dir("$target_drive/.gh_graveyard");
		if (file_exists("$graveyard/$share/$full_path")) {
			echo "  "; passthru("ls -l " . quoted_form("$graveyard/$share/$full_path"));
			$data = var_export(unserialize(file_get_contents("$graveyard/$share/$full_path")), TRUE);
			$data = str_replace("\n", "\n    ", $data);
			echo "    $data\n";
		}
	}

	echo "\nFile copies:\n";
	foreach ($storage_pool_directories as $target_drive) {
		if (file_exists("$target_drive/$share/$full_path")) {
			echo "  "; passthru("ls -l " . quoted_form("$target_drive/$share/$full_path"));
		}
	}

	exit(0);
}
if ($action == 'empty-attic') {
	if (exec("whoami") != 'root') {
		echo "You need to execute this as root.\n";
		exit(1);
	}
	foreach ($storage_pool_directories as $target_drive) {
		$attic_path = clean_dir("$target_drive/.gh_attic");
		if (!file_exists($attic_path)) {
			echo "Attic in $target_drive is empty. Nothing to do.\n";
		} else {
			$attic_size = trim(exec("du -sk " . quoted_form($attic_path) . " | awk '{print $1}'"));
			echo "Attic in $target_drive is " . bytes_to_human($attic_size*1024, FALSE) . ". Emptying... ";
			exec("rm -rf " . quoted_form($attic_path));
			echo "Done\n";
		}
	}
	exit(0);
}
if ($action == 'stats') {
	echo "\nGreyhole Statistics\n===================\n\n";

	$dfs = get_free_space_in_storage_pool_dirs();
	echo "Storage Pool\n";
	echo "                Total -  Used =  Free + Attic = Possible\n";
	foreach ($storage_pool_directories as $target_drive) {
		echo "  $target_drive: ";
		if (!isset($dfs[$target_drive])) {
			echo "  N/A -   N/A =   N/A +   N/A =   N/A\n";
			continue;
		}

		$df_command = "df -k " . quoted_form($target_drive) . " | awk '{print \$(NF-4),\$(NF-3)}'";
		unset($responses);
		exec($df_command, $responses);
		$response = explode(' ', $responses[1]);
		$total_space = (float) array_shift($response);
		$used_space = (float) array_shift($response);

		$free_space = $dfs[$target_drive];

		$attic_path = clean_dir("$target_drive/.gh_attic");
		if (!file_exists($attic_path)) {
			$attic_size = 0;
		} else {
			$attic_size = trim(exec("du -sk " . quoted_form($attic_path) . " | awk '{print $1}'"));
		}

		$potential_available_space = (float) $free_space + $attic_size;

		echo sprintf('%4.0f', $total_space/1024/1024) . "G - " . sprintf('%4.0f', $used_space/1024/1024) . "G = " . sprintf('%4.0f', $free_space/1024/1024) . "G + " . sprintf('%4.0f', $attic_size/1024/1024) . "G = " . sprintf('%4.0f', $potential_available_space/1024/1024) . "G\n";
	}
	echo "\n";
	exit(0);
}

if ($action == 'gone') {
	if (!mark_gone_ok($options['dir'], 'remove')) {
		echo "Directory " . $options['dir'] . " is not one of your defined storage pool directories.\n";
		echo "Please use one of the following with the --gone option:\n  ";
		echo implode("\n  ", $storage_pool_directories) . "\n";
		exit(1);
	}
	gh_log(INFO, "Storage pool directory " . $options['dir'] . " has been marked Gone");
	echo "Storage pool directory " . $options['dir'] . " has been marked Gone, which means the missing file copies that are in this directory will be re-created during the next fsck.\n";
	exit(0);
}

if ($action == 'gone-ok') {
	if (!mark_gone_ok($options['dir'])) {
		echo "Directory " . $options['dir'] . " is not one of your defined storage pool directories.\n";
		echo "Please use one of the following with the --gone-ok option:\n  ";
		echo implode("\n  ", $storage_pool_directories) . "\n";
		exit(1);
	}
	gh_log(INFO, "Storage pool directory " . $options['dir'] . " has been marked Gone-OK");
	echo "Storage pool directory " . $options['dir'] . " has been marked Gone-OK, which means the missing file copies that are in this directory will not be re-created until it reappears.\n";
	exit(0);
}

if ($action == 'prerotate') {
	parse_samba_log(FALSE);
	gh_log(INFO, "Samba log parsed using --prerotate");
	echo "Samba log parsed successfully. You can now rotate the log, then reset the read pointer using --postrotate\n";
	exit(0);
}

repair_tables();

if ($action == 'postrotate') {
	$query = sprintf("UPDATE settings SET value = '0' WHERE name = '%s'", 'last_read_log_smbd_line');
	mysql_query($query) or gh_log(CRITICAL, "Can't update settings for 'last_read_log_smbd_line': " . mysql_error());
	gh_log(INFO, "Samba log read pointer reset using --postrotate");
	echo "Samba log read pointer reset to 0.\n";
	exit(0);
}

if ($action == 'fsck') {
	$pos = array_search('fsck', $argv);
	$full_path = '';
	if (isset($options['dir'])) {
		$full_path = $options['dir'];
		if (!is_dir($full_path)) {
			echo "$full_path is not a directory. Exiting.\n";
			exit(1);
		}
	}
	$query = sprintf("INSERT INTO tasks (action, share, additional_info, complete) VALUES ('fsck', '%s', %s, 'yes')",
		mysql_escape_string($full_path),
		(isset($options['email-report']) ? "'daily'" : "NULL")
	);
	mysql_query($query) or gh_log(CRITICAL, "Can't insert fsck task: " . mysql_error());
	if ($full_path == '') {
		$full_path = 'all shares';
	}
	echo "fsck of $full_path has been scheduled. It will start after all currently pending tasks have been completed.\n";
	exit(0);
}

gh_log(INFO, "Greyhole daemon started.");
parse_samba_log();
simplify_tasks();
while (TRUE) {
	parse_samba_log();
	$action = 'check_pool';
	check_storage_pool_dirs();
	execute_next_task();
}

function execute_next_task() {
	global $log_level, $fsck_report, $shares_options, $email_to, $sleep_before_task, $action;

	$query = "SELECT id, action, share, full_path, additional_info FROM tasks WHERE complete = 'yes' ORDER BY id ASC LIMIT 1";
	$result = mysql_query($query) or gh_log(CRITICAL, "Can't query tasks: " . mysql_error());
	if (mysql_num_rows($result) < 1) {
		$action = 'sleep';
		gh_log(DEBUG, "Nothing to do... Sleeping.");
		sleep($log_level == DEBUG ? 10 : 600);
		mysql_free_result($result);
		return;
	}
	$task = mysql_fetch_object($result);
	mysql_free_result($result);
	
	if (($key = array_search($task->id, $sleep_before_task)) !== FALSE) {
		$action = 'sleep';
		gh_log(DEBUG, "Only locked files operations pending... Sleeping.");
		sleep($log_level == DEBUG ? 10 : 600);
		$sleep_before_task = array();
	}
	
	$action = $task->action;
	gh_log(DEBUG, "Now working on task ID $task->id: $task->action $task->share/$task->full_path" . ($task->action == 'rename' ? " -> $task->share/$task->additional_info" : ''));

	$result = 0;
	switch ($task->action) {
		case 'fsck':
			gh_log(INFO, "Starting fsck for $task->share");
			initialize_fsck_report($task->share == '' ? 'All shares' : $task->share);
			clearstatcache();
			if ($task->share == '') {
				foreach ($shares_options as $share_name => $share_options) {
					gh_fsck($share_options['landing_zone'], $share_name);
				}
				foreach (get_graveyards() as $graveyard) {
					foreach ($shares_options as $share_name => $share_options) {
						gh_fsck_graveyard($graveyard, "/$share_name", $share_name);
					}
				}
			} else {
				$share_options = get_share_options_from_full_path($task->share);
				if ($share_options !== FALSE) {
					$share = $share_options['name'];
					gh_fsck($task->share, $share);
					$subdir = "/$share" . str_replace($share_options['landing_zone'], '', $task->share);
					gh_log(DEBUG, "Starting graveyards fsck for $subdir");
					foreach (get_graveyards() as $graveyard) {
						gh_fsck_graveyard($graveyard, $subdir, $share);
					}
				}
			}
			gh_log(INFO, "fsck for " . ($task->share == '' ? 'All shares' : $task->share) . " completed.");
			if ($task->additional_info == 'daily') {
				// Email report for daily fsck
				$fsck_report = get_fsck_report();
				$hostname = exec('hostname');
				gh_log(DEBUG, "Sending fsck report to $email_to");
				mail($email_to, 'Daily fsck of Greyhole shares on ' . $hostname, $fsck_report);
			}
			break;
		case 'mkdir':
			break;
		case 'write':
			$result = gh_write($task->share, $task->full_path, $task->id);
			break;
		case 'rename':
			gh_rename($task->share, $task->full_path, $task->additional_info, $task->id);
			break;
		case 'unlink':
			gh_unlink($task->share, $task->full_path, $task->id);
			break;
		case 'rmdir':
			gh_rmdir($task->share, $task->full_path);
			break;
	}
	if ($task->action != 'write' && $task->action != 'rename') {
		$sleep_before_task = array();
	}
	if ($result === 0) {
		$query = sprintf("INSERT INTO tasks_completed (SELECT * FROM tasks WHERE id = %d)", $task->id);
		mysql_query($query) or gh_log(CRITICAL, "Can't insert in tasks_completed: " . mysql_error());

		$query = sprintf("DELETE FROM tasks WHERE id = %d", $task->id);
		mysql_query($query) or gh_log(CRITICAL, "Can't delete from tasks: " . mysql_error());
	}
}

function gh_rmdir($share, $full_path) {
	global $storage_pool_directories;
	$landing_zone = get_share_landing_zone($share);
	
	gh_log(INFO, "Directory deleted: $landing_zone/$full_path");
	foreach ($storage_pool_directories as $target_drive) {
		if (@rmdir("$target_drive/$share/$full_path/")) {
			gh_log(DEBUG, "  Removed copy at $target_drive/$share/$full_path");
		}
		$graveyard = "$target_drive/.gh_graveyard";
		if (@rmdir("$graveyard/$share/$full_path/")) {
			gh_log(DEBUG, "  Removed tombstones directory $graveyard/$share/$full_path");
		}
	}
}

function gh_unlink($share, $full_path, $task_id) {
	$landing_zone = get_share_landing_zone($share);
	
	gh_log(INFO, "File deleted: $landing_zone/$full_path");

	if (gh_file_exists("$landing_zone/$full_path")) {
		gh_log(DEBUG, "  File still exists in landing zone; a new file replaced the one deleted here. Skipping.");
		return;
	}

	list($path, $filename) = explode_full_path($full_path);

	$existing_tombstones = get_tombstones($share, $path, $filename, TRUE);
	foreach ($existing_tombstones as $tombstone) {
		gh_recycle($tombstone->path);
	}
	remove_tombstones($share, $path, $filename);
}

function is_a_graveyard_dir($share, $full_path) {
	foreach (get_graveyards() as $graveyard) {
		if (is_dir("$graveyard/$share/$full_path")) {
			return TRUE;
		}
	}
	return FALSE;
}

function gh_rename($share, $full_path, $target_full_path, $task_id) {
	global $storage_pool_directories, $log_level, $sleep_before_task;
	$landing_zone = get_share_landing_zone($share);
	
	if (is_dir("$landing_zone/$target_full_path") || is_a_graveyard_dir($share, $full_path)) {
		gh_log(INFO, "Directory renamed: $landing_zone/$full_path -> $landing_zone/$target_full_path");
		foreach ($storage_pool_directories as $target_drive) {
			list($original_path, $dirname) = explode_full_path(get_share_landing_zone($share) . "/$target_full_path");

			if (is_dir("$target_drive/$share/$full_path")) {
				# Make sure the parent directory of target_full_path exists, before we try moving something there...
				list($path, $dirname) = explode_full_path("$target_drive/$share/$target_full_path");
				gh_mkdir($path, "$target_drive/$share", $original_path);

				rename("$target_drive/$share/$full_path", "$target_drive/$share/$target_full_path");
				gh_log(DEBUG, "  Directory moved: $target_drive/$share/$full_path -> $target_drive/$share/$target_full_path");
			}

			list($path, $dirname) = explode_full_path("$target_drive/.gh_graveyard/$share/$target_full_path");
			gh_mkdir($path, "$target_drive/.gh_graveyard/$share", $original_path);
			$result = @rename("$target_drive/.gh_graveyard/$share/$full_path", "$target_drive/.gh_graveyard/$share/$target_full_path");
			if ($result) {
				gh_log(DEBUG, "  Graveyard directory moved: $target_drive/.gh_graveyard/$share/$full_path -> $target_drive/.gh_graveyard/$share/$target_full_path");
			}
		}
		$existing_tombstones = get_tombstones($share, $target_full_path);
		foreach ($existing_tombstones as $file_path => $file_tombstones) {
			$new_file_tombstones = array();
			foreach ($file_tombstones as $key => $tombstone) {
				$old_path = $tombstone->path;
				$tombstone->path = str_replace("/$share/$full_path/", "/$share/$target_full_path/", $tombstone->path);
				gh_log(DEBUG, "  Changing tombstone: $old_path -> $tombstone->path");
				$new_file_tombstones[$tombstone->path] = $tombstone;

				// is_linked = is the target of the existing symlink
				if ($tombstone->is_linked) {
					gh_log(DEBUG, "  Updating symlink at $landing_zone/$target_full_path/$file_path to point to $tombstone->path");
					if (gh_recycle("$landing_zone/$target_full_path/$file_path")) {
 						@symlink($tombstone->path, "$landing_zone/$target_full_path/$file_path");
						// Creating this symlink can fail if the parent dir was removed
					}
				}
			}
			list($path, $filename) = explode_full_path("$target_full_path/$file_path");
			save_tombstones($share, $path, $filename, $new_file_tombstones);
		}
	} else {
		gh_log(INFO, "File renamed: $landing_zone/$full_path -> $landing_zone/$target_full_path");
		
		// Check if another process locked this file before we work on it.
		if (file_is_locked($share, $target_full_path) !== FALSE) {
			gh_log(DEBUG, "  File $landing_zone/$target_full_path is locked by another process. Will wait until it's unlocked to work on it.");
			$query = sprintf("INSERT INTO tasks (action, share, full_path, additional_info, complete) (SELECT action, share, full_path, additional_info, complete FROM tasks WHERE id = %d)",
				$task_id
			);
			mysql_query($query) or gh_log(CRITICAL, "Error inserting postponed task: " . mysql_error());
			$sleep_before_task[] = mysql_insert_id();
			return;
		}

		list($path, $filename) = explode_full_path($full_path);
		list($target_path, $target_filename) = explode_full_path($target_full_path);

		$existing_tombstones = get_tombstones($share, $path, $filename);

		// There might be old tombstones... for example, when a delete task was skipped.
		// Let's remove the file copies if there are any leftovers; correct copies will be re-created below.
		if (file_exists("$landing_zone/$target_full_path") && (count($existing_tombstones) > 0 || !is_link("$landing_zone/$target_full_path"))) {
			$existing_target_tombstones = get_tombstones($share, $target_path, $target_filename);
			if (count($existing_target_tombstones) > 0) {
				foreach ($existing_target_tombstones as $tombstone) {
					gh_recycle($tombstone->path);
				}
				remove_tombstones($share, $target_path, $target_filename);
			}
		}

		if (count($existing_tombstones) == 0) {
			// New file
			gh_write($share, $target_full_path, $task_id);
		} else {
			foreach ($existing_tombstones as $i => $tombstone) {
				$old_path = $tombstone->path;
				$tombstone->path = str_replace("/$share/$full_path", "/$share/$target_full_path", $old_path);
				gh_log(DEBUG, "  Renaming copy at $old_path to $tombstone->path");

				// Make sure the target directory exists
				list($tombstone_dir_path, $tombstone_filename) = explode_full_path($tombstone->path);
				$root_path = str_replace(clean_dir("/$share/$target_full_path"), '', $tombstone->path);
				list($original_path, $dirname) = explode_full_path(get_share_landing_zone($share) . "/$target_full_path");
				gh_mkdir($tombstone_dir_path, "$root_path/$share", $original_path);

				$it_worked = rename($old_path, $tombstone->path);

				if ($it_worked) {
					// is_linked = is the target of the existing symlink
					if ($tombstone->is_linked) {
						gh_log(DEBUG, "  Updating symlink at $landing_zone/$target_full_path to point to $tombstone->path");
						if (gh_recycle("$landing_zone/$target_full_path")) {
	 						@symlink($tombstone->path, "$landing_zone/$target_full_path");
							// Creating this symlink can fail if the parent dir was removed
						}
					}
				} else {
					gh_log(WARN, "    Warning! An error occured while renaming file copy $old_path to $tombstone->path.");
				}
				$existing_tombstones[$i] = $tombstone;
			}
			remove_tombstones($share, $path, $filename);
			save_tombstones($share, $target_path, $target_filename, $existing_tombstones);

			if (is_link("$landing_zone/$full_path") && !file_exists(readlink("$landing_zone/$full_path"))) {
				gh_log(DEBUG, "  Removing deprecated symlink at $landing_zone/$full_path");
				unlink("$landing_zone/$full_path");
			}
		}
	}
	$sleep_before_task = array();
}

function gh_file_exists($real_path, $log_message=null) {
	clearstatcache();
	if (!file_exists($real_path)) {
		if ($log_message != null) {
			eval('$log_message = "' . str_replace('"', '\"', $log_message) . '";');
			gh_log(DEBUG, $log_message);
		}
		return FALSE;
	}
	return TRUE;
}

function get_num_copies($share) {
	global $shares_options, $storage_pool_directories;
	if (!isset($shares_options[$share]['num_copies'])) {
		global $config_file;
		gh_log(CRITICAL, "Found a share ($share_name) with no 'num_copies' value defined in $config_file. You need to edit $config_file to fix this, then restart Greyhole.");
	}
	$num_copies = $shares_options[$share]['num_copies'];
	if ($num_copies < 1) {
		$num_copies = 1;
	}
	if ($num_copies > count($storage_pool_directories)) {
		$num_copies = count($storage_pool_directories);
	}
	return $num_copies;
}

function file_is_locked($share, $full_path) {
	$landing_zone = get_share_landing_zone($share);
	
	$real_fullpath = "$landing_zone/$full_path";
	$result = exec("lsof -M -n -P -l " . quoted_form($real_fullpath) . " 2> /dev/null");
	if (strpos($result, $real_fullpath) !== FALSE) {
		return $result;
	}
	$query = sprintf("SELECT * FROM tasks WHERE complete = 'no' AND action = 'write' AND share = '%s' AND full_path = '%s' LIMIT 1",
		$share,
		mysql_escape_string($full_path)
	);
	$result = mysql_query($query) or gh_log(CRITICAL, "Error querying tasks for locked files: " . mysql_error());
	return mysql_num_rows($result) > 0;
}

function real_file_is_locked($real_fullpath) {
	$result = exec("lsof -M -n -P -l " . quoted_form($real_fullpath) . " 2> /dev/null");
	if (strpos($result, $real_fullpath) !== FALSE) {
		return $result;
	}
	return FALSE;
}

function gh_write($share, $full_path, $task_id) {
	global $storage_pool_directories, $log_level, $sleep_before_task;
	
	$landing_zone = get_share_landing_zone($share);
	
	if (!gh_file_exists("$landing_zone/$full_path", 'File write: $real_path doesn\'t exist anymore. Skipping.')) {
		if (!gh_file_exists($landing_zone, '  Share "'.$share.'" landing zone "$real_path" doesn\'t exist anymore. Will not process this task until it re-appears...')) {
			$sleep_before_task[] = $task_id;
			return 1;
		}
		return 0;
	}
	
	$num_copies_required = get_num_copies($share);

	list($path, $filename) = explode_full_path($full_path);

	if (is_link("$landing_zone/$full_path")) {
		$source_file = clean_dir(readlink("$landing_zone/$full_path"));
		gh_log(INFO, "File changed: $share/$full_path", FALSE);
		if ($log_level === DEBUG) {
			clearstatcache();
			$filesize = filesize($source_file);
			gh_log(DEBUG, " - " . number_format($filesize) . " bytes", FALSE);
		}
		gh_log(INFO, "");
		gh_log(DEBUG, "  Will use source file: $source_file");

		$existing_tombstones = get_tombstones($share, $path, $filename, FALSE, TRUE);
		
		// Remove old copies (but not the one that was updated!)
		$keys_to_remove = array();
		$found_source_file = FALSE;
		foreach ($existing_tombstones as $key => $tombstone) {
			$tombstone->path = clean_dir($tombstone->path);
			if ($tombstone->path == $source_file) {
				$tombstone->is_linked = TRUE;
				$tombstone->state = 'OK';
				$found_source_file = TRUE;
			} else {
				gh_log(DEBUG, "  Will remove copy at $tombstone->path");
				$keys_to_remove[] = $key;
			}
			$file_tombstones[$key] = $tombstone;
		}
		if (!$found_source_file) {
			// This shouldn't happen, but if we're about to remove all copies, let's make sure we keep at least one.
			$key = array_shift($keys_to_remove);
			$source_file = $existing_tombstones[$key]->path;
			gh_log(DEBUG, "  Change of mind... Will use source file: $source_file");
		}
		foreach ($keys_to_remove as $key) {
			if ($existing_tombstones[$key]->path != $source_file) {
				gh_recycle($existing_tombstones[$key]->path);
			}
			unset($existing_tombstones[$key]);
		}
	} else {
		$source_file = clean_dir("$landing_zone/$full_path");
		gh_log(INFO, "File created: $share/$full_path", FALSE);
		if ($log_level === DEBUG) {
			clearstatcache();
			$filesize = filesize($source_file);
			gh_log(DEBUG, " - " . number_format($filesize) . " bytes", FALSE);
		}
		gh_log(INFO, "");

		// There might be old tombstones... for example, when a delete task was skipped.
		// Let's remove the file copies if there are any leftovers; correct copies will be re-created in create_copies_from_tombstones()
		$existing_tombstones = get_tombstones($share, $path, $filename);
		if (count($existing_tombstones) > 0) {
			foreach ($existing_tombstones as $tombstone) {
				gh_recycle($tombstone->path);
			}
			remove_tombstones($share, $path, $filename);
			$existing_tombstones = array();
		}
	}

	// Only need to check for locking if we have something to do!
	if ($num_copies_required > 1 || count($existing_tombstones) == 0) {
		// Check if another process locked this file before we work on it.
		if (($locked_by = file_is_locked($share, $full_path)) !== FALSE) {
			gh_log(DEBUG, "  File is locked by another process. Will wait until it's unlocked to work on it.");
			$sleep_before_task[] = $task_id;
			return 1;
		}
		$sleep_before_task = array();
	}
	
	$tombstones = create_tombstones($share, $full_path, $num_copies_required, $filesize, $existing_tombstones);

	// Use the 1st tombstone for the symlink; it might be on a sticky drive.
	$i = 0;
	foreach ($tombstones as $tombstone) {
		$tombstone->is_linked = ($i++ == 0);
	}

	save_tombstones($share, $path, $filename, $tombstones);

	create_copies_from_tombstones($tombstones, $share, $full_path, $source_file);

	return 0;
}

function is_greyhole_owned_dir($path) {
	return file_exists("$path/.greyhole_uses_this");
}

function create_copies_from_tombstones($tombstones, $share, $full_path, $source_file) {
	$landing_zone = get_share_landing_zone($share);
	
	list($path, $filename) = explode_full_path($full_path);

	$link_next = FALSE;
	foreach ($tombstones as $key => $tombstone) {
		if (!gh_file_exists("$landing_zone/$full_path", '  $real_path doesn\'t exist anymore. Aborting.')) { return; }
		
		if ($tombstone->path == $source_file && $tombstone->state == 'OK') {
			gh_log(DEBUG, "  File copy at $tombstone->path is already up to date.");
			continue;
		}

		gh_log(DEBUG, "  Copying file to $tombstone->path");

		$root_path = str_replace(clean_dir("/$share/$full_path"), '', $tombstone->path);
		if (!is_greyhole_owned_dir($root_path)) {
			gh_log(WARN, "  Warning! It seems $root_path is missing it's \".greyhole_uses_this\" file. This either means this mount is currently unmounted, or you forgot to create this file.");
			$tombstone->state = 'Gone';
			$tombstones[$key] = $tombstone;
			continue;
		}

		list($tombstone_dir_path, $tombstone_filename) = explode_full_path($tombstone->path);

		list($original_path, $tombstone_filename) = explode_full_path(get_share_landing_zone($share) . "/$full_path");
		if (!gh_mkdir($tombstone_dir_path, "$root_path/$share", $original_path)) {
			$tombstone->state = 'Gone';
			$tombstones[$key] = $tombstone;
			continue;
		}

		$temp_path = get_temp_filename($tombstone->path);
		$file_infos = gh_get_file_infos("$landing_zone/$full_path");
		if (!is_link("$landing_zone/$full_path") && is_file("$landing_zone/$full_path")) {
			$it_worked = rename("$landing_zone/$full_path", $temp_path);
		} else {
			$it_worked = copy("$landing_zone/$full_path", $temp_path);
		}
		if ($it_worked) {
			rename($temp_path, $tombstone->path);
			gh_chperm($tombstone->path, $file_infos);
		} else {
			gh_log(WARN, "    Failed file copy. Skipping.");
			if ($tombstone->is_linked) {
				$tombstone->is_linked = FALSE;
				$link_next = TRUE;
			}
			$tombstone->state = 'Gone';
			$tombstones[$key] = $tombstone;
			continue;
		}

		if ($link_next && !$tombstone->is_linked) {
			$tombstone->is_linked = TRUE;
			$tombstones[$key] = $tombstone;
			$link_next = FALSE;
		}
		if ($tombstone->is_linked) {
			gh_log(DEBUG, "    Creating symlink in share pointing to the above file copy.");
			symlink($tombstone->path, "$landing_zone/$path/.gh_$filename");
			if (!file_exists("$landing_zone/$full_path") || gh_recycle("$landing_zone/$full_path")) {
				rename("$landing_zone/$path/.gh_$filename", "$landing_zone/$path/$filename");
			} else {
				unlink("$landing_zone/$path/.gh_$filename");
			}
		}

		if (gh_file_exists($tombstone->path, '  Copy at $real_path doesn\'t exist. Will not mark it OK!')) {
			$tombstone->state = 'OK';
			$tombstones[$key] = $tombstone;
		}
		save_tombstones($share, $path, $filename, array_values($tombstones));
	}
}

function gh_chperm($real_file_path, $file_infos) {
	chmod($real_file_path, $file_infos->fileperms);
	chown($real_file_path, $file_infos->fileowner);
	chgrp($real_file_path, $file_infos->filegroup);
}

function gh_mkdir($directory, $root_path, $original_directory) {
	$root_path = '/' . trim($root_path, '/');
	if (!is_dir($directory)) {
		$dir_infos = gh_get_file_infos($original_directory);
		// Try simple mkdir; will work only if parent dir already exists
		if (!@mkdir($directory, $dir_infos->fileperms)) {
			// Try recursive mkdir
			if (!mkdir($directory, $dir_infos->fileperms, TRUE)) {
				gh_log(WARN, "  Failed to create directory $directory");
				return FALSE;
			}
			// Need to chown/chgrp parent dirs too
			$parent_directory = $directory;
			$original_parent_directory = $original_directory;
			$i = 0;
			while ($parent_directory != $root_path && $i++ < 255) {
				$dir_infos = gh_get_file_infos($original_parent_directory);
				chmod($parent_directory, $dir_infos->fileperms);
				chown($parent_directory, $dir_infos->fileowner);
				chgrp($parent_directory, $dir_infos->filegroup);
				list($parent_directory, $directory_name) = explode_full_path($parent_directory);
				list($original_parent_directory, $directory_name) = explode_full_path($original_parent_directory);
			}
		} else {
			// Simple mkdir worked
			chown($directory, $dir_infos->fileowner);
			chgrp($directory, $dir_infos->filegroup);
		}
	}
	return TRUE;
}

function get_temp_filename($full_path) {
	list($path, $filename) = explode_full_path($full_path);
	return "$path/.$filename." . substr(md5($filename), 0, 5);
}

function create_tombstones($share, $full_path, $num_copies_required, $filesize, $tombstones=array()) {
	list($path, $filename) = explode_full_path($full_path);
	
	$num_ok = count($tombstones);
	foreach ($tombstones as $key => $tombstone) {
		if (!file_exists($tombstone->path)) {
			$tombstone->state = 'Gone';
		}
		if ($tombstone->state != 'OK' && $tombstone->state != 'Pending') {
			$num_ok--;
		}
		if ($key != $tombstone->path) {
			unset($tombstones[$key]);
			$key = $tombstone->path;
		}
		$tombstones[$key] = $tombstone;
	}

	// Select drives that have enough free space for this file
	if ($num_ok < $num_copies_required) {
		$local_target_drives = order_target_drives($filesize/1024, FALSE, $share, $path);
	}
	while ($num_ok < $num_copies_required && count($local_target_drives) > 0) {
		$target_drive = array_shift($local_target_drives);
		$clean_target_full_path = clean_dir("$target_drive/$share/$full_path");
		if (isset($tombstones[$clean_target_full_path])) {
			continue;
		}
		// Prepend new target drives, to make sure sticky directories will be used first
		$tombstones = array_reverse($tombstones);
		$tombstones[$clean_target_full_path] = (object) array('path' => $clean_target_full_path, 'is_linked' => count($tombstones) == 0, 'state' => 'Pending');
		$tombstones = array_reverse($tombstones);
		$num_ok++;
	}
	return $tombstones;
}

function get_tombstone_data_filename($share, $path, $filename) {
	foreach (get_graveyards() as $graveyard) {
		$f = "$graveyard/$share/$path/$filename";
		if (file_exists($f)) {
			return $f;
		}
	}
	return FALSE;
}

function get_tombstones_for_dir($share, $path, $load_nok_tombstones, $quiet, $prefix='') {
	$landing_zone = get_share_landing_zone($share);
	
	$tombstones = array();
	
	// Find new files (files with no tombstones yet)
	$handle = @opendir("$landing_zone/$path");
	if ($handle) {
		while (($filename = readdir($handle)) !== FALSE) {
			if ($filename != '.' && $filename != '..') {
				if (is_dir("$landing_zone/$path/$filename")) {
					foreach (get_tombstones_for_dir($share, "$path/$filename", $load_nok_tombstones, $quiet, $prefix.$filename.'/') as $filename => $file_tombstones) {
						$tombstones[$filename] = $file_tombstones;
					}
				} else if (is_file("$landing_zone/$path/$filename") && !is_link("$landing_zone/$path/$filename")) {
					// Found a file in a renamed directory that has no tombstone. Let's queue it for processing.
					gh_log(DEBUG, "$share/$path/$filename is a file (not a symlink). Adding a new 'write' pending task for that file.");
					$query = sprintf("INSERT INTO tasks (action, share, full_path, complete) VALUES ('write', '%s', '%s', 'yes')",
						mysql_escape_string($share),
						mysql_escape_string(clean_dir("$path/$filename"))
					);
					mysql_query($query) or gh_log(CRITICAL, "Can't insert write task: " . mysql_error());
				}
			}
		}
	}

	foreach (get_graveyards() as $graveyard) {
		$handle = @opendir("$graveyard/$share/$path");
		if (!$handle) {
			#gh_log(DEBUG, "Got 0 tombstones ($graveyard/$share/$path does't exists).");
			continue;
		}
		while (($filename = readdir($handle)) !== FALSE) {
			if ($filename != '.' && $filename != '..') {
				if (is_dir("$graveyard/$share/$path/$filename")) {
					foreach (get_tombstones_for_dir($share, "$path/$filename", $load_nok_tombstones, $quiet, $prefix.$filename.'/') as $filename => $file_tombstones) {
						$tombstones[$filename] = $file_tombstones;
					}
				} else {
					// Found a file
					$tombstones[$prefix.$filename] = get_tombstones($share, $path, $filename, $load_nok_tombstones, $quiet);
					if (count($tombstones[$prefix.$filename]) == 0 && is_file("$landing_zone/$path/$filename") && !is_link("$landing_zone/$path/$filename")) {
						// Found a file in a renamed directory that has no tombstone. Let's queue it for processing.
						gh_log(DEBUG, "$share/$path/$filename is a file (not a symlink). Adding a new 'write' pending task for that file.");
						$query = sprintf("INSERT INTO tasks (action, share, full_path, complete) VALUES ('write', '%s', '%s', 'yes')",
							mysql_escape_string($share),
							mysql_escape_string(clean_dir("$path/$filename"))
						);
						mysql_query($query) or gh_log(CRITICAL, "Can't insert write task: " . mysql_error());
					}
				}
			}
		}
		closedir($handle);
	}

	return $tombstones;
}

function get_tombstones($share, $path, $filename=null, $load_nok_tombstones=FALSE, $quiet=FALSE) {
	if (!$quiet) {
		gh_log(DEBUG, "Loading tombstones for " . ($filename === null ? '(dir) ' : '') . "$share" . (!empty($path) ? "/$path" : "") . "" . ($filename!== null ? "/$filename" : "") . "... ", FALSE);
		if ($filename === null) {
			gh_log(DEBUG, "");
		}
	}
	if ($filename === null) {
		// Load all tombstones from the specified directory
		$tombstones = get_tombstones_for_dir($share, $path, $load_nok_tombstones, $quiet);
		return $tombstones;
	}
	$tombstones_data_file = get_tombstone_data_filename($share, $path, $filename);
	clearstatcache();
	$tombstones = array();
	if (file_exists($tombstones_data_file)) {
		if (($fp = fopen($tombstones_data_file, 'r'))) {
			$t = '';
			while (!feof($fp)) {
				$t .= fread($fp, 1024);
			}
			$tombstones = unserialize($t);
			fclose($fp);
		}
	}

	// Fix wrong 'is_linked' flags
	$share_file_link_to = FALSE;
	if (is_link($share_file)) {
		$share_file = get_share_landing_zone($share) . "/$path/$filename";
		$share_file_link_to = readlink($share_file);
	}
	foreach ($tombstones as $key => $tombstone) {
		if ($tombstone->state == 'OK') {
			if ($tombstone->is_linked && $tombstone->path != $share_file_link_to && $share_file_link_to !== FALSE) {
				gh_log(DEBUG, 'Changing is_linked to FALSE for ' . $tombstone->path);
				$tombstone->is_linked = FALSE;
				$tombstones[$key] = $tombstone;
				save_tombstones($share, $path, $filename, array_values($tombstones));
			} else if (!$tombstone->is_linked && $tombstone->path == $share_file_link_to && $share_file_link_to !== FALSE) {
				gh_log(DEBUG, 'Changing is_linked to TRUE for ' . $tombstone->path);
				$tombstone->is_linked = TRUE;
				$tombstones[$key] = $tombstone;
				save_tombstones($share, $path, $filename, array_values($tombstones));
			}
		}
	}

	if (!$load_nok_tombstones) {
		$ok_tombstones = array();
		foreach ($tombstones as $key => $tombstone) {
			if ($tombstone->state == 'OK') {
				$valid_path = FALSE;
				global $storage_pool_directories;
				foreach ($storage_pool_directories as $dir) {
					if (strpos($tombstone->path, $dir) === 0) {
						$valid_path = TRUE;
						break;
					}
				}
				if ($valid_path) {
					$ok_tombstones[$key] = $tombstone;
				} else {
					gh_log(INFO, "Found a tombstone pointing to a directory not defined in your storage pool: '$tombstone->path'. Will mark it as Gone.");
					$tombstone->state = 'Gone';
					$tombstones[$key] = $tombstone;
					save_tombstones($share, $path, $filename, array_values($tombstones));
				}
			}
		}
		$tombstones = $ok_tombstones;
	}
	if (!$quiet) {
		gh_log(DEBUG, "Got " . count($tombstones) . " tombstones.");
	}
	return $tombstones;
}

function remove_tombstones($share, $path, $filename) {
	gh_log(DEBUG, "  Removing tombstones for $share" . (!empty($path) ? "/$path" : "") . ($filename!== null ? "/$filename" : ""));
	while (($f = get_tombstone_data_filename($share, $path, $filename)) !== FALSE) {
		@unlink($f);
		gh_log(DEBUG, "    Removed tombstone at $f");
		clearstatcache();
	}
}

function save_tombstones($share, $path, $filename, $tombstones) {
	if (count($tombstones) == 0) {
		remove_tombstones($share, $path, $filename);
		return;
	}

	gh_log(DEBUG, "  Saving " . count($tombstones) . " tombstones for $share" . (!empty($path) ? "/$path" : "") . ($filename!== null ? "/$filename" : ""));
	foreach (get_graveyards() as $graveyard) {
		$target_drive = str_replace('/.gh_graveyard', '', $graveyard);
		$data_filepath = "$graveyard/$share/$path";
		$has_tombstone = FALSE;
		foreach ($tombstones as $tombstone) {
			if (strpos($tombstone->path, $target_drive) === 0) {
				gh_mkdir($data_filepath, "$graveyard/$share", get_share_landing_zone($share) . "/$path");
				file_put_contents("$data_filepath/$filename", serialize($tombstones));
				gh_log(DEBUG, "    Saved tombstones in $data_filepath/$filename");
				$has_tombstone = TRUE;
				break;
			}
		}
		if (!$has_tombstone && file_exists("$data_filepath/$filename")) {
			unlink("$data_filepath/$filename");
		}
	}
}

function simplify_tasks() {
	global $action;
	$action = 'simplify_tasks';
	
	gh_log(DEBUG, "Simplifying pending tasks.");
	
	// Delete duplicate writes/renames
	$query = "SELECT GROUP_CONCAT(id) ids, action, share, full_path, additional_info FROM tasks WHERE action IN ('write', 'rename') GROUP BY action, share, full_path, additional_info HAVING COUNT(*) > 1";
	$result = mysql_query($query) or gh_log(CRITICAL, "Can't select duplicate tasks: " . mysql_error());
	while ($row = mysql_fetch_object($result)) {
		$ids = explode(',', $row->ids);
		sort($ids);
		array_pop($ids);
		gh_log(DEBUG, "  Removing " . count($ids) . " duplicate pending tasks for $row->share/" . (!empty($row->full_path) ? $row->full_path : '') . (!empty($row->additional_info) ? " -> $row->additional_info" : ''));
		
		$ids = implode(',', $ids);
		if ($ids[0] == ',') {
			$ids = substr($ids, 1);
		}
		$query = sprintf("DELETE FROM tasks WHERE id IN (%s)",
			$ids
		);
		mysql_query($query) or gh_log(CRITICAL, "Can't delete duplicate tasks: " . mysql_error());
	}
	mysql_free_result($result);
	
	// Remove locked write tasks
	$query = "SELECT share, full_path FROM tasks WHERE action = 'write' and complete = 'no'";
	$result = mysql_query($query) or gh_log(CRITICAL, "Can't select locked write tasks: " . mysql_error());
	while ($row = mysql_fetch_object($result)) {
		$query = sprintf("DELETE FROM tasks WHERE action = 'write' and complete = 'yes' AND share = '%s' AND full_path = '%s'",
			mysql_escape_string($row->share),
			mysql_escape_string($row->full_path)
		);
		mysql_query($query) or gh_log(CRITICAL, "Can't delete duplicate of locked write task: " . mysql_error());
	}
}

function parse_samba_log($simplify_after_parse=TRUE) {
	global $samba_log_file, $action;
	$action = 'parse_logs';

	$query = sprintf("SELECT value FROM settings WHERE name = '%s'", 'last_read_log_smbd_line');
	$result = mysql_query($query) or gh_log(CRITICAL, "Can't query settings for 'last_read_log_smbd_line': " . mysql_error());
	if (mysql_num_rows($result) != 1) {
		gh_log(CRITICAL, "Received " . mysql_num_rows($result) . " rows when querying settings for 'last_read_log_smbd_line'; expected one.");
	}
	$row = mysql_fetch_object($result);
	mysql_free_result($result);

	$f_seek_point = (int) $row->value;

	clearstatcache();
	if ($f_seek_point > filesize($samba_log_file)) {
		gh_log(DEBUG, "Log file size = " . filesize($samba_log_file) . "; forcing seek point to 0.");
		$f_seek_point = 0;
	}

	$fp = fopen($samba_log_file, 'r') or gh_log(CRITICAL, "Can't open Samba log file '$samba_log_file' for reading.");
	fseek($fp, $f_seek_point);

	$new_tasks = 0;
	$last_line = FALSE;
	$act = FALSE;
	while ($line = fgets($fp)) {
		if (($p = strpos($line, ' smbd_greyhole:')) !== FALSE) {
			$line = trim(substr($line, $p+16));

			// Prevent insertion of unneeded duplicates
			if ($line === $last_line) {
				continue;
			}
			$last_line = $line;

			// Close logs are only processed when no more duplicates are found, so we'll execute this now that a non-duplicate line was found.
			if ($act === 'close') {
				$query = sprintf("UPDATE tasks SET additional_info = NULL, complete = 'yes' WHERE complete = 'no' AND share = '%s' AND additional_info = '%s'",
					mysql_escape_string($share),
					$fd
				);
				mysql_query($query) or gh_log(CRITICAL, "Error updating tasks: " . mysql_error() . "; Query: $query");
			}

			$line = explode('*', $line);
			$act = array_shift($line);
			$share = array_shift($line);
			if ($act == 'mkdir') {
				// Nothing to do with those
				continue;
			}
			$result = array_pop($line);
			if (strpos($result, 'failed') === 0) {
				gh_log(DEBUG, "Failed $act in $share/$line[0]. Skipping.");
				continue;
			}
			unset($fullpath);
			unset($fullpath_target);
			unset($fd);
			switch ($act) {
				case 'open':
					$fullpath = array_shift($line);
					$fd = array_shift($line);
					$act = 'write';
					break;
				case 'rmdir':
				case 'unlink':
					$fullpath = array_shift($line);
					break;
				case 'rename':
					$fullpath = array_shift($line);
					$fullpath_target = array_shift($line);
					break;
				case 'close':
					$fd = array_shift($line);
					break;
				default:
					$act = FALSE;
					continue;
			}
			if ($act === FALSE) {
				continue;
			}

			// Close logs are only processed when no more duplicates are found, so we won't execute it just yet; we'll process it the next time we find a non-duplicate line.
			if ($act != 'close') {
				if (isset($fd) && $fd == -1) {
					continue;
				}
				$new_tasks++;
				$query = sprintf("INSERT INTO tasks (action, share, full_path, additional_info, complete) VALUES ('%s', '%s', %s, %s, '%s')",
					$act,
					mysql_escape_string($share),
					isset($fullpath) ? "'".mysql_escape_string(clean_dir($fullpath))."'" : 'NULL',
					isset($fullpath_target) ? "'".mysql_escape_string(clean_dir($fullpath_target))."'" : (isset($fd) ? "'$fd'" : 'NULL'),
					$act == 'write' ? 'no' : 'yes'
				);
			}

			mysql_query($query) or gh_log(CRITICAL, "Error inserting task: " . mysql_error() . "; Query: $query");
		}
	}
	$f_seek_point = ftell($fp);
	fclose($fp);

	// Close logs are only processed when no more duplicates are found, so we'll execute this now that we're done parsing the current log.
	if ($act == 'close') {
		$query = sprintf("UPDATE tasks SET additional_info = NULL, complete = 'yes' WHERE complete = 'no' AND share = '%s' AND additional_info = '%s'",
			mysql_escape_string($share),
			$fd
		);
		mysql_query($query) or gh_log(CRITICAL, "Error updating tasks: " . mysql_error() . "; Query: $query");
	}
	
	$query = sprintf("UPDATE settings SET value = '%d' WHERE name = '%s'", $f_seek_point, 'last_read_log_smbd_line');
	mysql_query($query) or gh_log(CRITICAL, "Can't update settings for 'last_read_log_smbd_line': " . mysql_error());
	
	if ($simplify_after_parse && $new_tasks > 0) {
		$query = "SELECT COUNT(*) num_rows FROM tasks";
		$result = mysql_query($query) or gh_log(CRITICAL, "Can't get tasks count: " . mysql_error());
		$row = mysql_fetch_object($result);
		mysql_free_result($result);
		$num_rows = (int) $row->num_rows;
		if ($num_rows < 1000 || $num_rows % 5 == 0) { // Runs 1/5 of the times when num_rows > 1000
			if ($num_rows < 5000 || $num_rows % 100 == 0) { // Runs 1/100 of the times when num_rows > 5000
				simplify_tasks();
			}
		}
	}
}

function get_free_space_in_storage_pool_dirs() {
	global $storage_pool_directories, $df_command, $last_df_time, $last_dfs, $df_cache_time;
	if ($last_df_time > time() - $df_cache_time) {
		return $last_dfs;
	}
	$dfs = array();
	exec($df_command, $responses);
	array_shift($responses); // header
	for ($i=0; $i<count($responses); $i++) {
		$response = explode(' ', $responses[$i]);
		$dfs[$storage_pool_directories[$i]] = (float) array_pop($response);
	}
	$last_df_time = time();
	$last_dfs = $dfs;
	return $dfs;
}

function order_target_drives($filesize_kb, $include_full_drives, $share, $path) {
	global $storage_pool_directories, $minimum_free_space_pool_directories, $dir_selection_algorithm, $last_OOS_notification, $sticky_files;
	$sorted_target_drives = array();
	$last_resort_sorted_target_drives = array();
	$full_drives = array();

	$dfs = get_free_space_in_storage_pool_dirs();

	foreach ($storage_pool_directories as $target_drive) {
		if (!isset($dfs[$target_drive])) {
			continue;
		}
		$free_space = $dfs[$target_drive];
		$minimum_free_space = (float) (isset($minimum_free_space_pool_directories[$target_drive]) ? $minimum_free_space_pool_directories[$target_drive]*1024*1024 : 0.0);
		$available_space = (float) $free_space - $minimum_free_space;
		if ($available_space <= $filesize_kb) {
			if ($free_space > $filesize_kb) {
				while (isset($last_resort_sorted_target_drives[$free_space])) {
					$free_space -= 0.001;
				}
				$last_resort_sorted_target_drives[$free_space] = $target_drive;
			} else {
				while (isset($full_drives[$free_space])) {
					$free_space -= 0.001;
				}
				$full_drives[$free_space] = $target_drive;
			}
			continue;
		}
		while (isset($sorted_target_drives[$available_space])) {
			$available_space -= 0.001;
		}
		$sorted_target_drives[$available_space] = $target_drive;
	}
	if ($dir_selection_algorithm == 'most_available_space') {
		krsort($sorted_target_drives);
		krsort($last_resort_sorted_target_drives);
	}
	
	// Email notification when all dirs are over-capacity
	if (count($sorted_target_drives) == 0) {
		gh_log(WARN, "  Warning! All storage pool directories are over-capacity!");
		if (!isset($last_OOS_notification)) {
			$query = sprintf("SELECT value FROM settings WHERE name = '%s'", 'last_OOS_notification');
			$result = mysql_query($query) or gh_log(CRITICAL, "Can't query settings for 'last_OOS_notification': " . mysql_error());
			if (mysql_num_rows($result) != 1) {
				gh_log(CRITICAL, "Received " . mysql_num_rows($result) . " rows when querying settings for 'last_OOS_notification'; expected one.");
			}
			$row = mysql_fetch_object($result);
			mysql_free_result($result);
			$last_OOS_notification = $row->value;
		}
		if ($last_OOS_notification < strtotime('-1 day')) {
			global $email_to;

			gh_log(INFO, "  Sending email notification to $email_to");

			$hostname = exec('hostname');
			$body = "This is an automated email from Greyhole.

It appears all the defined storage pool directories are over-capacity.
You probably want to do something about this!

";
			foreach ($last_resort_sorted_target_drives as $free_space => $target_drive) {
				$minimum_free_space = (int) (isset($minimum_free_space_pool_directories[$target_drive]) ? $minimum_free_space_pool_directories[$target_drive] : 0);
				$body .= "$target_drive has " . number_format($free_space/1024/1024, 2) . " GB free; minimum specified in greyhole.conf: $minimum_free_space GB.\n";
			}
			mail($email_to, "Greyhole is out of space on $hostname!", $body);
			
			$last_OOS_notification = time();
			$query = sprintf("UPDATE settings SET value = '%s' WHERE name = '%s'", $last_OOS_notification, 'last_OOS_notification');
			mysql_query($query) or gh_log(CRITICAL, "Can't update settings for 'last_OOS_notification': " . mysql_error());
		}
	}

	if ($dir_selection_algorithm == 'random') {
		shuffle($sorted_target_drives);
		shuffle($last_resort_sorted_target_drives);
	}
	
	global $log_level;
	if ($log_level === DEBUG) {
		$log = "Drives with available space: ";
		foreach ($sorted_target_drives as $s => $d) {
			$log .= "$d (" . round($s/1024/1024) . " GB avail) - ";
		}
		$log = substr($log, 0, strlen($log)-2);
		if (count($last_resort_sorted_target_drives) > 0) {
			$log .= "; Drives with free space, but no available space: ";
			foreach ($last_resort_sorted_target_drives as $s => $d) {
				$log .= "$d (" . round($s/1024/1024) . " GB free) - ";
			}
			$log = substr($log, 0, strlen($log)-2);
		}
		if (count($full_drives) > 0) {
			$log .= "; Drives full: ";
			foreach ($full_drives as $s => $d) {
				$log .= "$d (" . round($s/1024) . " MB free) - ";
			}
			$log = substr($log, 0, strlen($log)-2);
		}
		gh_log(DEBUG, $log);
	}
	
	$drives = array_merge($sorted_target_drives, $last_resort_sorted_target_drives);
	if ($include_full_drives) {
		$drives = array_merge($drives, $full_drives);
	}

	if (isset($sticky_files)) {
		foreach ($sticky_files as $share_dir => $stick_into) {
			if (strpos("$share/$path", $share_dir) === 0) {
				if (count($stick_into) == 0) {
					// Stick files into any drives
					$query = sprintf("SELECT value FROM settings WHERE name = 'stick_into-%s'",
						mysql_escape_string($share_dir)
					);
					$result = mysql_query($query) or gh_log(CRITICAL, "Can't query settings for stick_target-$share_dir: " . mysql_error());
					if (mysql_num_rows($result) == 1) {
						$row = mysql_fetch_object($result);
						$stick_into = unserialize($row->value);
					} else {
						$value = serialize($drives);
						$query = sprintf("INSERT INTO settings (name, value) VALUES ('stick_into-%s', '%s')",
							mysql_escape_string($share_dir),
							mysql_escape_string($value)
						);
						mysql_query($query) or gh_log(CRITICAL, "Can't insert new settings for stick_into-$share_dir: " . mysql_error());
						return $drives;
					}
				} else {
					// Stick files into specific drives: $stick_into
				}
				
				// Make sure the drives we want to use are not yet full
				$priority_drives = array();
				foreach ($stick_into as $stick_into_dir) {
					if (array_search($stick_into_dir, $full_drives) === FALSE) {
						unset($drives[array_search($stick_into_dir, $drives)]);
						$priority_drives[] = $stick_into_dir;
					}
				}
				$drives = array_merge($priority_drives, $drives);
			}
		}
	}

	return $drives;
}

function gh_fsck($path, $share) {
	global $storage_pool_directories, $fsck_report;
	
	gh_log(DEBUG, "Entering $path");
	$fsck_report['landing_zone']['num_dirs']++;

	$list = array();
	$handle = opendir($path);
	if ($handle === FALSE) {
		gh_log(ERROR, "  Couldn't open $path to list content. Skipping...");
		return;
	}
	while (($filename = readdir($handle)) !== FALSE) {
		if ($filename != '.' && $filename != '..') {
			$full_path = "$path/$filename";
			$file_type = @filetype($full_path);
			if ($file_type == 'dir') {
				gh_fsck($full_path, $share);
			} else {
				$fsck_report['landing_zone']['num_files']++;
				gh_fsck_file($path, $filename, $file_type, 'landing_zone', $share);
			}
		}
	}
	closedir($handle);
}

function gh_fsck_graveyard($root, $path, $share) {
	global $fsck_report;
	
	gh_log(DEBUG, "Entering graveyard $root$path");
	if (!is_dir("$root$path")) {
		gh_log(DEBUG, "  Not a directory... Aborting.");
		return;
	}

	$handle = opendir("$root$path");
	while (($filename = readdir($handle)) !== FALSE) {
		if ($filename != '.' && $filename != '..') {
			if (@is_dir("$root$path/$filename")) {
				$fsck_report['graveyard']['num_dirs']++;
				gh_fsck_graveyard($root, "$path/$filename", $share);
			} else {
				// Found a tombstone
				$fsck_report['graveyard']['num_files']++;
				
				$path_parts = explode('/', $path);
				array_shift($path_parts);
				$share = array_shift($path_parts);
				$landing_zone = get_share_landing_zone($share);
				$local_path = $landing_zone . '/' . implode('/', $path_parts);
				
				// If file exists in landing zone, we already fsck-ed it in gh_fsck(); let's not repeat ourselves, shall we?
				if (!file_exists("$local_path/$filename")) {
					gh_fsck_file($local_path, $filename, FALSE, 'graveyard', $share);
				#} else {
				#	gh_log(DEBUG, "File $local_path/$filename was already checked.");
				}
			}
		}
	}
	closedir($handle);
}

function gh_fsck_file($path, $filename, $file_type, $source, $share) {
	global $storage_pool_directories, $fsck_report;

	$landing_zone = get_share_landing_zone($share);

	$file_path = substr($path, strlen($landing_zone)+1);

	if ($file_type == 'file') {
		// Let's just add a 'write' task for this file; if it's a duplicate of an already pending task, it won't be processed twice, since the simplify function will remove such duplicates.
		gh_log(DEBUG, "$path/$filename is a file (not a symlink). Adding a new 'write' pending task for that file.");
		$query = sprintf("INSERT INTO tasks (action, share, full_path, complete) VALUES ('write', '%s', '%s', 'yes')",
			mysql_escape_string($share),
			mysql_escape_string(clean_dir("$file_path/$filename"))
		);
		mysql_query($query) or gh_log(CRITICAL, "Can't insert write task: " . mysql_error());
		return;
	} else {
		if ($file_type == 'link' && !file_exists(readlink("$path/$filename"))) {
			// Link points to now gone copy; let's just remove it, and treat this as if the link was not there in the first place.
			unlink("$path/$filename");
			$file_type = FALSE;
		}
		if ($file_type === FALSE) {
			gh_log(INFO, "$path/$filename is missing from the share directory. Will try to re-create it, if copies are available.");
			$fsck_report['not_in_landing']++;
		}
	}

	$file_tombstones = array();
	$num_ok = 0;
	$file_copies_inodes = array();

	// Look for this file on all available drives
	foreach ($storage_pool_directories as $target_drive) {
		$inode_number = @fileinode("$target_drive/$share/$file_path/$filename");
		if ($inode_number !== FALSE) {
			if (is_dir("$target_drive/$share/$file_path/$filename")) {
				gh_log(DEBUG, "Found a directory that should be a file! Will try to remove it, if it's empty.");
				@rmdir("$target_drive/$share/$file_path/$filename");
				continue;
			}
			if (!isset($source_real_path)) {
				$source_real_path = "$target_drive/$share/$file_path/$filename";
			}
			gh_log(DEBUG, "Found $target_drive/$share" . (!empty($file_path) ? "/$file_path" : '') . "/$filename");
			$clean_full_path = clean_dir("$target_drive/$share/$file_path/$filename");
			$file_tombstones[$clean_full_path] = (object) array('path' => $clean_full_path, 'is_linked' => FALSE, 'state' => 'OK');
			$file_copies_inodes[$inode_number] = "$target_drive/$share/$file_path/$filename";
			$num_ok++;
			
			// Temp files leftovers of stopped Greyhole executions
			$temp_filename = get_temp_filename("$target_drive/$share/$file_path/$filename");
			if (file_exists($temp_filename) && is_file($temp_filename)) {
				gh_log(INFO, "  Found temporary file $temp_filename ... deleting.");
				$fsck_report['temp_files'][] = $temp_filename;
				gh_recycle($temp_filename);
			}
		}
	}

	foreach (get_tombstones($share, $file_path, $filename, TRUE) as $tombstone) {
		$inode_number = @fileinode($tombstone->path);
		if ($inode_number === FALSE) {
			$tombstone->state = 'Gone';
			$tombstone->is_linked = FALSE;

			$root_path = str_replace(clean_dir("/$share/$file_path/$filename"), '', $tombstone->path);
			if (gone_ok($root_path)) {
				// Let's not replace this copy yet...
				$file_copies_inodes[$tombstone->path] = $tombstone->path;
				$num_ok++;
				$fsck_report['gone_ok']++;
			}
		} else if (is_dir($tombstone->path)) {
			gh_log(DEBUG, "Found a directory that should be a file! Will try to remove it, if it's empty.");
			@rmdir($tombstone->path);
			$tombstone->state = 'Gone';
			$tombstone->is_linked = FALSE;
			continue;
		} else {
			$tombstone->state = 'OK';
			if (!isset($file_tombstones[$tombstone->path])) {
				$file_copies_inodes[$inode_number] = $tombstone->path;
				$num_ok++;
			}
		}
		$file_tombstones[$tombstone->path] = $tombstone;
	}

	if (count($file_copies_inodes) > 0) {
		// If no tombstone is linked, link the 1st one
		$found_linked_tombstone = FALSE;
		foreach ($file_tombstones as $key => $tombstone) {
			if ($tombstone->is_linked) {
				if (file_exists($tombstone->path)) {
					$found_linked_tombstone = TRUE;
					$expected_file_size = filesize($tombstone->path);
					$original_file_path = $tombstone->path;
					break;
				} else {
					$tombstone->is_linked = FALSE;
					$tombstone->state = 'Gone';
				}
			}
		}
		if (!$found_linked_tombstone) {
			reset($file_tombstones)->is_linked = TRUE;
			$expected_file_size = filesize(reset($file_tombstones)->path);
			$original_file_path = reset($file_tombstones)->path;
		}
		
		// Check that all file copies have the same size
		foreach ($file_copies_inodes as $key => $real_full_path) {
			if (array_search($real_full_path, array_keys($file_copies_inodes)) !== FALSE) {
				// That file isn't available atm, but it's OK.
				continue;
			}
			$file_size = filesize($real_full_path);
			if ($file_size != $expected_file_size && real_file_is_locked($real_full_path) === FALSE && real_file_is_locked($original_file_path) === FALSE) {
				gh_log(WARN, "  A file copy with a different file size than the original was found: $real_full_path is " . number_format($file_size) . " bytes. Original: $original_file_path is " . number_format($expected_file_size) . " bytes.");
				$fsck_report['wrong_file_size'][clean_dir($real_full_path)] = array($file_size, $expected_file_size, $original_file_path);
				// Will not count that copy as a valid copy!
				unset($file_copies_inodes[$key]);
			}
		}
	}

	$num_copies_required = get_num_copies($share);
	
	if (count($file_copies_inodes) == $num_copies_required) {
		if (!$found_linked_tombstone || $file_type != 'link') {
			// Re-create symlink...
			if (!$found_linked_tombstone) {
				// ... the old one points to a drive that was replaced
				gh_log(INFO, '  Symlink target moved. Updating symlink.');
				$fsck_report['symlink_target_moved']++;
			} else {
				// ... it was missing
				gh_log(INFO, '  Symlink was missing. Creating new symlink.');
			}
			foreach ($file_tombstones as $key => $tombstone) {
				if ($tombstone->is_linked) {
					gh_log(DEBUG, "  Updating symlink at $landing_zone/$file_path/$filename to point to $tombstone->path");
					gh_recycle("$landing_zone/$file_path/$filename");
					gh_mkdir("$landing_zone/$file_path", "$landing_zone", null);
					symlink($tombstone->path, "$landing_zone/$file_path/$filename");
					break;
				}
			}
		}
		save_tombstones($share, $file_path, $filename, array_values($file_tombstones));
	} else if (count($file_copies_inodes) == 0) {
		gh_log(WARN, '  WARNING! No copies of this file are available. Deleting from share.');
		gh_recycle("$landing_zone/$file_path/$filename");
		if ($source == 'graveyard') {
			$fsck_report['not_in_landing']--;
		}
		if ($source == 'graveyard' || get_tombstone_data_filename($share, $file_path, $filename) !== FALSE) {
			$fsck_report['no_copies_found_files'][clean_dir("$share/$file_path/$filename")] = TRUE;
		}
		save_tombstones($share, $file_path, $filename, array_values($file_tombstones));
	} else if (count($file_copies_inodes) < $num_copies_required) {
		// Create new copies
		gh_log(INFO, "  Missing file copies. Expected $num_copies_required, got " . count($file_copies_inodes) . ". Will create more copies using $source_real_path");
		$fsck_report['missing_copies']++;
		clearstatcache(); $filesize = filesize("$source_real_path");
		$file_tombstones = create_tombstones($share, "$file_path/$filename", $num_copies_required, $filesize, $file_tombstones);

		// Re-copy the file everywhere, and re-create the symlink
		$symlink_created = FALSE;
		foreach ($file_tombstones as $key => $tombstone) {
			if ($source_real_path != $tombstone->path) {
				list($tombstone_dir_path, $tombstone_filename) = explode_full_path($tombstone->path);
				if ($tombstone->state != 'Gone') {
					$root_path = str_replace(clean_dir("/$share/$file_path"), '', $tombstone_dir_path);
					list($original_path, $tombstone_filename) = explode_full_path(get_share_landing_zone($share) . "/$file_path");
					if (!gh_mkdir($tombstone_dir_path, "$root_path/$share", $original_path)) {
						$tombstone->state = 'Gone';
						$file_tombstones[$key] = $tombstone;
						continue;
					}
				}
				
				if (!is_dir($tombstone_dir_path) || $tombstone->state == 'Gone') {
					continue;
				}

				if ($tombstone->state == 'Pending') {
					gh_log(DEBUG, "  Copying file to $tombstone->path");
					$temp_path = get_temp_filename($tombstone->path);
					copy($source_real_path, $temp_path);
					rename($temp_path, $tombstone->path);
					gh_chperm($tombstone->path, gh_get_file_infos($source_real_path));
					$tombstone->state = 'OK';
					$file_tombstones[$key] = $tombstone;
				}
			}
			if ($tombstone->is_linked) {
				if ($symlink_created /* already */) {
					$tombstone->is_linked = FALSE;
					$file_tombstones[$key] = $tombstone;
					continue;
				}
				gh_log(DEBUG, "  Updating symlink at $landing_zone/$file_path/$filename to point to $tombstone->path");
				gh_recycle("$landing_zone/$file_path/$filename");
				gh_mkdir("$landing_zone/$file_path", "$landing_zone", null);
				symlink($tombstone->path, "$landing_zone/$file_path/$filename");
				$symlink_created = TRUE;
			}
		}
		save_tombstones($share, $file_path, $filename, array_values($file_tombstones));
	} else {
		# Let's not assume that files on missing drives are really there... Removing files here could be dangerous!
		foreach ($file_copies_inodes as $inode => $path) {
			if (!is_numeric($inode)) {
				unset($file_copies_inodes[$inode]);
			}
		}
		if (count($file_copies_inodes) > $num_copies_required) {
			gh_log(INFO, "  Too many file copies. Expected $num_copies_required, got " . count($file_copies_inodes) . ". Will try to remove some.");
			if (file_is_locked($share, "$file_path/$filename") !== FALSE) {
				gh_log(INFO, "  File is locked. Will not remove copies at this time. The next fsck will try to remove copies again.");
				return;
			}
			$fsck_report['too_many_copies']++;
			$keys_to_remove = array();
		
			$local_target_drives = array_values(order_target_drives(0, TRUE, $share, $file_path));
			while (count($file_copies_inodes) > $num_copies_required) {
				$target_drive = array_pop($local_target_drives);
				$key = clean_dir("$target_drive/$share/$file_path/$filename");
				gh_log(DEBUG, "  Looking for copy at $key");
				if (isset($file_tombstones[$key])) {
					$tombstone = $file_tombstones[$key];
					if ($tombstone->state == 'OK' && real_file_is_locked($tombstone->path) === FALSE) {
						$fsck_report['too_many_files'][] = $tombstone->path;
						gh_log(DEBUG, "  Removing copy at $tombstone->path");
						unset($file_copies_inodes[fileinode($tombstone->path)]);
						gh_recycle($tombstone->path);
						$keys_to_remove[] = $key;
						$num_ok--;
						break;
					}
				}
			}
			foreach ($keys_to_remove as $key) {
				unset($file_tombstones[$key]);
			}

			// If no tombstone is linked, link the 1st one
			$found_linked_tombstone = FALSE;
			foreach ($file_tombstones as $key => $tombstone) {
				if ($tombstone->is_linked) {
					$found_linked_tombstone = TRUE;
					break;
				}
			}
			if (!$found_linked_tombstone) {
				$tombstone = reset($file_tombstones);
				gh_log(DEBUG, "  Updating symlink at $landing_zone/$file_path/$filename to point to $tombstone->path");
				gh_recycle("$landing_zone/$file_path/$filename");
				gh_mkdir("$landing_zone/$file_path", "$landing_zone", null);
				symlink($tombstone->path, "$landing_zone/$file_path/$filename");
				reset($file_tombstones)->is_linked = TRUE;
			}

			save_tombstones($share, $file_path, $filename, array_values($file_tombstones));
		}
	}
}

function initialize_fsck_report($what) {
	global $fsck_report;
	$fsck_report = array();
	$fsck_report['start'] = time();
	$fsck_report['what'] = $what;
	$fsck_report['graveyard'] = array();
	$fsck_report['graveyard']['num_dirs'] = 0;
	$fsck_report['graveyard']['num_files'] = 0;
	$fsck_report['landing_zone'] = array();
	$fsck_report['landing_zone']['num_dirs'] = 0;
	$fsck_report['landing_zone']['num_files'] = 0;
	$fsck_report['not_in_landing'] = 0;
	$fsck_report['no_copies_found_files'] = array();
	$fsck_report['symlink_target_moved'] = 0;
	$fsck_report['too_many_copies'] = 0;
	$fsck_report['too_many_files'] = array();
	$fsck_report['missing_copies'] = 0;
	$fsck_report['wrong_file_size'] = array();
	$fsck_report['temp_files'] = array();
	$fsck_report['gone_ok'] = 0;
}

function get_fsck_report() {
	global $fsck_report, $storage_pool_directories, $gone_ok_drives;
	
	$fsck_report['end'] = time();
	
	$displayable_duration = duration_to_human($fsck_report['end'] - $fsck_report['start']);
	
	$report = "fsck report
-----------
Scanned directory: " . $fsck_report['what'] . "

Started:  " . date('Y-m-d H:i:s', $fsck_report['start']) . "
Ended:    " . date('Y-m-d H:i:s', $fsck_report['end']) . "
Duration: $displayable_duration

Graveyard:
  Found " . number_format($fsck_report['graveyard']['num_dirs']) . " directories
  Found " . number_format($fsck_report['graveyard']['num_files']) . " files

Landing Zone (shares):
  Found " . number_format($fsck_report['landing_zone']['num_dirs']) . " directories
  Found " . number_format($fsck_report['landing_zone']['num_files']) . " files

Attic size:\n";

	foreach ($storage_pool_directories as $dir) {
		$attic_path = clean_dir("$dir/.gh_attic");
		if (is_dir($attic_path)) {
			$report .= "  $attic_path = " . trim(exec("du -sh " . quoted_form($attic_path) . " | awk '{print $1}'"))."\n";
		} else {
			$report .= "  $attic_path = empty\n";
		}
	}

	// Errors
	if (empty($fsck_report['no_copies_found_files']) && count($fsck_report['wrong_file_size']) == 0) {
		$report .= "\nNo problems found.\n";
	} else {
		$report .= "\nProblems:\n";

		if (!empty($fsck_report['no_copies_found_files'])) {
			ksort($fsck_report['no_copies_found_files']);
			$report .= "  Found " . count($fsck_report['no_copies_found_files']) . " files in the graveyard for which no file copies were found.
    Those files were removed from the Landing Zone. (i.e. those files are now gone!) They will re-appear in your shares if a copy re-appear and fsck is run.
    If you don't want to see those files listed here each time fsck runs, delete the corresponding files from the graveyard.
  Files with no copies:\n";
			$report .= "    " . implode("\n    ", array_keys($fsck_report['no_copies_found_files'])) . "\n\n";
		}

		if (count($fsck_report['wrong_file_size']) > 0) {
			$report .= "  Found " . count($fsck_report['wrong_file_size']) . " file copies with the wrong file size. Those files don't have the same file size as the original files available on your shares. You should manually remove the invalid copies.\n";
			foreach ($fsck_report['wrong_file_size'] as $real_file_path => $info_array) {
				$report .= "    $real_file_path is " . number_format($info_array[0]) . " bytes; should be " . number_format($info_array[1]) . " bytes.\n";
			}
			$report .= "\n";
		}
	}

	// Warnings
	if ($fsck_report['too_many_copies'] == 0 && $fsck_report['symlink_target_moved'] == 0 && $fsck_report['not_in_landing'] == 0 && count($fsck_report['temp_files']) == 0 && $fsck_report['gone_ok'] == 0) {
		// Nothing to say...
	} else {
		$report .= "Notices:\n";

		if ($fsck_report['too_many_copies'] > 0) {
			$fsck_report['too_many_files'] = array_unique($fsck_report['too_many_files']);
		
			$report .= "  Found " . $fsck_report['too_many_copies'] . " files for which there was too many file copies. Deleted (or moved in attic) files:\n";
			$report .= "    " . implode("\n    ", $fsck_report['too_many_files']) . "\n\n";
		}

		if ($fsck_report['symlink_target_moved'] > 0) {
			$report .= "  Found " . $fsck_report['symlink_target_moved'] . " files in the Landing Zone that were pointing to a now gone copy.
    Those symlinks were updated to point to the new location of those file copies.\n\n";
		}

		if ($fsck_report['not_in_landing'] > 0) {
			$report .= "  Found " . $fsck_report['not_in_landing'] . " files that were not in the Landing Zone.
    Symlinks were created in the Landing Zone to point to those files.\n\n";
		}
	
		if (count($fsck_report['temp_files']) > 0) {
			$report .= "  Found " . count($fsck_report['temp_files']) . " temporary files, which are leftovers of interrupted Greyhole executions. The following temporary files were deleted (or moved into the attic):\n";
			$report .= "    " . implode("\n    ", $fsck_report['temp_files']) . "\n\n";
		}
	
		if ($fsck_report['gone_ok'] > 0) {
			$report .= "  Found " . $fsck_report['gone_ok'] . " missing files that are in a storage pool directory marked Gone-OK.
  If this directory is gone for good, you should execute the following command, and remove the directory from your configuration file:
    sudo greyhole-executer --gone <path>
  where <path> is one of:\n";
	    	$report .= "    " . implode("\n    ", array_keys($gone_ok_drives)) . "\n\n";
		}
	}

	return $report;
}

function gh_recycle($real_path) {
	$is_symlink = FALSE;
	clearstatcache();
	if (is_link($real_path)) {
		$is_symlink = TRUE;
	} else if (!file_exists($real_path)) {
		return TRUE;
	}

	$should_move_to_attic = FALSE;
	if (!$is_symlink) {
		global $storage_pool_directories, $delete_moves_to_attic, $shares_options;
		
		$share_options = get_share_options_from_full_path($real_path);
		if ($share_options !== FALSE) {
			$full_path = trim($share_options['name'] . "/" . str_replace($share_options['landing_zone'], '', $real_path), '/');
			$share = substr($full_path, 0, strpos($full_path, '/'));
		} else {
			foreach ($storage_pool_directories as $dir) {
				if (strpos($real_path, $dir) === 0) {
					$attic_path = "$dir/.gh_attic";
					$full_path = trim(str_replace($dir, '', $real_path), '/');
					break;
				}
			}

			$share = substr($full_path, 0, strpos($full_path, '/'));

			if (isset($shares_options[$share]['delete_moves_to_attic'])) {
				$should_move_to_attic = $shares_options[$share]['delete_moves_to_attic'];
			} else {
				$should_move_to_attic = $delete_moves_to_attic;
			}
		}
	}
	
	if ($should_move_to_attic) {
		// Move to attic
		if (!isset($attic_path)) {
			gh_log(WARN, "  Warning! Can't find attic for $real_path. Won't delete this file!");
			return FALSE;
		}
		
		$target_path = clean_dir("$attic_path/$full_path");

		list($path, $filename) = explode_full_path($target_path);
		
		list($original_path, $filename) = explode_full_path(get_share_landing_zone($share) . "/$full_path");
		
		gh_mkdir($path, "$attic_path/$share", $original_path);

		if (@rename($real_path, $target_path)) {
			gh_log(DEBUG, "  Moved copy from $real_path to attic: $target_path");
			return TRUE;
		}
	} else {
		if (@unlink($real_path)) {
			if (!$is_symlink) {
				gh_log(DEBUG, "  Deleted copy at $real_path");
			}
			return TRUE;
		}
	}
	return FALSE;
}

function repair_tables() {
	mysql_query("REPAIR TABLE tasks") or gh_log(CRITICAL, "Can't repair tasks table: " . mysql_error());
	mysql_query("REPAIR TABLE tasks_completed") or gh_log(CRITICAL, "Can't repair tasks_completed table: " . mysql_error());
	mysql_query("REPAIR TABLE settings") or gh_log(CRITICAL, "Can't repair settings table: " . mysql_error());
}

function check_storage_pool_dirs() {
	global $storage_pool_directories, $email_to, $gone_ok_drives;
	$hostname = exec('hostname');
	$needs_fsck = FALSE;
	$i = 0; $j = 0;
	foreach ($storage_pool_directories as $target_drive) {
		if (!is_greyhole_owned_dir($target_drive) && !gone_fscked($target_drive, $i++ == 0)) {
			$needs_fsck = 1;
			gh_log(WARN, "Warning! It seems $target_drive is missing it's \".greyhole_uses_this\" file. This either means this mount is currently unmounted, or you forgot to create this file.");
			$body = "This is an automated email from Greyhole.

It appears one of your storage pool directory is missing it's \".greyhole_uses_this\" file:
  $target_drive/.greyhole_uses_this: File not found

This either means this mount is currently unmounted, or you forgot to create this file.

Here are your options:

- If you forgot to create this file, you should create it ASAP, as per the INSTALL instructions. Until you do, this directory will not be part of your storage pool.

- If the mount is gone, you should either re-mount it manually (if possible), or remove it from your configuration file, if you know it is gone for good.

- If you know this mount will come back soon, and do NOT want Greyhole to re-create missing file copies for this directory until it reappears, you should execute this command:
  sudo greyhole-executer --gone-ok ".quoted_form($target_drive)."

A fsck will now start, to fix the symlinks found in your shares, when possible.
You'll receive a report email once that fsck run completes.
";
			mail($email_to, 'Missing storage pool directory on ' . $hostname . ': ' . $target_drive, $body);
			gh_log(DEBUG, "Email sent for gone dir: $target_drive");
			$gone_ok_drives[$target_drive] = TRUE; // The upcoming fsck should not recreate missing copies just yet
		} else if ((gone_ok($target_drive, $j++ == 0) || gone_fscked($target_drive, $i++ == 0)) && is_greyhole_owned_dir($target_drive)) {
			// $target_drive is now back
			$needs_fsck = 2;
			$body = "This is an automated email from Greyhole.

It appears one of your storage pool directory came back:
  $target_drive was missing; it's now available again.

A fsck will now start, to fix the symlinks found in your shares, when possible.
You'll receive a report email once that fsck run completes.
";
			mail($email_to, 'Storage pool directory now online on ' . $hostname . ': ' . $target_drive, $body);
			gh_log(DEBUG, "Email sent for revived dir: $target_drive");

			mark_gone_ok($target_drive, 'remove');
			mark_gone_drive_fscked($target_drive, 'remove');
			$i = 0; $j = 0;
		}
	}
	
	if ($needs_fsck !== FALSE) {
		global $shares_options;
		if ($needs_fsck === 1) {
			gh_log(INFO, "Starting fsck for all shares - caused by missing drive. Will just recreate symlinks to existing copies when possible; won't create new copies just yet.");
		} else {
			gh_log(INFO, "Starting fsck for all shares - caused by missing drive that came back online.");
		}
		initialize_fsck_report();
		clearstatcache();

		foreach ($shares_options as $share_name => $share_options) {
			gh_fsck($share_options['landing_zone'], $share_name);
		}
		foreach (get_graveyards() as $graveyard) {
			foreach ($shares_options as $share_name => $share_options) {
				gh_fsck_graveyard($graveyard, "/$share_name", $share_name);
			}
		}
		gh_log(INFO, "fsck for all shares completed.");

		$fsck_report = get_fsck_report();
		gh_log(DEBUG, "Sending fsck report to $email_to");
		mail($email_to, 'fsck of Greyhole shares on ' . $hostname, $fsck_report);
		if ($needs_fsck === 1) {
			mark_gone_drive_fscked($target_drive);
		}

		// Refresh $gone_ok_drives to it's real value (from the DB)
		get_gone_ok_dirs();
	}
}

// Is it OK for a drive to be gone?
function gone_ok($target_drive, $refresh=FALSE) {
	global $gone_ok_drives;
	if ($refresh || !isset($gone_ok_drives)) {
		$gone_ok_drives = get_gone_ok_dirs();
	}
	if (isset($gone_ok_drives[$target_drive])) {
		return TRUE;
	}
	return FALSE;
}

function get_gone_ok_dirs() {
	global $gone_ok_drives;
	$query = sprintf("SELECT value FROM settings WHERE name = 'Gone-OK-Drives'");
	$result = mysql_query($query) or gh_log(CRITICAL, "Can't query settings for Gone-OK-Drives: " . mysql_error());
	if (mysql_num_rows($result) == 1) {
		$row = mysql_fetch_object($result);
		$gone_ok_drives = unserialize($row->value);
	} else {
		$query = "INSERT INTO `greyhole`.`settings` (`name`, `value`) VALUES ('Gone-OK-Drives', 'a:0:{}')";
		mysql_query($query) or gh_log(CRITICAL, "Can't insert new settings for Gone-OK-Drives: " . mysql_error());
		$gone_ok_drives = array();
	}
	return $gone_ok_drives;
}

function mark_gone_ok($target_drive, $action='add') {
	global $storage_pool_directories;
	if (!array_search($target_drive, $storage_pool_directories)) {
		return FALSE;
	}

	global $gone_ok_drives;
	$gone_ok_drives = get_gone_ok_dirs();
	if ($action == 'add') {
		$gone_ok_drives[$target_drive] = TRUE;
	} else {
		unset($gone_ok_drives[$target_drive]);
	}

	$query = sprintf("UPDATE settings SET value = '%s' WHERE name = 'Gone-OK-Drives'",
		mysql_escape_string(serialize($gone_ok_drives))
	);
	mysql_query($query) or gh_log(CRITICAL, "Can't save settings for Gone-OK-Drives: " . mysql_error());
	return TRUE;
}

function gone_fscked($target_drive, $refresh=FALSE) {
	global $fscked_gone_drives;
	if ($refresh || !isset($fscked_gone_drives)) {
		$fscked_gone_drives = get_fsck_gone_drives();
	}
	if (isset($fscked_gone_drives[$target_drive])) {
		return TRUE;
	}
	return FALSE;
}

function get_fsck_gone_drives() {
	global $fscked_gone_drives;
	$query = sprintf("SELECT value FROM settings WHERE name = 'Gone-FSCKed-Drives'");
	$result = mysql_query($query) or gh_log(CRITICAL, "Can't query settings for Gone-FSCKed-Drives: " . mysql_error());
	if (mysql_num_rows($result) == 1) {
		$row = mysql_fetch_object($result);
		$fscked_gone_drives = unserialize($row->value);
	} else {
		$query = "INSERT INTO `greyhole`.`settings` (`name`, `value`) VALUES ('Gone-FSCKed-Drives', 'a:0:{}')";
		mysql_query($query) or gh_log(CRITICAL, "Can't insert new settings for Gone-FSCKed-Drives: " . mysql_error());
		$fscked_gone_drives = array();
	}
	return $fscked_gone_drives;
}

function mark_gone_drive_fscked($target_drive, $action='add') {
	global $fscked_gone_drives;
	$fscked_gone_drives = get_fsck_gone_drives();
	if ($action == 'add') {
		$fscked_gone_drives[$target_drive] = TRUE;
	} else {
		unset($fscked_gone_drives[$target_drive]);
	}

	$query = sprintf("UPDATE settings SET value = '%s' WHERE name = 'Gone-FSCKed-Drives'",
		mysql_escape_string(serialize($fscked_gone_drives))
	);
	mysql_query($query) or gh_log(CRITICAL, "Can't save settings for Gone-FSCKed-Drives: " . mysql_error());
}

function get_graveyards() {
	global $storage_pool_directories;
	$graveyards = array();
	foreach ($storage_pool_directories as $target_drive) {
		if (is_greyhole_owned_dir($target_drive)) {
			$graveyards[] = "$target_drive/.gh_graveyard";
		}
	}
	return $graveyards;
}

function get_share_options_from_full_path($full_path) {
	global $shares_options;
	$landing_zone = '';
	$share = FALSE;
	foreach ($shares_options as $share_name => $share_options) {
		if (strpos($full_path, $share_options['landing_zone']) === 0 && strlen($share_options['landing_zone']) > strlen($landing_zone)) {
			$landing_zone = $share_options['landing_zone'];
			$share = $share_options;
		}
	}
	return $share;
}

function get_share_landing_zone($share) {
	global $shares_options;
	if (isset($shares_options[$share]['landing_zone'])) {
		return $shares_options[$share]['landing_zone'];
	} else {
		global $config_file, $smb_config_file;
		gh_log(CRITICAL, "Found a share ($share) defined in $config_file with no path in $smb_config_file. Either add this share in $smb_config_file, or remove it from $config_file, then restart Greyhole.");
	}
}

function gh_get_file_infos($real_path) {
	if ($real_path == null || !file_exists($real_path)) {
		return (object) array(
			'fileowner' => 0,
			'filegroup' => 0,
			'fileperms' => (int) base_convert("0755", 8, 10)
		);
	}
	return (object) array(
		'fileowner' => (int) fileowner($real_path),
		'filegroup' => (int) filegroup($real_path),
		'fileperms' => (int) base_convert(substr(decoct(fileperms($real_path)), -4), 8, 10)
	);
}

function gh_get_dir_perms($directory) {
	return (int) base_convert(substr(decoct(fileperms($directory)), -4), 8, 10);
}
?>
