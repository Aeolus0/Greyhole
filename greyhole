#!/usr/bin/php
<?php
/*
Copyright 2009 Guillaume Boudreau

This file is part of Greyhole.

Greyhole is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Greyhole is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Greyhole.  If not, see <http://www.gnu.org/licenses/>.
*/

include('includes/common.php');
include('includes/sql.php');

$action = 'unknown';
$options = array();
for ($i=1; $i<$argc; $i++) {
	switch ($argv[$i]) {
		case '--daemon':
		case '--fsck':
		case '--balance':
		case '--prerotate':
		case '--postrotate':
		case '--stats':
		case '--empty-attic':
		case '--view-queue':
		case '--iostat':
		$action = substr($argv[$i], 2);
		break;

		case '--email-report':
		case '--dont-walk-graveyard':
		case '--disk-usage-report':
		$options[substr($argv[$i], 2)] = TRUE;
		break;
		
		case '--wait-for':
		case '--gone':
		case '--going':
		case '--thaw':
		$action = substr($argv[$i], 2);
		// Fall through --dir to fetch the path for the above commands

		case '--dir':
		if (isset($argv[$i+1])) {
			$options['dir'] = $argv[$i+1];
		}
		$i++;
		break;

		case '--debug':
		$action = 'debug';
		if (isset($argv[$i+1])) {
			$options['debug_filename'] = $argv[$i+1];
			$i++;
		}
		break;
		
		default:
		print_usage();
	}
}

if ($action == 'unknown') {
	print_usage();
}

process_config();

db_connect() or gh_log(CRITICAL, "Can't connect $db_options->engine to database.");
db_select_db();
db_migrate();

if (@$db_use_mysql) {
	db_query("SET SESSION group_concat_max_len = 1048576");
}

function print_usage() {
	echo "Invalid command line options.\n";
	echo "Usage: Start the daemon:         greyhole --daemon\n";
	echo "       Schedule a fsck:          greyhole --fsck [--email-report] [--dont-walk-graveyard] [--dir <path>]\n";
	echo "       Balance available space \n";
	echo "        on storage pool devices: greyhole --balance\n";
	echo "       Display statistics:       greyhole --stats\n";
	echo "       Display work queue:       greyhole --view-queue\n";
	echo "       Empty attic:              greyhole --empty-attic\n";
	echo "       Debug file operations:    greyhole --debug <filename>\n";
	echo "\n";
	echo "       List frozen directories:  greyhole --thaw\n";
	echo "       Thaw a frozen directory:  greyhole --thaw <share/directory>\n";
	echo "\n";
	echo "       Pre-rotate task:          greyhole --prerotate\n";
	echo "       Post-rotate task:         greyhole --postrotate\n";
	echo "\n";
	echo "     When <path>, one of your storage pool directories, is/will become unavailable:\n";
	echo "       <path> will return soon:      greyhole --wait-for <path>\n";
	echo "       <path> is gone for good:      greyhole --gone <path>\n";
	echo "       <path> will be gone for good: greyhole --going <path>\n";
	echo "\n";
	echo "     About the attic: The attic is used like a Recycle Bin, or Trash.\n";
	echo "       That means you'll need to manually empty it once in a while.\n";
	echo "       To do so, use the --empty-attic parameter (see above).\n";
	echo "       Another option is to create a 'Greyhole Attic' Samba share.\n";
	echo "       More details about that here: http://greyhole.pommepause.com/doc/attic\n";
	exit(1);
}

if ($action != 'stats' && $action != 'view-queue' && $action != 'debug' && $action != 'iostat') {
	if (exec("whoami") != 'root') {
		echo "You need to execute this as root.\n";
		exit(1);
	}
}

if ($action == 'iostat') {
	$devices_directories = array();
	foreach ($storage_pool_directories as $target_drive) {
		$device = exec("df " . quoted_form($target_drive) . " | awk '{print \$1}'");
		$device = preg_replace('@/dev/(sd[a-z])[0-9]+@', '\1', $device);
		$devices_directories[$device] = $target_drive;
	}

	while (TRUE) {
		unset($result);
		exec("iostat -p ALL -k 10 2 | grep '^sd[a-z] ' | awk '{print \$1,\$3,\$4}'", $result);
		$iostat = array();
		foreach ($result as $line) {
			$info = explode(' ', $line);
			$device = $info[0];
			$read_kBps = $info[1];
			$write_kBps = $info[2];
			if (!isset($devices_directories[$device])) {
				# That device isn't in the storage pool.
				continue;
			}
			$directory = $devices_directories[$device];
			$iostat[$directory] = (float) $read_kBps + $write_kBps;
		}
		foreach ($iostat as $dir => $io_kBps) {
			echo "$dir: $io_kBps kBps\n";
		}
	}
	
	exit(0);
}

if ($action == 'thaw') {
	if (!isset($options['dir'])) {
		echo "Frozen directories:\n";
		foreach ($frozen_directories as $frozen_directory) {
			echo "  $frozen_directory\n";
		}
		echo "To thaw any of the above directories, use the following command:\n";
		echo "greyhole --thaw <directory>\n";
		exit(0);
	}
	$path = explode('/', $options['dir']);
	$share = array_shift($path);
	$query = sprintf("UPDATE tasks SET complete = 'thawed' WHERE complete = 'frozen' AND share = '%s' AND full_path LIKE '%s%%'",
		db_escape_string($share),
		db_escape_string(implode('/', $path))
	);
	db_query($query) or die("Can't thaw tasks with query: $query - Error: " . db_error());
	echo $options['dir'] . " directory has been thawed.\n";
	echo "All pasts file operations that occured in this directory will now be processed by Greyhole.\n";
	exit(0);
}

if ($action == 'gone' || $action == 'going') {
	global $storage_pool_directories;
	if (array_search($options['dir'], $storage_pool_directories) === FALSE) {
		if (!empty($options['dir'])) {
			echo "Directory " . $options['dir'] . " is not one of your defined storage pool directories.\n";
		}
		echo "Please use one of the following with the --$action option:\n  ";
		echo implode("\n  ", $storage_pool_directories) . "\n";
		exit(1);
	}

	if ($action == 'going') {
		set_graveyard_backup();
		gh_log(INFO, "Storage pool directory " . $options['dir'] . " will be removed from the storage pool.");
		echo("Storage pool directory " . $options['dir'] . " will be removed from the storage pool.\n");

		// global $going_dir; // Used in function is_greyhole_owned_dir()
		$going_dir = $options['dir'];

		// fsck shares with only 1 file copy to remove those from $options['dir']
		initialize_fsck_report('Shares with only 1 copy');
		foreach ($shares_options as $share_name => $share_options) {
			if ($share_options['num_copies'] == 1) {
				echo "Moving file copies for share '$share_name'... Please be patient... ";
				gh_fsck($share_options['landing_zone'], $share_name);
				echo "Done.\n";
			}
		}

		unlink("$going_dir/.greyhole_uses_this");

		// Remove $options['dir'] from config file and restart (if it was running)
		$escaped_dir = str_replace('/', '\/', $going_dir);
		exec("/bin/sed -ie 's/^.*storage_pool_directory.*$escaped_dir.*$//' /etc/greyhole.conf");
		exec("/sbin/service greyhole condrestart");

		// If we're on Amahi, let's remove it from the Storage Pool page too
		if (file_exists('/usr/bin/hdactl')) {
			$hda_going_dir = preg_replace('/\/gh$/', '', $going_dir);
			exec("/usr/bin/mysql -u root -phda -e \"DELETE FROM disk_pool_partitions WHERE path = '$hda_going_dir'\" hda_production");
		}
		
		// Schedule fsck for all shares to re-create missing copies on other shares
		db_query("INSERT INTO tasks (action, share, additional_info, complete) VALUES ('fsck', '', NULL, 'yes')") or gh_log(CRITICAL, "Can't insert fsck task: " . db_error());
		echo "All the files that were only on $going_dir have been copied somewhere else.\n";
		echo "A fsck of all shares has been scheduled, to recreate other file copies. It will start after all currently pending tasks have been completed.\n";
	}

	mark_gone_ok($options['dir'], 'remove');
	mark_gone_drive_fscked($options['dir'], 'remove');
	gh_log(INFO, "Storage pool directory " . $options['dir'] . " has been marked Gone");
	echo "Storage pool directory " . $options['dir'] . " has been marked Gone, which means the missing file copies that are in this directory will be re-created during the next fsck.\n";
	exit(0);
}

if ($action == 'debug') {
	if (!isset($options['debug_filename'])) {
		print_usage();
	}
	$filename = $options['debug_filename'];
	
	if (strpos($filename, '/') === FALSE) {
		$filename = "/$filename";
	}

	echo "Debugging file operations for file named \"$filename\"\n";

	echo "\nFrom DB\n=======\n";
	$debug_tasks = array();
	$query = sprintf("SELECT id, action, share, full_path, additional_info, event_date FROM tasks_completed WHERE full_path LIKE '%%%s%%' ORDER BY id ASC",
		db_escape_string($filename)
	);
	$result = db_query($query) or die("Can't query tasks_completed with query: $query - Error: " . db_error());
	while ($row = db_fetch_object($result)) {
		$debug_tasks[$row->id] = $row;
	}

	// Renames
	$query = sprintf("SELECT id, action, share, full_path, additional_info, event_date FROM tasks_completed WHERE additional_info LIKE '%%%s%%' ORDER BY id ASC",
		db_escape_string($filename)
	);
	while (TRUE) {
		$result = db_query($query) or die("Can't query tasks_completed for renames with query: $query - Error: " . db_error());
		while ($row = db_fetch_object($result)) {
			$debug_tasks[$row->id] = $row;
			$query = sprintf("SELECT id, action, share, full_path, additional_info, event_date FROM tasks_completed WHERE additional_info = '%s' ORDER BY id ASC",
				db_escape_string($row->full_path)
			);
		}

		# Is there more?
		$new_query = preg_replace('/SELECT .* FROM/i', 'SELECT COUNT(*) FROM', $query);
		$result = db_query($new_query) or die("Can't query tasks_completed for COUNT of renames with query: $new_query - Error: " . db_error());
		if (db_fetch_object($result) !== FALSE) {
			break;
		}
	}
	
	ksort($debug_tasks);
	$to_grep = array();
	foreach ($debug_tasks as $task) {
		echo "  [$task->event_date] Task ID $task->id: $task->action $task->share/$task->full_path" . ($task->action == 'rename' ? " -> $task->share/$task->additional_info" : '') . "\n";
		$to_grep["$task->share/$task->full_path"] = 1;
		if ($task->action == 'rename') {
			$to_grep["$task->share/$task->additional_info"] = 1;
		}
	}
	if (empty($to_grep)) {
		$to_grep[$filename] = 1;
		if (strpos($filename, '/') !== FALSE) {
			$share = trim(substr($filename, 0, strpos(substr($filename, 1), '/')+1), '/');
			$full_path = trim(substr($filename, strpos(substr($filename, 1), '/')+1), '/');
			$debug_tasks[] = (object) array('share' => $share, 'full_path' => $full_path);
		}
	}

	echo "\nFrom logs\n=========\n";
	$to_grep = array_keys($to_grep);
	$to_grep = implode("|", $to_grep);
	$commands = array();
	$commands[] = "zgrep -E -B 1 -A 1 -h " . quoted_form($to_grep) . " /var/log/greyhole.log-*";
	$commands[] = "grep -E -B 1 -A 1 -h " . quoted_form($to_grep) . " /var/log/greyhole.log";
	foreach ($commands as $command) {
		exec($command, $result);
	}
	foreach ($result as $rline) {
		echo preg_replace('@^/var/log/greyhole.log[0-9\.gz-]*:@', '', $rline) . "\n";
	}
	
	echo "\nFrom filesystem\n===============\n";

	$last_task = array_pop($debug_tasks);
	$share = $last_task->share;
	if ($last_task->action == 'rename') {
		$full_path = $last_task->additional_info;
	} else {
		$full_path = $last_task->full_path;
	}
	list($path, $filename) = explode_full_path($full_path);
	echo "Landing Zone:\n";
	echo "  "; passthru("ls -l " . quoted_form(get_share_landing_zone($share) . "/" . $full_path));

	echo "\nGraveyard:\n";
	foreach ($storage_pool_directories as $target_drive) {
		$graveyard = clean_dir("$target_drive/.gh_graveyard");
		if (file_exists("$graveyard/$share/$full_path")) {
			echo "  "; passthru("ls -l " . quoted_form("$graveyard/$share/$full_path"));
			$data = var_export(unserialize(file_get_contents("$graveyard/$share/$full_path")), TRUE);
			$data = str_replace("\n", "\n    ", $data);
			echo "    $data\n";
		}
	}

	echo "\nFile copies:\n";
	foreach ($storage_pool_directories as $target_drive) {
		if (file_exists("$target_drive/$share/$full_path")) {
			echo "  "; passthru("ls -l " . quoted_form("$target_drive/$share/$full_path"));
		}
	}

	exit(0);
}

if ($action == 'empty-attic') {
	foreach ($storage_pool_directories as $target_drive) {
		$attic_path = clean_dir("$target_drive/.gh_attic");
		if (!file_exists($attic_path)) {
			echo "Attic in $target_drive is empty. Nothing to do.\n";
		} else {
			$attic_size = trim(exec("du -sk " . quoted_form($attic_path) . " | awk '{print $1}'"));
			echo "Attic in $target_drive is " . bytes_to_human($attic_size*1024, FALSE) . ". Emptying... ";
			exec("rm -rf " . quoted_form($attic_path));
			echo "Done\n";
		}
	}
	if (isset($attic_share) && strlen(quoted_form($attic_share['landing_zone'])) > 8) {
		exec("rm -rf " . quoted_form($attic_share['landing_zone']) . '/*');
	}
	exit(0);
}

if ($action == 'view-queue') {
	echo "\nGreyhole Work Queue Statistics\n==============================\n\n";
	
	$shares_names = array_keys($shares_options);
	natcasesort($shares_names);

	$max_share_strlen = 0;
	foreach ($shares_names as $share_name) {
		if (strlen($share_name) > $max_share_strlen) {
			$max_share_strlen = strlen($share_name);
		}
	}

	echo "This table gives you the number of pending operations queued for the Greyhole daemon, per share.\n\n";
	printf("%$max_share_strlen"."s  Write   Delete  Rename\n", '');
	$total_num_writes_pending = $total_num_delete_pending = $total_num_rename_pending = 0;
	foreach ($shares_names as $share_name) {
		$result = db_query(sprintf("SELECT COUNT(*) AS num FROM tasks WHERE action = 'write' AND share = '%s'", db_escape_string($share_name))) or die("Can't find # of writes in tasks table: " . db_error());
		$row = db_fetch_object($result);
		$num_writes_pending = (int) $row->num;
		$total_num_writes_pending += $num_writes_pending;

		$result = db_query(sprintf("SELECT COUNT(*) AS num FROM tasks WHERE (action = 'unlink' OR action = 'rmdir') AND share = '%s'", db_escape_string($share_name))) or die("Can't find # of deletes in tasks table: " . db_error());
		$row = db_fetch_object($result);
		$num_delete_pending = (int) $row->num;
		$total_num_delete_pending += $num_delete_pending;

		$result = db_query(sprintf("SELECT COUNT(*) AS num FROM tasks WHERE action = 'rename' AND share = '%s'", db_escape_string($share_name))) or die("Can't find # of renames in tasks table: " . db_error());
		$row = db_fetch_object($result);
		$num_rename_pending = (int) $row->num;
		$total_num_rename_pending += $num_rename_pending;

		echo sprintf("%-$max_share_strlen"."s", $share_name) . "  ";
		echo sprintf('%-7s', $num_writes_pending) . " ";
		echo sprintf('%-7s', $num_delete_pending) . " ";
		echo sprintf('%-7s', $num_rename_pending) . "\n";
	}
	for ($i=0; $i<$max_share_strlen; $i++) {
		echo "=";
	}
	echo sprintf("\n%-$max_share_strlen"."s  ", 'Total');
	echo sprintf('%-6s', $total_num_writes_pending) . "+ ";
	echo sprintf('%-6s', $total_num_delete_pending) . "+ ";
	echo sprintf('%-6s', $total_num_rename_pending) . "= ";
	echo ($total_num_writes_pending + $total_num_delete_pending + $total_num_rename_pending) . "\n";

	echo "\n";
	exit(0);
}

if ($action == 'stats') {
	echo "\nGreyhole Statistics\n===================\n\n";

	$max_drive_strlen = 0;
	foreach ($storage_pool_directories as $target_drive) {
		if (strlen($target_drive) > $max_drive_strlen) {
			$max_drive_strlen = strlen($target_drive);
		}
	}
	$max_drive_strlen++;

	$dfs = get_free_space_in_storage_pool_dirs();
	echo "Storage Pool\n";
	printf("%$max_drive_strlen"."s   Total -  Used =  Free + Attic = Possible\n", '');
	foreach ($storage_pool_directories as $target_drive) {
		printf("  %-$max_drive_strlen"."s ", "$target_drive:");
		if (!isset($dfs[$target_drive])) {
			echo "  N/A -   N/A =   N/A +   N/A =   N/A\n";
			continue;
		}

		$df_command = "df -k " . quoted_form($target_drive) . " | awk '{print \$(NF-4),\$(NF-3)}'";
		unset($responses);
		exec($df_command, $responses);
		$response = explode(' ', $responses[1]);
		$total_space = (float) array_shift($response);
		$used_space = (float) array_shift($response);

		$free_space = $dfs[$target_drive];

		$attic_path = clean_dir("$target_drive/.gh_attic");
		if (!file_exists($attic_path)) {
			$attic_size = 0;
		} else {
			$attic_size = trim(exec("du -sk " . quoted_form($attic_path) . " | awk '{print $1}'"));
		}

		$potential_available_space = (float) $free_space + $attic_size;

		echo sprintf('%4.0f', $total_space/1024/1024) . "G - " . sprintf('%4.0f', $used_space/1024/1024) . "G = " . sprintf('%4.0f', $free_space/1024/1024) . "G + " . sprintf('%4.0f', $attic_size/1024/1024) . "G = " . sprintf('%4.0f', $potential_available_space/1024/1024) . "G\n";
	}
	echo "\n";
	exit(0);
}

if ($action == 'wait-for') {
	if (!mark_gone_ok($options['dir'])) {
		echo "Directory " . $options['dir'] . " is not one of your defined storage pool directories.\n";
		echo "Please use one of the following with the --wait-for option:\n  ";
		echo implode("\n  ", $storage_pool_directories) . "\n";
		exit(1);
	}
	gh_log(INFO, "Storage pool directory " . $options['dir'] . " has been marked Temporarily-Gone");
	echo "Storage pool directory " . $options['dir'] . " has been marked Temporarily-Gone, which means the missing file copies that are in this directory will not be re-created until it reappears.\n";
	exit(0);
}

if ($action == 'prerotate') {
	parse_samba_log(FALSE);
	gh_log(INFO, "Samba log parsed using --prerotate");
	echo "Samba log parsed successfully. You can now rotate the log, then reset the read pointer using --postrotate\n";
	exit(0);
}

repair_tables();

if ($action == 'postrotate') {
	$query = sprintf("UPDATE settings SET value = '0' WHERE name = '%s'", 'last_read_log_smbd_line');
	db_query($query) or gh_log(CRITICAL, "Can't update settings for 'last_read_log_smbd_line': " . db_error());
	gh_log(INFO, "Samba log read pointer reset using --postrotate");
	echo "Samba log read pointer reset to 0.\n";
	exit(0);
}

if ($action == 'balance') {
	$query = "INSERT INTO tasks (action, share, complete) VALUES ('balance', '', 'yes')";
	db_query($query) or gh_log(CRITICAL, "Can't insert balance task: " . db_error());
	echo "A balance has been scheduled. It will start after all currently pending tasks have been completed.\n";
	echo "This operation will try to even the available space on all directories included in your storage pool.\n";
	exit(0);
}

if ($action == 'fsck') {
	$pos = array_search('fsck', $argv);
	$full_path = '';
	if (isset($options['dir'])) {
		$full_path = $options['dir'];
		if (!is_dir($full_path)) {
			echo "$full_path is not a directory. Exiting.\n";
			exit(1);
		}
	}
	$fsck_options = array();
	if (isset($options['email-report'])) {
		$fsck_options[] = 'email';
	}
	if (!isset($options['dont-walk-graveyard'])) {
		$fsck_options[] = 'graveyard';
	}
	if (isset($options['disk-usage-report'])) {
		$fsck_options[] = 'du';
	}
	$query = sprintf("INSERT INTO tasks (action, share, additional_info, complete) VALUES ('fsck', '%s', %s, 'yes')",
		db_escape_string($full_path),
		(!empty($fsck_options) ? "'" . implode('|', $fsck_options) . "'" : "NULL")
	);
	db_query($query) or gh_log(CRITICAL, "Can't insert fsck task: " . db_error());
	if ($full_path == '') {
		$full_path = 'all shares';
	}
	echo "fsck of $full_path has been scheduled. It will start after all currently pending tasks have been completed.\n";
	exit(0);
}

gh_log(INFO, "Greyhole (version %VERSION%) daemon started.");
set_graveyard_backup();
parse_samba_log();
simplify_tasks();
while (TRUE) {
	parse_samba_log();
	$action = 'check_pool';
	check_storage_pool_dirs();
	execute_next_task();
}

function execute_next_task() {
	global $log_level, $fsck_report, $shares_options, $email_to, $sleep_before_task, $action, $frozen_directories, $next_task, $current_task_id;

	if (isset($next_task)) {
		$task = $next_task;
		$next_task = null;
	} else {
		$query = "SELECT id, action, share, full_path, additional_info, complete FROM tasks WHERE complete IN ('yes', 'thawed') ORDER BY id ASC LIMIT 1";
		$result = db_query($query) or gh_log(CRITICAL, "Can't query tasks: " . db_error());
		$task = db_fetch_object($result);
		if ($task === FALSE) {
			// No more complete = yes|thawed; let's look for complete = idle tasks.
			$query = "SELECT id, action, share, full_path, additional_info, complete FROM tasks WHERE complete = 'idle' ORDER BY id ASC LIMIT 1";
			$result = db_query($query) or gh_log(CRITICAL, "Can't query tasks: " . db_error());
			$task = db_fetch_object($result);
			if ($task === FALSE) {
				$action = 'sleep';
				gh_log(DEBUG, "Nothing to do... Sleeping.");
				sleep($log_level == DEBUG ? 10 : ($log_level == TEST ? 1 : 600));
				db_free_result($result);
				return;
			}
		}
		db_free_result($result);
	}
	$current_task_id = $task->id;

	# Postpone tasks in frozen directories until a --thaw command is received
	if ($task->complete != 'thawed') {
		foreach ($frozen_directories as $frozen_directory) {
			if (strpos("$task->share/$task->full_path", $frozen_directory) === 0) {
				$action = $task->action;
				gh_log(DEBUG, "Now working on task ID $task->id: $task->action $task->share/$task->full_path" . ($task->action == 'rename' ? " -> $task->share/$task->additional_info" : ''));
				gh_log(DEBUG, "  This directory is frozen. Will postpone this task until it is thawed.");
				postpone_task($task->id, 'frozen');
				archive_task($task->id);
				return;
			}
		}
	}
	
	if (($key = array_search($task->id, $sleep_before_task)) !== FALSE) {
		$action = 'sleep';
		gh_log(DEBUG, "Only locked files operations pending... Sleeping.");
		sleep($log_level == DEBUG ? 10 : ($log_level == TEST ? 1 : 600));
		$sleep_before_task = array();
	}
	
	$action = $task->action;
	gh_log(DEBUG, "Now working on task ID $task->id: $task->action $task->share/$task->full_path" . ($task->action == 'rename' ? " -> $task->share/$task->additional_info" : ''));

	switch ($task->action) {
		case 'balance':
			gh_log(INFO, "Starting available space balancing");
			gh_balance();
			gh_log(INFO, "Available space balancing completed.");
			break;
		case 'fsck_file':
			$file_type = @filetype($task->full_path);
			list($path, $filename) = explode_full_path($task->full_path);
			gh_fsck_file($path, $filename, $file_type, 'landing_zone', $task->share);
			break;
		case 'fsck':
			gh_log(INFO, "Starting fsck for $task->share");
			initialize_fsck_report($task->share == '' ? 'All shares' : $task->share);
			if (strpos($task->additional_info, 'du') !== FALSE) {
				global $options;
				$options['disk-usage-report'] = TRUE;
			}
			clearstatcache();
			if ($task->share == '') {
				foreach ($shares_options as $share_name => $share_options) {
					gh_fsck($share_options['landing_zone'], $share_name);
				}
				if (strpos($task->additional_info, 'graveyard') !== FALSE) {
					foreach (get_graveyards() as $graveyard) {
						foreach ($shares_options as $share_name => $share_options) {
							gh_fsck_graveyard($graveyard, "/$share_name", $share_name);
						}
					}
				}
			} else {
				$share_options = get_share_options_from_full_path($task->share);
				if ($share_options !== FALSE) {
					$share = $share_options['name'];
					gh_fsck($task->share, $share);

					if (strpos($task->additional_info, 'graveyard') !== FALSE) {
						$subdir = "/$share" . str_replace($share_options['landing_zone'], '', $task->share);
						gh_log(DEBUG, "Starting graveyards fsck for $subdir");
						foreach (get_graveyards() as $graveyard) {
							gh_fsck_graveyard($graveyard, $subdir, $share);
						}
					}
				}
			}
			gh_log(INFO, "fsck for " . ($task->share == '' ? 'All shares' : $task->share) . " completed.");
			if (strpos($task->additional_info, 'email') !== FALSE) {
				// Email report for daily fsck
				$fsck_report = get_fsck_report();
				$hostname = exec('hostname');
				gh_log(DEBUG, "Sending fsck report to $email_to");
				mail($email_to, 'fsck of Greyhole shares on ' . $hostname, $fsck_report);
			}
			if (strpos($task->additional_info, 'du') !== FALSE) {
				// Save disk-usage report to disk
				$fp = fopen('/usr/local/greyhole/gh-disk-usage.log', 'w');
				if ($fp) {
					global $du;
					foreach ($du as $path => $size) {
						$chars_count = count_chars($path, 1);
						fwrite($fp, $chars_count[ord('/')] . " $path $size\n");
					}
					fwrite($fp, "# " . serialize($shares_options) . "\n");
					fclose($fp);
				}
			}
			break;
		case 'mkdir':
			break;
		case 'write':
			gh_write($task->share, $task->full_path, $task->id);
			break;
		case 'rename':
			gh_rename($task->share, $task->full_path, $task->additional_info, $task->id);
			break;
		case 'unlink':
			gh_unlink($task->share, $task->full_path, $task->id);
			break;
		case 'rmdir':
			gh_rmdir($task->share, $task->full_path);
			break;
	}
	if ($task->action != 'write' && $task->action != 'rename') {
		$sleep_before_task = array();
	}
	archive_task($task->id);
}

function archive_task($task_id) {
	$query = sprintf("INSERT INTO tasks_completed SELECT * FROM tasks WHERE id = %d", $task_id);
	db_query($query) or gh_log(CRITICAL, "Can't insert in tasks_completed: " . db_error());

	$query = sprintf("DELETE FROM tasks WHERE id = %d", $task_id);
	db_query($query) or gh_log(CRITICAL, "Can't delete from tasks: " . db_error());
}

function gh_rmdir($share, $full_path) {
	global $storage_pool_directories, $attic_share_names;
	$landing_zone = get_share_landing_zone($share);
	if (!$landing_zone) {
		return;
	}
	
	gh_log(INFO, "Directory deleted: $landing_zone/$full_path");
	
	if (array_search($share, $attic_share_names) !== FALSE) {
		// Remove that directory from all attics
		foreach ($storage_pool_directories as $target_drive) {
			if (@rmdir("$target_drive/.gh_attic/$full_path")) {
				gh_log(DEBUG, "  Removed copy from attic at $target_drive/.gh_attic/$full_path");
			}
		}
		return;
	}

	foreach ($storage_pool_directories as $target_drive) {
		if (@rmdir("$target_drive/$share/$full_path/")) {
			gh_log(DEBUG, "  Removed copy at $target_drive/$share/$full_path");
		}
		$graveyard = "$target_drive/.gh_graveyard";
		if (@rmdir("$graveyard/$share/$full_path/")) {
			gh_log(DEBUG, "  Removed tombstones directory $graveyard/$share/$full_path");
		}
	}
}

function gh_unlink($share, $full_path, $task_id) {
	global $attic_share_names, $attic_share, $storage_pool_directories;
	
	$landing_zone = get_share_landing_zone($share);
	if (!$landing_zone) {
		return;
	}
	
	gh_log(INFO, "File deleted: $landing_zone/$full_path");
	
	if (array_search($share, $attic_share_names) !== FALSE) {
		// Will delete the file in the attic which has no corresponding symlink in the Greyhole Attic share.
		// That symlink is what was deleted from that share to create the task we're currently working on.
		$full_path = preg_replace('/ copy [0-9]+$/', '', $full_path);
		gh_log(DEBUG, "  Looking for corresponding file in attic to delete...");
		foreach ($storage_pool_directories as $target_drive) {
			if (file_exists("$target_drive/.gh_attic/$full_path")) {
				$delete = TRUE;
				list($path, $filename) = explode_full_path("{$attic_share['landing_zone']}/$full_path");
				if ($dh = opendir($path)) {
					while (($file = readdir($dh)) !== FALSE) {
						if ($file == '.' || $file == '..') { continue; }
						if (is_link("$path/$file") && readlink("$path/$file") == "$target_drive/.gh_attic/$full_path") {
							$delete = FALSE;
							continue;
						}
					}
				}
				if ($delete) {
					gh_log(DEBUG, "    Deleting corresponding copy $target_drive/.gh_attic/$full_path");
					unlink("$target_drive/.gh_attic/$full_path");
					break;
				}
			}
		}
		return;
	}

	if (gh_file_exists("$landing_zone/$full_path") && !is_dir("$landing_zone/$full_path")) {
		gh_log(DEBUG, "  File still exists in landing zone; a new file replaced the one deleted here. Skipping.");
		return;
	}

	list($path, $filename) = explode_full_path($full_path);

	$existing_tombstones = get_tombstones($share, $path, $filename, TRUE);
	foreach ($existing_tombstones as $tombstone) {
		gh_recycle($tombstone->path);
	}
	remove_tombstones($share, $path, $filename);
}

function is_a_graveyard_dir($share, $full_path) {
	foreach (get_graveyards() as $graveyard) {
		if (is_dir("$graveyard/$share/$full_path")) {
			return TRUE;
		}
	}
	return FALSE;
}

function gh_rename($share, $full_path, $target_full_path, $task_id) {
	global $storage_pool_directories, $log_level, $sleep_before_task;
	$landing_zone = get_share_landing_zone($share);
	if (!$landing_zone) {
		return;
	}
	
	if (is_dir("$landing_zone/$target_full_path") || is_a_graveyard_dir($share, $full_path)) {
		gh_log(INFO, "Directory renamed: $landing_zone/$full_path -> $landing_zone/$target_full_path");

		$existing_tombstones = get_tombstones($share, $full_path, null, FALSE, FALSE, FALSE); // $check_symlink=FALSE to prevent symlinks to be handled at this point; they'll be fixed below.

		foreach ($storage_pool_directories as $target_drive) {
			list($original_path, $dirname) = explode_full_path(get_share_landing_zone($share) . "/$target_full_path");

			if (is_dir("$target_drive/$share/$full_path")) {
				# Make sure the parent directory of target_full_path exists, before we try moving something there...
				list($path, $dirname) = explode_full_path("$target_drive/$share/$target_full_path");
				gh_mkdir($path, $original_path);

				rename("$target_drive/$share/$full_path", "$target_drive/$share/$target_full_path");
				gh_log(DEBUG, "  Directory moved: $target_drive/$share/$full_path -> $target_drive/$share/$target_full_path");
			}

			list($path, $dirname) = explode_full_path("$target_drive/.gh_graveyard/$share/$target_full_path");
			gh_mkdir($path, $original_path);
			$result = @rename("$target_drive/.gh_graveyard/$share/$full_path", "$target_drive/.gh_graveyard/$share/$target_full_path");
			if ($result) {
				gh_log(DEBUG, "  Graveyard directory moved: $target_drive/.gh_graveyard/$share/$full_path -> $target_drive/.gh_graveyard/$share/$target_full_path");
			}
		}

		foreach ($existing_tombstones as $file_path => $file_tombstones) {
			$new_file_tombstones = array();
			$symlinked = FALSE;
			foreach ($file_tombstones as $key => $tombstone) {
				$old_path = $tombstone->path;
				$tombstone->path = str_replace("/$share/$full_path/", "/$share/$target_full_path/", $tombstone->path);
				gh_log(DEBUG, "  Changing tombstone: $old_path -> $tombstone->path");
				$new_file_tombstones[$tombstone->path] = $tombstone;

				// is_linked = is the target of the existing symlink
				if ($tombstone->is_linked) {
					$symlinked = TRUE;
					gh_log(DEBUG, "  Updating symlink at $landing_zone/$target_full_path/$file_path to point to $tombstone->path");
					@unlink("$landing_zone/$target_full_path/$file_path");
					if (!file_exists("$landing_zone/$target_full_path/$file_path")) {
 						@symlink($tombstone->path, "$landing_zone/$target_full_path/$file_path");
						// Creating this symlink can fail if the parent dir was removed
					}
				}
			}
			if (!$symlinked && count($file_tombstones) > 0) {
				// None of the tombstones were is_linked; use the last one for the symlink.
				$tombstone->is_linked = TRUE;
				$file_tombstones[$key] = $tombstone;
				gh_log(DEBUG, "  Updating symlink at $landing_zone/$target_full_path/$file_path to point to $tombstone->path");
				@unlink("$landing_zone/$target_full_path/$file_path");
				if (!file_exists("$landing_zone/$target_full_path/$file_path")) {
					@symlink($tombstone->path, "$landing_zone/$target_full_path/$file_path");
					// Creating this symlink can fail if the parent dir was removed
				}
			}
			list($path, $filename) = explode_full_path("$target_full_path/$file_path");
			save_tombstones($share, $path, $filename, $new_file_tombstones);
		}
	} else {
		gh_log(INFO, "File renamed: $landing_zone/$full_path -> $landing_zone/$target_full_path");
		
		// Check if another process locked this file before we work on it.
		if (file_is_locked($share, $target_full_path) !== FALSE) {
			gh_log(DEBUG, "  File $landing_zone/$target_full_path is locked by another process. Will wait until it's unlocked to work on it.");
			postpone_task($task_id);
			return;
		}

		list($path, $filename) = explode_full_path($full_path);
		list($target_path, $target_filename) = explode_full_path($target_full_path);

		$existing_tombstones = get_tombstones($share, $path, $filename, FALSE, FALSE, FALSE); // $check_symlink=FALSE to prevent symlink to be handled at this point; it'll be fixed below.

		// There might be old tombstones... for example, when a delete task was skipped.
		// Let's remove the file copies if there are any leftovers; correct copies will be re-created below.
		if (file_exists("$landing_zone/$target_full_path") && (count($existing_tombstones) > 0 || !is_link("$landing_zone/$target_full_path"))) {
			$existing_target_tombstones = get_tombstones($share, $target_path, $target_filename);
			if (count($existing_target_tombstones) > 0) {
				foreach ($existing_target_tombstones as $tombstone) {
					gh_recycle($tombstone->path);
				}
				remove_tombstones($share, $target_path, $target_filename);
			}
		}

		if (count($existing_tombstones) == 0) {
			// Any NOK tombstones that need to be removed?
			$all_existing_tombstones = get_tombstones($share, $path, $filename, TRUE, FALSE, FALSE);
			if (count($all_existing_tombstones) > 0) {
				remove_tombstones($share, $path, $filename);
			}
			// New file
			gh_write($share, $target_full_path, $task_id);
		} else {
			$symlinked = FALSE;
			foreach ($existing_tombstones as $key => $tombstone) {
				$old_path = $tombstone->path;
				$tombstone->path = str_replace("/$share/$full_path", "/$share/$target_full_path", $old_path);
				gh_log(DEBUG, "  Renaming copy at $old_path to $tombstone->path");

				// Make sure the target directory exists
				list($tombstone_dir_path, $tombstone_filename) = explode_full_path($tombstone->path);
				list($original_path, $dirname) = explode_full_path(get_share_landing_zone($share) . "/$target_full_path");
				gh_mkdir($tombstone_dir_path, $original_path);

				$it_worked = rename($old_path, $tombstone->path);

				if ($it_worked) {
					// is_linked = is the target of the existing symlink
					$symlinked = TRUE;
					if ($tombstone->is_linked) {
						gh_log(DEBUG, "  Updating symlink at $landing_zone/$target_full_path to point to $tombstone->path");
						@unlink("$landing_zone/$target_full_path");
						if (!file_exists("$landing_zone/$target_full_path")) {
	 						@symlink($tombstone->path, "$landing_zone/$target_full_path");
							// Creating this symlink can fail if the parent dir was removed
						}
					}
				} else {
					gh_log(WARN, "    Warning! An error occured while renaming file copy $old_path to $tombstone->path.");
				}
				$existing_tombstones[$key] = $tombstone;
			}
			if (!$symlinked && count($existing_tombstones) > 0) {
				// None of the tombstones were is_linked; use the last one for the symlink.
				$tombstone->is_linked = TRUE;
				$existing_tombstones[$key] = $tombstone;
				gh_log(DEBUG, "  Updating symlink at $landing_zone/$target_full_path to point to $tombstone->path");
				@unlink("$landing_zone/$target_full_path");
				if (!file_exists("$landing_zone/$target_full_path")) {
					@symlink($tombstone->path, "$landing_zone/$target_full_path");
					// Creating this symlink can fail if the parent dir was removed
				}
			}
			remove_tombstones($share, $path, $filename);
			save_tombstones($share, $target_path, $target_filename, $existing_tombstones);

			if (is_link("$landing_zone/$full_path") && !file_exists(readlink("$landing_zone/$full_path"))) {
				gh_log(DEBUG, "  Removing deprecated symlink at $landing_zone/$full_path");
				unlink("$landing_zone/$full_path");
			}
		}
	}
	$sleep_before_task = array();
}

function gh_file_exists($real_path, $log_message=null) {
	clearstatcache();
	if (!file_exists($real_path)) {
		if ($log_message != null) {
			eval('$log_message = "' . str_replace('"', '\"', $log_message) . '";');
			gh_log(DEBUG, $log_message);
		}
		return FALSE;
	}
	return TRUE;
}

function get_num_copies($share) {
	global $shares_options, $storage_pool_directories;
	if (!isset($shares_options[$share]['num_copies'])) {
		global $config_file;
		gh_log(CRITICAL, "Found a share ($share_name) with no 'num_copies' value defined in $config_file. You need to edit $config_file to fix this, then restart Greyhole.");
	}
	$num_copies = $shares_options[$share]['num_copies'];
	if ($num_copies < 1) {
		$num_copies = 1;
	}
	if ($num_copies > count($storage_pool_directories)) {
		$num_copies = count($storage_pool_directories);
	}
	return $num_copies;
}

function file_is_locked($share, $full_path) {
	$landing_zone = get_share_landing_zone($share);
	if (!$landing_zone) {
		return FALSE;
	}
	
	$real_fullpath = "$landing_zone/$full_path";
	if (is_link($real_fullpath)) {
		$real_fullpath = readlink($real_fullpath);
	}
	$result = exec("lsof -M -n -P -l " . quoted_form($real_fullpath) . " 2> /dev/null");
	if (strpos($result, $real_fullpath) !== FALSE) {
		return $result;
	}
	$query = sprintf("SELECT * FROM tasks WHERE complete = 'no' AND action = 'write' AND share = '%s' AND full_path = '%s' LIMIT 1",
		db_escape_string($share),
		db_escape_string($full_path)
	);
	$result = db_query($query) or gh_log(CRITICAL, "Error querying tasks for locked files: " . db_error());
	return db_fetch_object($result) !== FALSE;
}

function real_file_is_locked($real_fullpath) {
	if (is_link($real_fullpath)) {
		$real_fullpath = readlink($real_fullpath);
	}
	$result = exec("lsof -M -n -P -l " . quoted_form($real_fullpath) . " 2> /dev/null");
	if (strpos($result, $real_fullpath) !== FALSE) {
		return $result;
	}
	return FALSE;
}

function gh_write($share, $full_path, $task_id) {
	global $storage_pool_directories, $log_level, $balance_modified_files, $sleep_before_task;
	
	$landing_zone = get_share_landing_zone($share);
	if (!$landing_zone) {
		return;
	}
	
	if (!gh_file_exists("$landing_zone/$full_path", 'File write: $real_path doesn\'t exist anymore. Skipping.')) {
		if (!gh_file_exists($landing_zone, '  Share "'.$share.'" landing zone "$real_path" doesn\'t exist anymore. Will not process this task until it re-appears...')) {
			postpone_task($task_id);
		}
		return;
	}
	
	$num_copies_required = get_num_copies($share);

	list($path, $filename) = explode_full_path($full_path);

	if (is_link("$landing_zone/$full_path")) {
		$source_file = clean_dir(readlink("$landing_zone/$full_path"));
		gh_log(INFO, "File changed: $share/$full_path", FALSE);
		clearstatcache();
		$filesize = gh_filesize($source_file);
		if ($log_level >= DEBUG) {
			gh_log(DEBUG, " - " . bytes_to_human($filesize, FALSE), FALSE);
		}
		gh_log(INFO, "");
		gh_log(DEBUG, "  Will use source file: $source_file");

		$existing_tombstones = get_tombstones($share, $path, $filename);
		
		// Will keep existing copies at their location if balance_modified_files = no
		// This will allow us to use rsync instead of blindly copying the complete files.
		if ($balance_modified_files) {
			// Remove old copies (but not the one that was updated!)
			$keys_to_remove = array();
			$found_source_file = FALSE;
			foreach ($existing_tombstones as $key => $tombstone) {
				$tombstone->path = clean_dir($tombstone->path);
				if ($tombstone->path == $source_file) {
					$tombstone->is_linked = TRUE;
					$tombstone->state = 'OK';
					$found_source_file = TRUE;
				} else {
					gh_log(DEBUG, "  Will remove copy at $tombstone->path");
					$keys_to_remove[] = $tombstone->path;
				}
				// This will make sure the correct key is used in the $existing_tombstones array...
				//   This is important because that key is what is used to check if there's already a copy on that drive.
				unset($existing_tombstones[$key]);
				$existing_tombstones[$tombstone->path] = $tombstone;
			}
			if (!$found_source_file) {
				// This shouldn't happen, but if we're about to remove all copies, let's make sure we keep at least one.
				$key = array_shift($keys_to_remove);
				$source_file = $existing_tombstones[$key]->path;
				gh_log(DEBUG, "  Change of mind... Will use source file: $source_file");
			}
			foreach ($keys_to_remove as $key) {
				if ($existing_tombstones[$key]->path != $source_file) {
					gh_recycle($existing_tombstones[$key]->path);
				}
				unset($existing_tombstones[$key]);
			}
		}
	} else {
		$source_file = clean_dir("$landing_zone/$full_path");
		gh_log(INFO, "File created: $share/$full_path", FALSE);
		clearstatcache();
		$filesize = gh_filesize($source_file);
		if ($log_level >= DEBUG) {
			gh_log(DEBUG, " - " . bytes_to_human($filesize, FALSE), FALSE);
		}
		gh_log(INFO, "");

		if (is_dir($source_file)) {
			gh_log(INFO, "$share/$full_path is now a directory! Aborting.");
			return;
		}

		// There might be old tombstones... for example, when a delete task was skipped.
		// Let's remove the file copies if there are any leftovers; correct copies will be re-created in create_copies_from_tombstones()
		$existing_tombstones = get_tombstones($share, $path, $filename);
		if (count($existing_tombstones) > 0) {
			foreach ($existing_tombstones as $tombstone) {
				gh_recycle($tombstone->path);
			}
			remove_tombstones($share, $path, $filename);
			$existing_tombstones = array();
			// Maybe there's other file copies, that weren't tombstones, or were NOK tombstones!
			global $storage_pool_directories;
			foreach ($storage_pool_directories as $dir) {
				if (file_exists("$dir/$share/$path/$filename")) {
					gh_recycle("$dir/$share/$path/$filename");
				}
			}
		}
	}

	// Only need to check for locking if we have something to do!
	if ($num_copies_required > 1 || count($existing_tombstones) == 0) {
		// Check if another process locked this file before we work on it.
		if (($locked_by = file_is_locked($share, $full_path)) !== FALSE) {
			gh_log(DEBUG, "  File is locked by another process. Will wait until it's unlocked to work on it.");
			postpone_task($task_id);
			return;
		}
		$sleep_before_task = array();
	}
	
	$tombstones = create_tombstones($share, $full_path, $num_copies_required, $filesize, $existing_tombstones);

	if (count($tombstones) == 0) {
		gh_log(WARN, "  No tombstones could be created. Will wait until tombstones can be created to work on this file.");
		postpone_task($task_id);
		return;
	}

	if (!is_link("$landing_zone/$full_path")) {
		// Use the 1st tombstone for the symlink; it might be on a sticky drive.
		$i = 0;
		foreach ($tombstones as $tombstone) {
			$tombstone->is_linked = ($i++ == 0);
		}
	}

	save_tombstones($share, $path, $filename, $tombstones);

	create_copies_from_tombstones($tombstones, $share, $full_path, $source_file);
}

function is_greyhole_owned_dir($path) {
	global $going_dir;
	if (isset($going_dir) && $path == $going_dir) {
		return FALSE;
	}
	return file_exists("$path/.greyhole_uses_this");
}

function create_copies_from_tombstones($tombstones, $share, $full_path, $source_file) {
	$landing_zone = get_share_landing_zone($share);
	
	list($path, $filename) = explode_full_path($full_path);

	$link_next = FALSE;
	foreach ($tombstones as $key => $tombstone) {
		if (!gh_file_exists("$landing_zone/$full_path", '  $real_path doesn\'t exist anymore. Aborting.')) { return; }
		
		if ($tombstone->path == $source_file && $tombstone->state == 'OK' && gh_filesize($tombstone->path) == gh_filesize($source_file)) {
			gh_log(DEBUG, "  File copy at $tombstone->path is already up to date.");
			continue;
		}

		gh_log(DEBUG, "  Copying file to $tombstone->path");

		$root_path = str_replace(clean_dir("/$share/$full_path"), '', $tombstone->path);
		if (!is_greyhole_owned_dir($root_path)) {
			gh_log(WARN, "  Warning! It seems $root_path is missing it's \".greyhole_uses_this\" file. This either means this mount is currently unmounted, or you forgot to create this file.");
			$tombstone->state = 'Gone';
			$tombstones[$key] = $tombstone;
			continue;
		}

		list($tombstone_dir_path, $tombstone_filename) = explode_full_path($tombstone->path);

		list($original_path, $tombstone_filename) = explode_full_path(get_share_landing_zone($share) . "/$full_path");
		if (!gh_mkdir($tombstone_dir_path, $original_path)) {
			$tombstone->state = 'Gone';
			$tombstones[$key] = $tombstone;
			continue;
		}

		$temp_path = get_temp_filename($tombstone->path);
		$file_infos = gh_get_file_infos("$landing_zone/$full_path");
		
		$it_worked = FALSE;
		if (is_link("$landing_zone/$full_path")) {
			exec("rsync " . quoted_form(readlink("$landing_zone/$full_path")) . " " . quoted_form($temp_path));
			$it_worked = file_exists($temp_path) && gh_filesize($temp_path) == gh_filesize(readlink("$landing_zone/$full_path"));
		} else if (gh_is_file("$landing_zone/$full_path")) {
			exec("rsync " . quoted_form("$landing_zone/$full_path") . " " . quoted_form($temp_path));
			$it_worked = file_exists($temp_path) && file_exists("$landing_zone/$full_path") && gh_filesize($temp_path) == gh_filesize("$landing_zone/$full_path");
			if ($it_worked) {
				unlink("$landing_zone/$full_path");
			}
		}
		
		if ($it_worked) {
			rename($temp_path, $tombstone->path);
			gh_chperm($tombstone->path, $file_infos);
		} else {
			gh_log(WARN, "    Failed file copy. Will mark this tombstone 'Gone'.");
			@unlink($temp_path);
			if ($tombstone->is_linked) {
				$tombstone->is_linked = FALSE;
				$link_next = TRUE;
			}
			$tombstone->state = 'Gone';
			gh_recycle($tombstone->path);
			$tombstones[$key] = $tombstone;
			save_tombstones($share, $path, $filename, array_values($tombstones));

			if (file_exists("$landing_zone/$full_path")) {
				global $current_task_id;
				if ($current_task_id === 0) {
					gh_log(ERROR, "    Failed file copy (cont). We already retried this task. Aborting.");
					return;
				}
				gh_log(WARN, "    Failed file copy (cont). Will try to re-process this write task, since the source file seems intact.");
				// Queue a new write task, to replace the now gone copy.
				global $next_task;
				$next_task = (object) array(
					'id' => 0,
					'action' => 'write',
					'share' => $share, 
					'full_path' => clean_dir($full_path),
					'complete' => 'yes'
				);
				return;
			}
		    continue;
		}

		if ($link_next && !$tombstone->is_linked) {
			$tombstone->is_linked = TRUE;
			$tombstones[$key] = $tombstone;
		}
		$link_next = FALSE;
		if ($tombstone->is_linked) {
			gh_log(DEBUG, "    Creating symlink in share pointing to the above file copy.");
			symlink($tombstone->path, "$landing_zone/$path/.gh_$filename");
			if (!file_exists("$landing_zone/$full_path") || unlink("$landing_zone/$full_path")) {
				rename("$landing_zone/$path/.gh_$filename", "$landing_zone/$path/$filename");
			} else {
				unlink("$landing_zone/$path/.gh_$filename");
			}
		}

		if (gh_file_exists($tombstone->path, '  Copy at $real_path doesn\'t exist. Will not mark it OK!')) {
			$tombstone->state = 'OK';
			$tombstones[$key] = $tombstone;
		}
		save_tombstones($share, $path, $filename, array_values($tombstones));
	}
}

function gh_chperm($real_file_path, $file_infos) {
	chmod($real_file_path, $file_infos->fileperms);
	chown($real_file_path, $file_infos->fileowner);
	chgrp($real_file_path, $file_infos->filegroup);
}

function gh_mkdir($directory, $original_directory_or_dir_infos) {
	if (!is_dir($directory)) {
		if (is_string($original_directory_or_dir_infos)) {
			$dir_infos = gh_get_file_infos($original_directory_or_dir_infos);
		} else {
			$dir_infos = $original_directory_or_dir_infos;
		}
		
		// Need to mkdir & chown/chgrp all dirs that don't exists, up to the full path ($directory)
		$dir_parts = explode('/', $directory);
		
		$i = 0;
		$parent_directory = '/' . $dir_parts[$i++];
		while (is_dir($parent_directory)) {
			$parent_directory = $parent_directory . '/' . $dir_parts[$i++];
		}
		while ($i <= count($dir_parts)) {
			if (!mkdir($parent_directory, $dir_infos->fileperms)) {
				gh_log(WARN, "  Failed to create directory $parent_directory");
				return FALSE;
			}
			if (!chown($parent_directory, $dir_infos->fileowner)) {
				gh_log(WARN, "  Failed to chown directory '$parent_directory'");
			}
			if (!chgrp($parent_directory, $dir_infos->filegroup)) {
				gh_log(WARN, "  Failed to chgrp directory '$parent_directory'");
			}
			if (!isset($dir_parts[$i])) {
				break;
			}
			$parent_directory = $parent_directory . '/' . $dir_parts[$i++];
		}
	}
	return TRUE;
}

function get_temp_filename($full_path) {
	list($path, $filename) = explode_full_path($full_path);
	return "$path/.$filename." . substr(md5($filename), 0, 5);
}

function create_tombstones($share, $full_path, $num_copies_required, $filesize, $tombstones=array()) {
	global $going_dir;

	list($path, $filename) = explode_full_path($full_path);
	
	$num_ok = count($tombstones);
	foreach ($tombstones as $key => $tombstone) {
		if (!file_exists($tombstone->path)) {
			$tombstone->state = 'Gone';
		}
		if (!empty($going_dir) && strpos($tombstone->path, $going_dir) === 0) {
			$tombstone->state = 'Gone';
		}
		if ($tombstone->state != 'OK' && $tombstone->state != 'Pending') {
			$num_ok--;
		}
		if ($key != $tombstone->path) {
			unset($tombstones[$key]);
			$key = $tombstone->path;
		}
		$tombstones[$key] = $tombstone;
	}

	// Select drives that have enough free space for this file
	if ($num_ok < $num_copies_required) {
		$local_target_drives = order_target_drives($filesize/1024, FALSE, $share, $path);
	}
	while ($num_ok < $num_copies_required && count($local_target_drives) > 0) {
		$target_drive = array_shift($local_target_drives);
		$clean_target_full_path = clean_dir("$target_drive/$share/$full_path");
		// Don't use drives that already have a copy
		if (isset($tombstones[$clean_target_full_path])) {
			continue;
		}
		foreach ($tombstones as $tombstone) {
			if ($clean_target_full_path == clean_dir($tombstone->path)) {
				continue;
			}
		}
		// Prepend new target drives, to make sure sticky directories will be used first
		$tombstones = array_reverse($tombstones);
		$tombstones[$clean_target_full_path] = (object) array('path' => $clean_target_full_path, 'is_linked' => count($tombstones) == 0, 'state' => 'Pending');
		$tombstones = array_reverse($tombstones);
		$num_ok++;
	}
	return $tombstones;
}

function get_tombstone_data_filename($share, $path, $filename) {
	foreach (get_graveyards() as $graveyard) {
		$f = "$graveyard/$share/$path/$filename";
		if (gh_is_file($f)) {
			return $f;
		}
	}
	return FALSE;
}

function get_tombstones_for_dir($share, $path, $load_nok_tombstones, $quiet, $prefix='') {
	if (!$quiet) {
		gh_log(DEBUG, "Loading tombstones for (dir) $share" . (!empty($path) ? "/$path" : "") . "...");
	}

	$landing_zone = get_share_landing_zone($share);
	
	$tombstones = array();
	
	$loaded_tombstones_dir = array();
	
	// Find new files (files with no tombstones yet)
	$handle = @opendir("$landing_zone/$path");
	if ($handle) {
		while (($filename = readdir($handle)) !== FALSE) {
			if ($filename != '.' && $filename != '..') {
				if (is_dir("$landing_zone/$path/$filename")) {
					foreach (get_tombstones_for_dir($share, "$path/$filename", $load_nok_tombstones, $quiet, $prefix.$filename.'/') as $full_filename => $file_tombstones) {
						$tombstones[$full_filename] = $file_tombstones;
					}
					$loaded_tombstones_dir["$path/$filename"] = TRUE;
				} else if (gh_is_file("$landing_zone/$path/$filename") && !is_link("$landing_zone/$path/$filename")) {
					// Found a file in a renamed directory that has no tombstone. Let's queue it for processing.
					gh_log(DEBUG, "$share/$path/$filename is a file (not a symlink). Adding a new 'write' pending task for that file.");
					$query = sprintf("INSERT INTO tasks (action, share, full_path, complete) VALUES ('write', '%s', '%s', 'yes')",
						db_escape_string($share),
						db_escape_string(clean_dir("$path/$filename"))
					);
					db_query($query) or gh_log(CRITICAL, "Can't insert write task: " . db_error());
				}
			}
		}
	}

	foreach (get_graveyards() as $graveyard) {
		$handle = @opendir("$graveyard/$share/$path");
		if (!$handle) {
			#gh_log(DEBUG, "Got 0 tombstones ($graveyard/$share/$path does't exists).");
			continue;
		}
		while (($filename = readdir($handle)) !== FALSE) {
			if ($filename != '.' && $filename != '..') {
				if (is_dir("$graveyard/$share/$path/$filename")) {
					if (isset($loaded_tombstones_dir["$path/$filename"])) {
						// Already loaded the tombstones in this directory above
						continue;
					}
					foreach (get_tombstones_for_dir($share, "$path/$filename", $load_nok_tombstones, $quiet, $prefix.$filename.'/') as $full_filename => $file_tombstones) {
						$tombstones[$full_filename] = $file_tombstones;
					}
				} else {
					// Found a file
					if (isset($tombstones[$prefix.$filename])) {
						// For which we already have the tombstones...
						continue;
					}
					// Found a new file
					$tombstones[$prefix.$filename] = get_tombstones($share, $path, $filename, $load_nok_tombstones, $quiet);
					if (count($tombstones[$prefix.$filename]) == 0 && gh_is_file("$landing_zone/$path/$filename") && !is_link("$landing_zone/$path/$filename")) {
						// Found a file in a renamed directory that has no tombstone. Let's queue it for processing.
						gh_log(DEBUG, "$share/$path/$filename is a file (not a symlink). Adding a new 'write' pending task for that file.");
						$query = sprintf("INSERT INTO tasks (action, share, full_path, complete) VALUES ('write', '%s', '%s', 'yes')",
							db_escape_string($share),
							db_escape_string(clean_dir("$path/$filename"))
						);
						db_query($query) or gh_log(CRITICAL, "Can't insert write task: " . db_error());
					}
				}
			}
		}
		closedir($handle);
	}

	return $tombstones;
}

function get_tombstones($share, $path, $filename=null, $load_nok_tombstones=FALSE, $quiet=FALSE, $check_symlink=TRUE) {
	if ($filename === null) {
		// Load all tombstones from the specified directory
		$tombstones = get_tombstones_for_dir($share, $path, $load_nok_tombstones, $quiet);
		return $tombstones;
	}
	if (!$quiet) {
		gh_log(DEBUG, "Loading tombstones for $share" . (!empty($path) ? "/$path" : "") . "/$filename... ", FALSE);
	}
	$tombstones_data_file = get_tombstone_data_filename($share, $path, $filename);
	clearstatcache();
	$tombstones = array();
	if (file_exists($tombstones_data_file)) {
		$t = file_get_contents($tombstones_data_file);
		$tombstones = unserialize($t);
	}

	if ($check_symlink) {
		// Fix wrong 'is_linked' flags
		$share_file = get_share_landing_zone($share) . "/$path/$filename";
		$share_file_link_to = FALSE;
		if (is_link($share_file)) {
			$share_file_link_to = readlink($share_file);
		}
		foreach ($tombstones as $key => $tombstone) {
			if ($tombstone->state == 'OK' && $share_file_link_to !== FALSE) {
				if ($tombstone->is_linked && $tombstone->path != $share_file_link_to) {
					if (!$quiet) {
						gh_log(DEBUG, 'Changing is_linked to FALSE for ' . $tombstone->path);
					}
					$tombstone->is_linked = FALSE;
					$tombstones[$key] = $tombstone;
					save_tombstones($share, $path, $filename, array_values($tombstones));
				} else if (!$tombstone->is_linked && $tombstone->path == $share_file_link_to) {
					if (!$quiet) {
						gh_log(DEBUG, 'Changing is_linked to TRUE for ' . $tombstone->path);
					}
					$tombstone->is_linked = TRUE;
					$tombstones[$key] = $tombstone;
					save_tombstones($share, $path, $filename, array_values($tombstones));
				}
			}
		}
	}

	$ok_tombstones = array();
	foreach ($tombstones as $key => $tombstone) {
		$valid_path = FALSE;
		global $storage_pool_directories;
		foreach ($storage_pool_directories as $dir) {
			if (strpos($tombstone->path, $dir) === 0) {
				$valid_path = TRUE;
				break;
			}
		}
		if ($valid_path && ($load_nok_tombstones || $tombstone->state == 'OK')) {
			$ok_tombstones[$key] = $tombstone;
		} else {
			if (!$valid_path) {
				gh_log(INFO, "Found a tombstone pointing to a directory not defined in your storage pool: '$tombstone->path'. Will mark it as Gone.");
				$tombstone->state = 'Gone';
				$tombstones[$key] = $tombstone;
				save_tombstones($share, $path, $filename, array_values($tombstones));
			} else {
				gh_log(INFO, "Found a tombstone, pointing to '$tombstone->path', with state = '$tombstone->state'. We just want 'OK' tombstones; will not use this tombstone.");
			}
		}
	}
	$tombstones = $ok_tombstones;
	
	if (!$quiet) {
		gh_log(DEBUG, "Got " . count($tombstones) . " tombstones.");
	}
	return $tombstones;
}

function remove_tombstones($share, $path, $filename) {
	gh_log(DEBUG, "  Removing tombstones for $share" . (!empty($path) ? "/$path" : "") . ($filename!== null ? "/$filename" : ""));
	while (($f = get_tombstone_data_filename($share, $path, $filename)) !== FALSE) {
		@unlink($f);
		gh_log(DEBUG, "    Removed tombstone at $f");
		clearstatcache();
	}
}

function save_tombstones($share, $path, $filename, $tombstones) {
	if (count($tombstones) == 0) {
		remove_tombstones($share, $path, $filename);
		return;
	}

	gh_log(DEBUG, "  Saving " . count($tombstones) . " tombstones for $share" . (!empty($path) ? "/$path" : "") . ($filename!== null ? "/$filename" : ""));
	$paths_used = array();
	foreach (get_graveyards() as $graveyard) {
		$target_drive = str_replace('/.gh_graveyard', '', $graveyard);
		$data_filepath = "$graveyard/$share/$path";
		$has_tombstone = FALSE;
		foreach ($tombstones as $tombstone) {
			if (strpos($tombstone->path, $target_drive) === 0) {
				gh_mkdir($data_filepath, get_share_landing_zone($share) . "/$path");
				gh_log(DEBUG, "    Saving tombstones in $data_filepath/$filename");
				file_put_contents("$data_filepath/$filename", serialize($tombstones));
				$has_tombstone = TRUE;
				$paths_used[] = $data_filepath;
				break;
			}
		}
		if (!$has_tombstone && file_exists("$data_filepath/$filename")) {
			unlink("$data_filepath/$filename");
		}
	}
	if (count($paths_used) == 1) {
		// Also save a backup on another drive
		global $graveyard_backup_directories;
		if (count($graveyard_backup_directories) > 0) {
			if (strpos($paths_used[0], str_replace('.gh_graveyard_backup', '.gh_graveyard', $graveyard_backup_directories[0])) === FALSE) {
				$graveyard_backup_directory = $graveyard_backup_directories[0];
			} else {
				$graveyard_backup_directory = $graveyard_backup_directories[1];
			}
			$data_filepath = "$graveyard_backup_directory/$share/$path";
			gh_log(DEBUG, "    Saving tombstones (backup) in $data_filepath/$filename");
			gh_mkdir($data_filepath, get_share_landing_zone($share) . "/$path");
			file_put_contents("$data_filepath/$filename", serialize($tombstones));
		}
	}
}

function simplify_tasks() {
	global $action;
	$action = 'simplify_tasks';
	
	gh_log(DEBUG, "Simplifying pending tasks.");
	
	// Delete duplicate writes/renames
	$query = "SELECT GROUP_CONCAT(id) ids, action, share, full_path, additional_info FROM tasks WHERE action IN ('write', 'rename') GROUP BY action, share, full_path, additional_info HAVING COUNT(*) > 1";
	$result = db_query($query) or gh_log(CRITICAL, "Can't select duplicate tasks: " . db_error());
	while ($row = db_fetch_object($result)) {
		$ids = explode(',', $row->ids);
		sort($ids);
		array_pop($ids);
		gh_log(DEBUG, "  Removing " . count($ids) . " duplicate pending tasks for $row->share/" . (!empty($row->full_path) ? $row->full_path : '') . (!empty($row->additional_info) ? " -> $row->additional_info" : ''));
		
		$ids = implode(',', $ids);
		if ($ids[0] == ',') {
			$ids = substr($ids, 1);
		}
		$query = sprintf("DELETE FROM tasks WHERE id IN (%s)",
			$ids
		);
		db_query($query) or gh_log(CRITICAL, "Can't delete duplicate tasks: " . db_error());
	}
	db_free_result($result);
	
	// Remove locked write tasks
	$query = "SELECT share, full_path FROM tasks WHERE action = 'write' and complete = 'no'";
	$result = db_query($query) or gh_log(CRITICAL, "Can't select locked write tasks: " . db_error());
	while ($row = db_fetch_object($result)) {
		$query = sprintf("DELETE FROM tasks WHERE action = 'write' and complete = 'yes' AND share = '%s' AND full_path = '%s'",
			db_escape_string($row->share),
			db_escape_string($row->full_path)
		);
		db_query($query) or gh_log(CRITICAL, "Can't delete duplicate of locked write task: " . db_error());
	}
}

function parse_samba_log($simplify_after_parse=TRUE) {
	global $samba_log_file, $action, $attic_share_names, $max_queued_tasks;
	$old_action = $action;
	$action = 'parse_logs';

	gh_log(DEBUG, "Parsing Samba logs...");

	// If we have enough queued tasks (90% of $max_queued_tasks), let's not parse the log at this time, and get some work done.
	// Once we fall below that, we'll queue up to at most $max_queued_tasks new tasks, then get back to work.
	// This will effectively 'batch' large file operations to make sure the DB doesn't become a problem because of the number of row,
	//   and this will allow the end-user to see real activity, other that new rows in greyhole.tasks...
	$query = "SELECT COUNT(*) num_rows FROM tasks";
	$result = db_query($query) or gh_log(CRITICAL, "Can't get tasks count: " . db_error());
	$row = db_fetch_object($result);
	db_free_result($result);
	$num_rows = (int) $row->num_rows;
	if ($num_rows >= ($max_queued_tasks * 0.9)) {
		$action = $old_action;
		gh_log(DEBUG, "  More than " . ($max_queued_tasks * 0.9) . " tasks queued... Won't queue any more at this time.");
		return;
	}

	$query = sprintf("SELECT value FROM settings WHERE name = '%s'", 'last_read_log_smbd_line');
	$result = db_query($query) or gh_log(CRITICAL, "Can't query settings for 'last_read_log_smbd_line': " . db_error());
	$row = db_fetch_object($result);
	if ($row === FALSE || db_fetch_object($result) !== FALSE) {
		gh_log(CRITICAL, "Received " . ($row === FALSE ? 'no rows' : 'more than one row') . " when querying settings for 'last_read_log_smbd_line'; expected one.");
	}
	db_free_result($result);

	$f_seek_point = (int) $row->value;

	clearstatcache();
	$samba_log_size = gh_filesize($samba_log_file);
	if ($f_seek_point > $samba_log_size) {
		gh_log(DEBUG, "Log file size = $samba_log_size; forcing seek point to 0.");
		$f_seek_point = 0;
	}

	$fp = fopen($samba_log_file, 'r') or gh_log(CRITICAL, "Can't open Samba log file '$samba_log_file' for reading.");
	fseek($fp, $f_seek_point);

	$new_tasks = 0;
	$last_line = FALSE;
	$act = FALSE;
	while ($line = fgets($fp)) {
		if (($p = strpos($line, ' smbd_greyhole:')) !== FALSE) {
			$line = trim(substr($line, $p+16));

			// Prevent insertion of unneeded duplicates
			if ($line === $last_line) {
				continue;
			}

			$line_ar = explode('*', $line);
			if (count($line_ar) == 1) {
				continue;
			}

			$last_line = $line;

			// Close logs are only processed when no more duplicates are found, so we'll execute this now that a non-duplicate line was found.
			if ($act === 'close') {
				$query = sprintf("UPDATE tasks SET additional_info = NULL, complete = 'yes' WHERE complete = 'no' AND share = '%s' AND additional_info = '%s'",
					db_escape_string($share),
					$fd
				);
				db_query($query) or gh_log(CRITICAL, "Error updating tasks (1): " . db_error() . "; Query: $query");
			}

			$line = $line_ar;
			$act = array_shift($line);
			$share = array_shift($line);
			if ($act == 'mkdir') {
				// Nothing to do with those
				continue;
			}
			$result = array_pop($line);
			if (strpos($result, 'failed') === 0) {
				gh_log(DEBUG, "Failed $act in $share/$line[0]. Skipping.");
				continue;
			}
			unset($fullpath);
			unset($fullpath_target);
			unset($fd);
			switch ($act) {
				case 'open':
					$fullpath = array_shift($line);
					$fd = array_shift($line);
					$act = 'write';
					break;
				case 'rmdir':
				case 'unlink':
					$fullpath = array_shift($line);
					break;
				case 'rename':
					$fullpath = array_shift($line);
					$fullpath_target = array_shift($line);
					break;
				case 'close':
					$fd = array_shift($line);
					break;
				default:
					$act = FALSE;
			}
			if ($act === FALSE) {
				continue;
			}

			// Close logs are only processed when no more duplicates are found, so we won't execute it just yet; we'll process it the next time we find a non-duplicate line.
			if ($act != 'close') {
				if (isset($fd) && $fd == -1) {
					continue;
				}
				if ($act != 'unlink' && $act != 'rmdir' && array_search($share, $attic_share_names) !== FALSE) { continue; }
				$new_tasks++;
				$query = sprintf("INSERT INTO tasks (action, share, full_path, additional_info, complete) VALUES ('%s', '%s', %s, %s, '%s')",
					$act,
					db_escape_string($share),
					isset($fullpath) ? "'".db_escape_string(clean_dir($fullpath))."'" : 'NULL',
					isset($fullpath_target) ? "'".db_escape_string(clean_dir($fullpath_target))."'" : (isset($fd) ? "'$fd'" : 'NULL'),
					$act == 'write' ? 'no' : 'yes'
				);
				db_query($query) or gh_log(CRITICAL, "Error inserting task: " . db_error() . "; Query: $query");
			}

			update_last_read_log_smbd_line($fp);
			
			// If we have enough queued tasks ($max_queued_tasks), let's stop parsing the log, and get some work done.
			if ($num_rows+$new_tasks >= $max_queued_tasks) {
				gh_log(DEBUG, "  We now have more than $max_queued_tasks tasks queued... Will stop parsing for now.");
				break;
			}
		}
	}
	fclose($fp);

	// Close logs are only processed when no more duplicates are found, so we'll execute this now that we're done parsing the current log.
	if ($act == 'close') {
		$query = sprintf("UPDATE tasks SET additional_info = NULL, complete = 'yes' WHERE complete = 'no' AND share = '%s' AND additional_info = '%s'",
			db_escape_string($share),
			$fd
		);
		db_query($query) or gh_log(CRITICAL, "Error updating tasks (2): " . db_error() . "; Query: $query");
	}
	gh_log(DEBUG, "  Done parsing.");
	
	if ($simplify_after_parse && $new_tasks > 0) {
		$query = "SELECT COUNT(*) num_rows FROM tasks";
		$result = db_query($query) or gh_log(CRITICAL, "Can't get tasks count: " . db_error());
		$row = db_fetch_object($result);
		db_free_result($result);
		$num_rows = (int) $row->num_rows;
		if ($num_rows < 1000 || $num_rows % 5 == 0) { // Runs 1/5 of the times when num_rows > 1000
			if ($num_rows < 5000 || $num_rows % 100 == 0) { // Runs 1/100 of the times when num_rows > 5000
				simplify_tasks();
			}
		}
	}
	$action = $old_action;
}

function update_last_read_log_smbd_line($fp) {
	$f_seek_point = ftell($fp);
	$query = sprintf("UPDATE settings SET value = '%d' WHERE name = '%s'", $f_seek_point, 'last_read_log_smbd_line');
	db_query($query) or gh_log(CRITICAL, "Can't update settings for 'last_read_log_smbd_line': " . db_error());
}

function get_free_space_in_storage_pool_dirs() {
	global $storage_pool_directories, $df_command, $last_df_time, $last_dfs, $df_cache_time;
	if ($last_df_time > time() - $df_cache_time) {
		return $last_dfs;
	}
	$dfs = array();
	exec($df_command, $responses);
	array_shift($responses); // header
	foreach ($storage_pool_directories as $target_drive) {
		$target_dir = '';
		for ($i=0; $i<count($responses); $i++) {
			$response = explode(' ', $responses[$i]);
			$free_space = (float) array_pop($response);
			$mount = implode(' ', $response);
			if (strpos($target_drive, $mount) === 0 && strlen($mount) > strlen($target_dir)) {
				$target_dir = $mount;
				$target_freespace = $free_space;
			}
		}
		$dfs[$target_drive] = $target_freespace;
	}
	$last_df_time = time();
	$last_dfs = $dfs;
	return $dfs;
}

function order_target_drives($filesize_kb, $include_full_drives, $share, $path, $log_prefix='') {
	global $storage_pool_directories, $minimum_free_space_pool_directories, $dir_selection_algorithm, $last_OOS_notification, $sticky_files, $going_dir;
	$sorted_target_drives = array();
	$last_resort_sorted_target_drives = array();
	$full_drives = array();

	$dfs = get_free_space_in_storage_pool_dirs();

	foreach ($storage_pool_directories as $target_drive) {
		if (!isset($dfs[$target_drive])) {
			if (!is_dir($target_drive)) {
				gh_log(ERROR, "The directory at $target_drive doesn't exist. This partition will never be used!");
				if (file_exists('/usr/bin/hdactl')) {
					gh_log(ERROR, "You should de-select, then re-select this partition in your Amahi dashboard (http://hda), in the Shares > Storage Pool page, to fix this problem.");
				} else {
					gh_log(ERROR, "See the INSTALL file for instructions on how to prepare partitions to include in your storage pool.");
				}
			} else {
				gh_log(ERROR, "Can't find how much free space is left on $target_drive. This partition will never be used!");
				gh_log(ERROR, "Please report this using the Issues tab at http://greyhole.pommepause.com. You should include the following information in your ticket:");
				gh_log(ERROR, "===== Error report starts here =====");
				gh_log(ERROR, "Unknown free space for partition: $target_drive");
				global $df_command;
				gh_log(ERROR, "df_command: $df_command");
				unset($responses);
				exec($df_command, $responses);
				gh_log(ERROR, "Result of df_command: " . var_export($responses, TRUE));
				unset($responses);
				exec('df -k 2>&1', $responses);
				gh_log(ERROR, "Result of df -k: " . var_export($responses, TRUE));
				gh_log(ERROR, "===== Error report ends here =====");
			}
			continue;
		}
		if ($target_drive == $going_dir) {
			continue;
		}
		$free_space = $dfs[$target_drive];
		$minimum_free_space = (float) (isset($minimum_free_space_pool_directories[$target_drive]) ? $minimum_free_space_pool_directories[$target_drive]*1024*1024 : 0.0);
		$available_space = (float) $free_space - $minimum_free_space;
		if ($available_space <= $filesize_kb) {
			if ($free_space > $filesize_kb) {
				while (isset($last_resort_sorted_target_drives[$free_space])) {
					$free_space -= 0.001;
				}
				$last_resort_sorted_target_drives[$available_space] = $target_drive;
			} else {
				while (isset($full_drives[$free_space])) {
					$free_space -= 0.001;
				}
				$full_drives[$free_space] = $target_drive;
			}
			continue;
		}
		while (isset($sorted_target_drives[$available_space])) {
			$available_space -= 0.001;
		}
		$sorted_target_drives[$available_space] = $target_drive;
	}
	if ($dir_selection_algorithm == 'most_available_space') {
		krsort($sorted_target_drives);
		krsort($last_resort_sorted_target_drives);
	}
	
	// Email notification when all dirs are over-capacity
	if (count($sorted_target_drives) == 0) {
		gh_log(WARN, "  Warning! All storage pool directories are over-capacity!");
		if (!isset($last_OOS_notification)) {
			$query = sprintf("SELECT value FROM settings WHERE name = '%s'", 'last_OOS_notification');
			$result = db_query($query) or gh_log(CRITICAL, "Can't query settings for 'last_OOS_notification': " . db_error());
			$row = db_fetch_object($result);
			if ($row === FALSE || db_fetch_object($result) !== FALSE) {
				gh_log(CRITICAL, "Received " . ($row === FALSE ? 'no rows' : 'more than one row') . " when querying settings for 'last_OOS_notification'; expected one.");
			}
			db_free_result($result);
			$last_OOS_notification = $row->value;
		}
		if ($last_OOS_notification < strtotime('-1 day')) {
			global $email_to;

			gh_log(INFO, "  Sending email notification to $email_to");

			$hostname = exec('hostname');
			$body = "This is an automated email from Greyhole.

It appears all the defined storage pool directories are over-capacity.
You probably want to do something about this!

";
			foreach ($last_resort_sorted_target_drives as $free_space => $target_drive) {
				$minimum_free_space = (int) (isset($minimum_free_space_pool_directories[$target_drive]) ? $minimum_free_space_pool_directories[$target_drive] : 0);
				$body .= "$target_drive has " . number_format($free_space/1024/1024, 2) . " GB free; minimum specified in greyhole.conf: $minimum_free_space GB.\n";
			}
			mail($email_to, "Greyhole is out of space on $hostname!", $body);
			
			$last_OOS_notification = time();
			$query = sprintf("UPDATE settings SET value = '%s' WHERE name = '%s'", db_escape_string($last_OOS_notification), 'last_OOS_notification');
			db_query($query) or gh_log(CRITICAL, "Can't update settings for 'last_OOS_notification': " . db_error());
		}
	}

	if ($dir_selection_algorithm == 'random') {
		shuffle($sorted_target_drives);
		shuffle($last_resort_sorted_target_drives);
	}
	
	global $log_level;
	if ($log_level >= DEBUG) {
		if (count($sorted_target_drives) > 0) {
			$log = $log_prefix ."Drives with available space: ";
			foreach ($sorted_target_drives as $s => $d) {
				$log .= "$d (" . bytes_to_human($s*1024, FALSE) . " avail) - ";
			}
			gh_log(DEBUG, substr($log, 0, strlen($log)-2));
		}
		if (count($last_resort_sorted_target_drives) > 0) {
			$log = $log_prefix ."Drives with enough free space, but no available space: ";
			foreach ($last_resort_sorted_target_drives as $s => $d) {
				$log .= "$d (" . bytes_to_human($s*1024, FALSE) . " avail) - ";
			}
			gh_log(DEBUG, substr($log, 0, strlen($log)-2));
		}
		if (count($full_drives) > 0) {
			$log = $log_prefix ."Drives full: ";
			foreach ($full_drives as $s => $d) {
				$log .= "$d (" . bytes_to_human($s*1024, FALSE) . " free) - ";
			}
			gh_log(DEBUG, substr($log, 0, strlen($log)-2));
		}
	}
	
	$drives = array_merge($sorted_target_drives, $last_resort_sorted_target_drives);
	if ($include_full_drives) {
		$drives = array_merge($drives, $full_drives);
	}

	if (isset($sticky_files)) {
		global $is_sticky;
		$is_sticky = FALSE;
		foreach ($sticky_files as $share_dir => $stick_into) {
			if (gh_wild_strpos("$share/$path", $share_dir) === 0) {
				$is_sticky = TRUE;

 				$more_drives_needed = FALSE;
				if (count($stick_into) > 0) {
					// Stick files into specific drives: $stick_into
					// Let's check if those drives are listed in the config file!
					foreach ($stick_into as $key => $stick_into_dir) {
						if (array_search($stick_into_dir, $storage_pool_directories) === FALSE) {
							unset($stick_into[$key]);
							$more_drives_needed = TRUE;
						}
					}
				}
				if (count($stick_into) == 0 || $more_drives_needed) {
					if (strpos($share_dir, '*') !== FALSE) {
						// Contains a wildcard... In this case, we want each directory that match the wildcard to have it's own setting. Let's find this directory...
						// For example, if $share_dir == 'Videos/Movies/*/*' and "$share/$path/" == "Videos/Movies/HD/La Vita e Bella/", we want to save a 'stick_into' setting for 'Videos/Movies/HD/La Vita e Bella/'
						// Files in other subdirectories of Videos/Movies/HD/ could end up in other drives.
						$needles = explode('*', $share_dir);
						$sticky_dir = '';
						$wild_part = "$share/$path/";
						for ($i=0; $i<count($needles); $i++) {
							$needle = $needles[$i];
							if ($i == 0) {
								$sticky_dir = $needle;
								$wild_part = @str_replace_first($needle, '', $wild_part);
							} else {
								if ($needle == '') {
									$needle = '/';
								}
								$small_wild_part = substr($wild_part, 0, strpos($wild_part, $needle)+strlen($needle));
								$sticky_dir .= $small_wild_part;
								$wild_part = str_replace_first($small_wild_part, '', $wild_part);
							}
						}
						$sticky_dir = trim($sticky_dir, '/');
					} else {
						$sticky_dir = $share_dir;
					}

					// Stick files into any drives
					$query = sprintf("SELECT value FROM settings WHERE name = 'stick_into-%s'",
						db_escape_string($sticky_dir)
					);
					$result = db_query($query) or gh_log(CRITICAL, "Can't query settings for stick_target-$sticky_dir: " . db_error());
					$row = db_fetch_object($result);
					if ($row !== FALSE) {
						$stick_into = array_merge($stick_into, unserialize($row->value));
						// Let's check if those drives are listed in the config file!
						$update_needed = FALSE;
						foreach ($stick_into as $key => $stick_into_dir) {
							if (array_search($stick_into_dir, $storage_pool_directories) === FALSE) {
								unset($stick_into[$key]);
								$update_needed = TRUE;
							}
						}
						if ($update_needed) {
							$value = serialize($stick_into);
							$query = sprintf("UPDATE settings SET value = '%s' WHERE name = 'stick_into-%s'",
								db_escape_string($value),
								db_escape_string($sticky_dir)
							);
							db_query($query) or gh_log(CRITICAL, "Can't update settings for stick_into-$sticky_dir: " . db_error());
						}
					} else {
						$value = serialize(array_merge($stick_into, $drives));
						$query = sprintf("INSERT INTO settings (name, value) VALUES ('stick_into-%s', '%s')",
							db_escape_string($sticky_dir),
							db_escape_string($value)
						);
						db_query($query) or gh_log(CRITICAL, "Can't insert new settings for stick_into-$sticky_dir: " . db_error());
					}
				}
				
				// Make sure the drives we want to use are not yet full
				$priority_drives = array();
				foreach ($stick_into as $stick_into_dir) {
					if (array_search($stick_into_dir, $full_drives) === FALSE && array_search($stick_into_dir, $storage_pool_directories) !== FALSE) {
						unset($drives[array_search($stick_into_dir, $drives)]);
						$priority_drives[] = $stick_into_dir;
					}
				}
				$drives = array_merge($priority_drives, $drives);
				gh_log(DEBUG, $log_prefix . "Reordered drives, per sticky_files config: " . implode(' - ', $drives));
				break;
			}
		}
	}

	return $drives;
}

function gh_fsck($path, $share) {
	global $storage_pool_directories, $fsck_report;
	
	gh_log(DEBUG, "Entering $path");
	$fsck_report['landing_zone']['num_dirs']++;

	$list = array();
	$handle = opendir($path);
	if ($handle === FALSE) {
		gh_log(ERROR, "  Couldn't open $path to list content. Skipping...");
		return;
	}
	while (($filename = readdir($handle)) !== FALSE) {
		if ($filename != '.' && $filename != '..') {
			$full_path = "$path/$filename";
			$file_type = @filetype($full_path);
			if ($file_type == 'dir') {
				gh_fsck($full_path, $share);
			} else {
				$fsck_report['landing_zone']['num_files']++;
				gh_fsck_file($path, $filename, $file_type, 'landing_zone', $share);
			}
		}
	}
	closedir($handle);
}

function gh_fsck_graveyard($root, $path, $share) {
	global $fsck_report;
	
	gh_log(DEBUG, "Entering graveyard $root$path");
	if (!is_dir("$root$path")) {
		gh_log(DEBUG, "  Not a directory... Aborting.");
		return;
	}

	$handle = opendir("$root$path");
	while (($filename = readdir($handle)) !== FALSE) {
		if ($filename != '.' && $filename != '..') {
			if (@is_dir("$root$path/$filename")) {
				$fsck_report['graveyard']['num_dirs']++;
				gh_fsck_graveyard($root, "$path/$filename", $share);
			} else {
				// Found a tombstone
				$fsck_report['graveyard']['num_files']++;
				
				$path_parts = explode('/', $path);
				array_shift($path_parts);
				$share = array_shift($path_parts);
				$landing_zone = get_share_landing_zone($share);
				$local_path = $landing_zone . '/' . implode('/', $path_parts);
				
				// If file exists in landing zone, we already fsck-ed it in gh_fsck(); let's not repeat ourselves, shall we?
				if (!file_exists("$local_path/$filename")) {
					gh_fsck_file($local_path, $filename, FALSE, 'graveyard', $share);
				}
			}
		}
	}
	closedir($handle);
}

function gh_fsck_file($path, $filename, $file_type, $source, $share) {
	global $storage_pool_directories, $fsck_report, $options, $action;

	$landing_zone = get_share_landing_zone($share);

	$file_path = trim(substr($path, strlen($landing_zone)+1), '/');

	if ($file_type == 'file') {
		// Let's just add a 'write' task for this file; if it's a duplicate of an already pending task, it won't be processed twice, since the simplify function will remove such duplicates.
		gh_log(INFO, "$path/$filename is a file (not a symlink). Adding a new 'write' pending task for that file.");
		$query = sprintf("INSERT INTO tasks (action, share, full_path, complete) VALUES ('write', '%s', '%s', 'yes')",
			db_escape_string($share),
			db_escape_string(empty($file_path) ? $filename : clean_dir("$file_path/$filename"))
		);
		db_query($query) or gh_log(CRITICAL, "Can't insert write task: " . db_error());
		return;
	} else {
		if ($file_type == 'link' && !file_exists(readlink("$path/$filename"))) {
			// Link points to now gone copy; let's just remove it, and treat this as if the link was not there in the first place.
			unlink("$path/$filename");
			$file_type = FALSE;
		}
		if ($file_type === FALSE) {
			if ($action != 'fsck_file') {
				// Maybe this file was removed after fsck started, and thus shouldn't be re-created here!
				// We'll queue this file fsck (to restore the symlink) for when all other file operations have been executed.
				$query = sprintf("INSERT INTO tasks (action, share, full_path, complete) VALUES ('fsck_file', '%s', '%s', 'idle')",
					db_escape_string($share),
					db_escape_string(empty($file_path) ? $filename : clean_dir("$file_path/$filename"))
				);
				db_query($query) or gh_log(CRITICAL, "Can't insert write task: " . db_error());
				return;
			}
		}
	}

	$file_tombstones = array();
	$num_ok = 0;
	$file_copies_inodes = array();

	// Look for this file on all available drives
	foreach ($storage_pool_directories as $target_drive) {
		$clean_full_path = clean_dir("$target_drive/$share/$file_path/$filename");
		$inode_number = @gh_fileinode($clean_full_path);
		if ($inode_number !== FALSE) {
			if (is_dir($clean_full_path)) {
				gh_log(DEBUG, "Found a directory that should be a file! Will try to remove it, if it's empty.");
				@rmdir($clean_full_path);
				continue;
			}

			gh_log(DEBUG, "Found $clean_full_path");

			if (!is_greyhole_owned_dir($target_drive)) {
				gh_log(DEBUG, "  Directory $target_drive is not part of the Greyhole storage pool anymore. The above file will not be counted as a valid file copy, but can be used to create a new valid copy.");
				$file_tombstones[$clean_full_path] = (object) array('path' => $clean_full_path, 'is_linked' => FALSE, 'state' => 'Gone');
				if (!isset($original_file_path)) {
					$original_file_path = $clean_full_path;
				}
			} else {
				$file_tombstones[$clean_full_path] = (object) array('path' => $clean_full_path, 'is_linked' => FALSE, 'state' => 'OK');
				$file_copies_inodes[$inode_number] = $clean_full_path;
				$num_ok++;
			}
			
			// Temp files leftovers of stopped Greyhole executions
			$temp_filename = get_temp_filename($clean_full_path);
			if (file_exists($temp_filename) && gh_is_file($temp_filename)) {
				gh_log(INFO, "  Found temporary file $temp_filename ... deleting.");
				$fsck_report['temp_files'][] = $temp_filename;
				gh_recycle($temp_filename);
			}
		}
	}

	foreach (get_tombstones($share, $file_path, $filename, TRUE) as $tombstone) {
		$inode_number = @gh_fileinode($tombstone->path);
		if ($inode_number === FALSE) {
			$tombstone->state = 'Gone';
			$tombstone->is_linked = FALSE;

			$root_path = str_replace(clean_dir("/$share/$file_path/$filename"), '', $tombstone->path);
			if (gone_ok($root_path)) {
				// Let's not replace this copy yet...
				$file_copies_inodes[$tombstone->path] = $tombstone->path;
				$num_ok++;
				$fsck_report['gone_ok']++;
			}
		} else if (is_dir($tombstone->path)) {
			gh_log(DEBUG, "Found a directory that should be a file! Will try to remove it, if it's empty.");
			@rmdir($tombstone->path);
			$tombstone->state = 'Gone';
			$tombstone->is_linked = FALSE;
			continue;
		} else {
			$tombstone->state = 'OK';
			if (!isset($file_tombstones[$tombstone->path])) {
				$file_copies_inodes[$inode_number] = $tombstone->path;
				$num_ok++;
			}
		}
		$file_tombstones[clean_dir($tombstone->path)] = $tombstone;
	}

	if (count($file_copies_inodes) > 0) {
		// If no tombstone is linked, link the 1st one
		$found_linked_tombstone = FALSE;
		foreach ($file_tombstones as $key => $tombstone) {
			if ($tombstone->is_linked) {
				if (file_exists($tombstone->path)) {
					$found_linked_tombstone = TRUE;
					$expected_file_size = gh_filesize($tombstone->path);
					$original_file_path = $tombstone->path;
					break;
				} else {
					$tombstone->is_linked = FALSE;
					$tombstone->state = 'Gone';
				}
			}
		}
		if (!$found_linked_tombstone) {
			$first_tombstone = reset($file_tombstones);
			$first_tombstone->is_linked = TRUE;
			$expected_file_size = gh_filesize($first_tombstone->path);
			$original_file_path = $first_tombstone->path;
		}
		
		if (isset($options['disk-usage-report'])) {
			global $du;
			$du_path = '/' . trim(clean_dir("/$share/$file_path"), '/');
			do {
				if (!isset($du[$du_path])) {
					$du[$du_path] = 0;
				}
				$du[$du_path] += $expected_file_size;
				$du_path = substr($du_path, 0, strrpos($du_path, '/'));
			} while (!empty($du_path));
		}
		
		// Check that all file copies have the same size
		foreach ($file_copies_inodes as $key => $real_full_path) {
			if (array_search($real_full_path, array_keys($file_copies_inodes)) !== FALSE) {
				// That file isn't available atm, but it's OK.
				continue;
			}
			$file_size = gh_filesize($real_full_path);
			if ($file_size != $expected_file_size) {
				// Found a file with a different size than the original...
				// There might be a good reason. Let's look for one!
				if (real_file_is_locked($real_full_path) !== FALSE || real_file_is_locked($original_file_path) !== FALSE) {
					// Write operation in progress
					continue;
				}
				// A pending write transaction maybe?
				parse_samba_log(FALSE);
				$query = sprintf("SELECT * FROM tasks WHERE action = 'write' AND share = '%s' AND full_path = '%s'",
					db_escape_string($share),
					db_escape_string("$file_path/$filename")
				);
				$result = db_query($query) or gh_log(CRITICAL, "Can't select for pending writes" . db_error());
				if (db_fetch_object($result) !== FALSE) {
					// Pending write task
					continue;
				}
				// Found no good reason!

				if ($file_size == 0) {
					// Empty file; just delete it.
					gh_log(WARN, "  An empty file copy was found: $real_full_path is 0 bytes. Original: $original_file_path is " . number_format($expected_file_size) . " bytes. This empty copy will be deleted.");
					unlink($real_full_path);
				} else {
					gh_log(WARN, "  A file copy with a different file size than the original was found: $real_full_path is " . number_format($file_size) . " bytes. Original: $original_file_path is " . number_format($expected_file_size) . " bytes.");
					gh_recycle($real_full_path);
					$fsck_report['wrong_file_size'][clean_dir($real_full_path)] = array($file_size, $expected_file_size, $original_file_path);
				}
				// Will not count that copy as a valid copy!
				unset($file_copies_inodes[$key]);
				unset($file_tombstones[clean_dir($real_full_path)]);
			}
		}
	}

	$num_copies_required = get_num_copies($share);
	
	if (count($file_copies_inodes) == $num_copies_required) {
		if (!$found_linked_tombstone || $file_type != 'link') {
			// Re-create symlink...
			if (!$found_linked_tombstone) {
				// ... the old one points to a drive that was replaced
				gh_log(INFO, '  Symlink target moved. Updating symlink.');
				$fsck_report['symlink_target_moved']++;
			} else {
				// ... it was missing
				gh_log(INFO, '  Symlink was missing. Creating new symlink.');
			}
			foreach ($file_tombstones as $key => $tombstone) {
				if ($tombstone->is_linked) {
					gh_log(DEBUG, "  Updating symlink at $landing_zone/$file_path/$filename to point to $tombstone->path");
					@unlink("$landing_zone/$file_path/$filename");
					list($tombstone_dir_path, $tombstone_filename) = explode_full_path($tombstone->path);
					gh_mkdir("$landing_zone/$file_path", $tombstone_dir_path);
					symlink($tombstone->path, "$landing_zone/$file_path/$filename");
					break;
				}
			}
			save_tombstones($share, $file_path, $filename, array_values($file_tombstones));
		}
	} else if (count($file_copies_inodes) == 0 && !isset($original_file_path)) {
		gh_log(WARN, '  WARNING! No copies of this file are available in the Greyhole storage pool. ' . (is_link("$landing_zone/$file_path/$filename") ? 'Deleting from share.' : 'Did you copy that file there without using your Samba shares..? (If you did, don\'t do that in the future!)'));
		if (is_link("$landing_zone/$file_path/$filename")) {
			gh_recycle("$landing_zone/$file_path/$filename");
			if ($source == 'graveyard' || get_tombstone_data_filename($share, $file_path, $filename) !== FALSE) {
				$fsck_report['no_copies_found_files'][clean_dir("$share/$file_path/$filename")] = TRUE;
			}
		} else {
			gh_log(INFO, "$file_path/$filename is a file (not a symlink). Adding a new 'write' pending task for that file.");
			$query = sprintf("INSERT INTO tasks (action, share, full_path, complete) VALUES ('write', '%s', '%s', 'yes')",
				db_escape_string($share),
				db_escape_string(empty($file_path) ? $filename : clean_dir("$file_path/$filename"))
			);
			db_query($query) or gh_log(CRITICAL, "Can't insert write task: " . db_error());
		}
		save_tombstones($share, $file_path, $filename, array_values($file_tombstones));
	} else if (count($file_copies_inodes) < $num_copies_required) {
		// Create new copies
		gh_log(INFO, "  Missing file copies. Expected $num_copies_required, got " . count($file_copies_inodes) . ". Will create more copies using $original_file_path");
		$fsck_report['missing_copies']++;
		clearstatcache(); $filesize = gh_filesize("$original_file_path");
		$file_tombstones = create_tombstones($share, "$file_path/$filename", $num_copies_required, $filesize, $file_tombstones);

		// Re-copy the file everywhere, and re-create the symlink
		$symlink_created = FALSE;
		$num_copies_current = 1; # the source file
		global $going_dir;
		if (!empty($going_dir)) {
			// Let's not count the source file here, since it will be gone soon!
			$num_copies_current = 0;
		}
		foreach ($file_tombstones as $key => $tombstone) {
			if ($original_file_path != $tombstone->path) {
				if ($num_copies_current >= $num_copies_required) {
					$tombstone->state = 'Gone';
					$file_tombstones[$key] = $tombstone;
					continue;
				}

				list($tombstone_dir_path, $tombstone_filename) = explode_full_path($tombstone->path);

				if ($tombstone->state == 'Gone') {
					foreach ($storage_pool_directories as $target_drive) {
						if (strpos($tombstone_dir_path, $target_drive) === 0 && is_greyhole_owned_dir($target_drive)) {
							$tombstone->state = 'Pending';
							$file_tombstones[$key] = $tombstone;
							break;
						}
					}
				}

				if ($tombstone->state != 'Gone') {
					$root_path = str_replace(clean_dir("/$share/$file_path"), '', $tombstone_dir_path);
					list($original_path, $tombstone_filename) = explode_full_path(get_share_landing_zone($share) . "/$file_path");
					if (!gh_mkdir($tombstone_dir_path, $original_path)) {
						$tombstone->state = 'Gone';
						$file_tombstones[$key] = $tombstone;
						continue;
					}
				}
				
				if (!is_dir($tombstone_dir_path) || $tombstone->state == 'Gone') {
					continue;
				}

				if ($tombstone->state == 'Pending') {
					gh_log(DEBUG, "  Copying file to $tombstone->path");
					$temp_path = get_temp_filename($tombstone->path);
					exec("rsync " . quoted_form($original_file_path) . " " . quoted_form($temp_path));
					$it_worked = file_exists($temp_path) && file_exists($original_file_path) && gh_filesize($temp_path) == gh_filesize($original_file_path);
					if ($it_worked) {
						rename($temp_path, $tombstone->path);
						gh_chperm($tombstone->path, gh_get_file_infos($original_file_path));
						$tombstone->state = 'OK';
						$num_copies_current++;
					} else {
						gh_log(WARN, "    Failed file copy. Skipping.");
						if ($tombstone->is_linked) {
							$tombstone->is_linked = FALSE;
						}
						$tombstone->state = 'Gone';
					}
					$file_tombstones[$key] = $tombstone;
				}
			}
			if ($original_file_path == $tombstone->path || $tombstone->is_linked) {
				if (!empty($going_dir) && strpos($original_file_path, $going_dir) === 0) {
					$tombstone->is_linked = FALSE;
					$tombstone->state = 'Gone';
					$file_tombstones[$key] = $tombstone;
					continue;
				}
				if ($symlink_created /* already */) {
					$tombstone->is_linked = FALSE;
					$file_tombstones[$key] = $tombstone;
					continue;
				}
				gh_log(DEBUG, "  Updating symlink at $landing_zone/$file_path/$filename to point to $tombstone->path");
				gh_recycle("$landing_zone/$file_path/$filename");
				list($tombstone_dir_path, $tombstone_filename) = explode_full_path($tombstone->path);
				gh_mkdir("$landing_zone/$file_path", $tombstone_dir_path);
				symlink($tombstone->path, "$landing_zone/$file_path/$filename");
				$symlink_created = TRUE;
			}
		}
		if (!$symlink_created) {
			foreach ($file_tombstones as $key => $tombstone) {
				if ($tombstone->state == 'OK') {
					$tombstone->is_linked = TRUE;
					$file_tombstones[$key] = $tombstone;
					gh_log(DEBUG, "  Updating symlink at $landing_zone/$file_path/$filename to point to $tombstone->path");
					gh_recycle("$landing_zone/$file_path/$filename");
					list($tombstone_dir_path, $tombstone_filename) = explode_full_path($tombstone->path);
					gh_mkdir("$landing_zone/$file_path", $tombstone_dir_path);
					symlink($tombstone->path, "$landing_zone/$file_path/$filename");
					break;
				}
			}
		}
		save_tombstones($share, $file_path, $filename, array_values($file_tombstones));
	} else {
		# Let's not assume that files on missing drives are really there... Removing files here could be dangerous!
		foreach ($file_copies_inodes as $inode => $path) {
			if (strpos($inode, '/') === 0) {
				unset($file_copies_inodes[$inode]);
			}
		}
		if (count($file_copies_inodes) > $num_copies_required) {
			gh_log(INFO, "  Too many file copies. Expected $num_copies_required, got " . count($file_copies_inodes) . ". Will try to remove some.");
			if (file_is_locked($share, "$file_path/$filename") !== FALSE) {
				gh_log(INFO, "  File is locked. Will not remove copies at this time. The next fsck will try to remove copies again.");
				return;
			}
			$fsck_report['too_many_copies']++;
		
			$local_target_drives = array_values(order_target_drives(0, TRUE, $share, $file_path));
			while (count($file_copies_inodes) > $num_copies_required && !empty($local_target_drives)) {
				$target_drive = array_pop($local_target_drives);
				$key = clean_dir("$target_drive/$share/$file_path/$filename");
				gh_log(DEBUG, "  Looking for copy at $key");
				if (isset($file_tombstones[$key]) || gh_file_exists($key)) {
					if (isset($file_tombstones[$key])) {
						$tombstone = $file_tombstones[$key];
					}
					if (gh_file_exists($key) || $tombstone->state == 'OK') {
						gh_log(DEBUG, "    Found file copy at $key, or tombstone is marked OK.");
						if (real_file_is_locked($key) !== FALSE) {
							gh_log(DEBUG, "    File copy is locked. Won't remove it.");
							continue;
						}
						$fsck_report['too_many_files'][] = $key;
						gh_log(DEBUG, "    Removing copy at $key");
						unset($file_copies_inodes[gh_fileinode($key)]);
						gh_recycle($key);
						if (isset($file_tombstones[$key])) {
							unset($file_tombstones[$key]);
						}
						$num_ok--;
					}
				}
			}

			// If no tombstone is linked, link the 1st one
			$found_linked_tombstone = FALSE;
			foreach ($file_tombstones as $key => $tombstone) {
				if ($tombstone->is_linked) {
					$found_linked_tombstone = TRUE;
					break;
				}
			}
			if (!$found_linked_tombstone) {
				$tombstone = reset($file_tombstones);
				gh_log(DEBUG, "  Updating symlink at $landing_zone/$file_path/$filename to point to $tombstone->path");
				gh_recycle("$landing_zone/$file_path/$filename");
				list($tombstone_dir_path, $tombstone_filename) = explode_full_path($tombstone->path);
				gh_mkdir("$landing_zone/$file_path", $tombstone_dir_path);
				symlink($tombstone->path, "$landing_zone/$file_path/$filename");
				reset($file_tombstones)->is_linked = TRUE;
			}

			save_tombstones($share, $file_path, $filename, array_values($file_tombstones));
		}
	}
}

function initialize_fsck_report($what) {
	global $fsck_report;
	$fsck_report = array();
	$fsck_report['start'] = time();
	$fsck_report['what'] = $what;
	$fsck_report['graveyard'] = array();
	$fsck_report['graveyard']['num_dirs'] = 0;
	$fsck_report['graveyard']['num_files'] = 0;
	$fsck_report['landing_zone'] = array();
	$fsck_report['landing_zone']['num_dirs'] = 0;
	$fsck_report['landing_zone']['num_files'] = 0;
	$fsck_report['no_copies_found_files'] = array();
	$fsck_report['symlink_target_moved'] = 0;
	$fsck_report['too_many_copies'] = 0;
	$fsck_report['too_many_files'] = array();
	$fsck_report['missing_copies'] = 0;
	$fsck_report['wrong_file_size'] = array();
	$fsck_report['temp_files'] = array();
	$fsck_report['gone_ok'] = 0;
}

function get_fsck_report() {
	global $fsck_report, $storage_pool_directories, $gone_ok_drives;
	
	$fsck_report['end'] = time();
	
	$displayable_duration = duration_to_human($fsck_report['end'] - $fsck_report['start']);
	
	$report = "fsck report
-----------
Scanned directory: " . $fsck_report['what'] . "

Started:  " . date('Y-m-d H:i:s', $fsck_report['start']) . "
Ended:    " . date('Y-m-d H:i:s', $fsck_report['end']) . "
Duration: $displayable_duration

Graveyard:
  Found " . number_format($fsck_report['graveyard']['num_dirs']) . " directories
  Found " . number_format($fsck_report['graveyard']['num_files']) . " files

Landing Zone (shares):
  Found " . number_format($fsck_report['landing_zone']['num_dirs']) . " directories
  Found " . number_format($fsck_report['landing_zone']['num_files']) . " files

Attic size:\n";

	foreach ($storage_pool_directories as $dir) {
		$attic_path = clean_dir("$dir/.gh_attic");
		if (is_dir($attic_path)) {
			$report .= "  $attic_path = " . trim(exec("du -sh " . quoted_form($attic_path) . " | awk '{print $1}'"))."\n";
		} else {
			$report .= "  $attic_path = empty\n";
		}
	}

	// Errors
	if (empty($fsck_report['no_copies_found_files']) && count($fsck_report['wrong_file_size']) == 0) {
		$report .= "\nNo problems found.\n\n";
	} else {
		$report .= "\nProblems:\n";

		if (!empty($fsck_report['no_copies_found_files'])) {
			ksort($fsck_report['no_copies_found_files']);
			$report .= "  Found " . count($fsck_report['no_copies_found_files']) . " files in the graveyard for which no file copies were found.
    Those files were removed from the Landing Zone. (i.e. those files are now gone!) They will re-appear in your shares if a copy re-appear and fsck is run.
    If you don't want to see those files listed here each time fsck runs, delete the corresponding files from the graveyard.
  Files with no copies:\n";
			$report .= "    " . implode("\n    ", array_keys($fsck_report['no_copies_found_files'])) . "\n\n";
		}

		if (count($fsck_report['wrong_file_size']) > 0) {
			$report .= "  Found " . count($fsck_report['wrong_file_size']) . " file copies with the wrong file size. Those files don't have the same file size as the original files available on your shares. The invalid copies have been moved into the attic.\n";
			foreach ($fsck_report['wrong_file_size'] as $real_file_path => $info_array) {
				$report .= "    $real_file_path is " . number_format($info_array[0]) . " bytes; should be " . number_format($info_array[1]) . " bytes.\n";
			}
			$report .= "\n\n";
		}
	}

	// Warnings
	if ($fsck_report['too_many_copies'] == 0 && $fsck_report['symlink_target_moved'] == 0 && count($fsck_report['temp_files']) == 0 && $fsck_report['gone_ok'] == 0) {
		// Nothing to say...
	} else {
		$report .= "Notices:\n";

		if ($fsck_report['too_many_copies'] > 0) {
			$fsck_report['too_many_files'] = array_unique($fsck_report['too_many_files']);
		
			$report .= "  Found " . $fsck_report['too_many_copies'] . " files for which there was too many file copies. Deleted (or moved in attic) files:\n";
			$report .= "    " . implode("\n    ", $fsck_report['too_many_files']) . "\n\n";
		}

		if ($fsck_report['symlink_target_moved'] > 0) {
			$report .= "  Found " . $fsck_report['symlink_target_moved'] . " files in the Landing Zone that were pointing to a now gone copy.
    Those symlinks were updated to point to the new location of those file copies.\n\n";
		}

		if (count($fsck_report['temp_files']) > 0) {
			$report .= "  Found " . count($fsck_report['temp_files']) . " temporary files, which are leftovers of interrupted Greyhole executions. The following temporary files were deleted (or moved into the attic):\n";
			$report .= "    " . implode("\n    ", $fsck_report['temp_files']) . "\n\n";
		}
	
		if ($fsck_report['gone_ok'] > 0) {
			$report .= "  Found " . $fsck_report['gone_ok'] . " missing files that are in a storage pool directory marked Temporarily-Gone.
  If this directory is gone for good, you should execute the following command, and remove the directory from your configuration file:
    greyhole --gone <path>
  where <path> is one of:\n";
	    	$report .= "    " . implode("\n    ", array_keys($gone_ok_drives)) . "\n\n";
		}
	}

	return $report;
}

function gh_recycle($real_path) {
	$is_symlink = FALSE;
	clearstatcache();
	if (is_link($real_path)) {
		$is_symlink = TRUE;
	} else if (!file_exists($real_path)) {
		return TRUE;
	}

	$should_move_to_attic = FALSE;
	if (!$is_symlink) {
		global $storage_pool_directories, $delete_moves_to_attic, $shares_options;
		
		$share_options = get_share_options_from_full_path($real_path);
		if ($share_options !== FALSE) {
			$full_path = trim($share_options['name'] . "/" . str_replace($share_options['landing_zone'], '', $real_path), '/');
			$share = $share_options['name'];
		} else {
			foreach ($storage_pool_directories as $dir) {
				if (strpos($real_path, $dir) === 0) {
					$attic_path = "$dir/.gh_attic";
					$full_path = trim(str_replace($dir, '', $real_path), '/');
					break;
				}
			}

			$share = substr($full_path, 0, strpos($full_path, '/'));

			if (isset($shares_options[$share]['delete_moves_to_attic'])) {
				$should_move_to_attic = $shares_options[$share]['delete_moves_to_attic'];
			} else {
				$should_move_to_attic = $delete_moves_to_attic;
			}
		}
	}
	
	if ($should_move_to_attic) {
		// Move to attic
		if (!isset($attic_path)) {
			gh_log(WARN, "  Warning! Can't find attic for $real_path. Won't delete this file!");
			return FALSE;
		}
		
		$target_path = clean_dir("$attic_path/$full_path");

		list($path, $filename) = explode_full_path($target_path);
		
		list($original_path, $filename) = explode_full_path(get_share_landing_zone($share) . "/$full_path");
		
		if (@is_file($path)) {
			unlink($path);
		}
		
		$dir_infos = (object) array(
			'fileowner' => 0,
			'filegroup' => 0,
			'fileperms' => (int) base_convert("0777", 8, 10)
		);
		gh_mkdir($path, $dir_infos);

		if (@is_dir($target_path)) {
			exec("rm -rf " . quoted_form($target_path));
		}
		if (@rename($real_path, $target_path)) {
			gh_log(DEBUG, "  Moved copy from $real_path to attic: $target_path");
			
			// Create a symlink in the Greyhole Attic share, to allow the user to remove this file using that share
			create_attic_share_symlink($target_path, $attic_path);
			return TRUE;
		}
	} else {
		if (@unlink($real_path)) {
			if (!$is_symlink) {
				gh_log(DEBUG, "  Deleted copy at $real_path");
			}
			return TRUE;
		}
	}
	return FALSE;
}

function repair_tables() {
	if (@$db_use_mysql) {
		db_query("REPAIR TABLE tasks") or gh_log(CRITICAL, "Can't repair tasks table: " . db_error());
		db_query("REPAIR TABLE tasks_completed") or gh_log(CRITICAL, "Can't repair tasks_completed table: " . db_error());
		db_query("REPAIR TABLE settings") or gh_log(CRITICAL, "Can't repair settings table: " . db_error());
	}
}

function check_storage_pool_dirs() {
	global $storage_pool_directories, $email_to, $gone_ok_drives;
	$hostname = exec('hostname');
	$needs_fsck = FALSE;
	$i = 0; $j = 0;
	foreach ($storage_pool_directories as $target_drive) {
		if (!is_greyhole_owned_dir($target_drive) && !gone_fscked($target_drive, $i++ == 0)) {
			$needs_fsck = 1;
			mark_gone_drive_fscked($target_drive);
			gh_log(WARN, "Warning! It seems $target_drive is missing it's \".greyhole_uses_this\" file. This either means this mount is currently unmounted, or you forgot to create this file.");
			$body = "This is an automated email from Greyhole.

It appears one of your storage pool directory is missing it's \".greyhole_uses_this\" file:
  $target_drive/.greyhole_uses_this: File not found

This either means this mount is currently unmounted, or you forgot to create this file.

Here are your options:

- If you forgot to create this file, you should create it ASAP, as per the INSTALL instructions. Until you do, this directory will not be part of your storage pool.

- If the mount is gone, you should either re-mount it manually (if possible), or remove it from your configuration file, if you know it is gone for good.

- If you know this mount will come back soon, and do NOT want Greyhole to re-create missing file copies for this directory until it reappears, you should execute this command:
  greyhole --wait-for ".quoted_form($target_drive)."

A fsck will now start, to fix the symlinks found in your shares, when possible.
You'll receive a report email once that fsck run completes.
";
			mail($email_to, 'Missing storage pool directory on ' . $hostname . ': ' . $target_drive, $body);
			gh_log(DEBUG, "Email sent for gone dir: $target_drive");
			$gone_ok_drives[$target_drive] = TRUE; // The upcoming fsck should not recreate missing copies just yet
		} else if ((gone_ok($target_drive, $j++ == 0) || gone_fscked($target_drive, $i++ == 0)) && is_greyhole_owned_dir($target_drive)) {
			// $target_drive is now back
			$needs_fsck = 2;
			$body = "This is an automated email from Greyhole.

It appears one of your storage pool directory came back:
  $target_drive was missing; it's now available again.

A fsck will now start, to fix the symlinks found in your shares, when possible.
You'll receive a report email once that fsck run completes.
";
			mail($email_to, 'Storage pool directory now online on ' . $hostname . ': ' . $target_drive, $body);
			gh_log(DEBUG, "Email sent for revived dir: $target_drive");

			mark_gone_ok($target_drive, 'remove');
			mark_gone_drive_fscked($target_drive, 'remove');
			$i = 0; $j = 0;
		}
	}
	
	if ($needs_fsck !== FALSE) {
		set_graveyard_backup();
		get_graveyards(FALSE); // FALSE => Resets the graveyards cache
		global $shares_options;
		if ($needs_fsck === 1) {
			gh_log(INFO, "Starting fsck for all shares - caused by missing drive. Will just recreate symlinks to existing copies when possible; won't create new copies just yet.");
		} else {
			gh_log(INFO, "Starting fsck for all shares - caused by missing drive that came back online.");
		}
		initialize_fsck_report('All shares');
		clearstatcache();

		foreach ($shares_options as $share_name => $share_options) {
			gh_fsck($share_options['landing_zone'], $share_name);
		}
		gh_log(INFO, "fsck for all shares completed.");

		$fsck_report = get_fsck_report();
		gh_log(DEBUG, "Sending fsck report to $email_to");
		mail($email_to, 'fsck of Greyhole shares on ' . $hostname, $fsck_report);

		// Refresh $gone_ok_drives to it's real value (from the DB)
		get_gone_ok_dirs();
	}
}

// Is it OK for a drive to be gone?
function gone_ok($target_drive, $refresh=FALSE) {
	global $gone_ok_drives;
	if ($refresh || !isset($gone_ok_drives)) {
		$gone_ok_drives = get_gone_ok_dirs();
	}
	if (isset($gone_ok_drives[$target_drive])) {
		return TRUE;
	}
	return FALSE;
}

function get_gone_ok_dirs() {
	global $gone_ok_drives;
	$query = "SELECT value FROM settings WHERE name = 'Gone-OK-Drives'";
	$result = db_query($query) or gh_log(CRITICAL, "Can't query settings for Gone-OK-Drives: " . db_error());
	$row = db_fetch_object($result);
	if ($row !== FALSE) {
		$gone_ok_drives = unserialize($row->value);
	} else {
		$query = "INSERT INTO settings (name, value) VALUES ('Gone-OK-Drives', 'a:0:{}')";
		db_query($query) or gh_log(CRITICAL, "Can't insert new settings for Gone-OK-Drives: " . db_error());
		$gone_ok_drives = array();
	}
	return $gone_ok_drives;
}

function mark_gone_ok($target_drive, $action='add') {
	global $storage_pool_directories;
	if (!array_search($target_drive, $storage_pool_directories)) {
		return FALSE;
	}

	global $gone_ok_drives;
	$gone_ok_drives = get_gone_ok_dirs();
	if ($action == 'add') {
		$gone_ok_drives[$target_drive] = TRUE;
	} else {
		unset($gone_ok_drives[$target_drive]);
	}

	$query = sprintf("UPDATE settings SET value = '%s' WHERE name = 'Gone-OK-Drives'",
		db_escape_string(serialize($gone_ok_drives))
	);
	db_query($query) or gh_log(CRITICAL, "Can't save settings for Gone-OK-Drives: " . db_error());
	return TRUE;
}

function gone_fscked($target_drive, $refresh=FALSE) {
	global $fscked_gone_drives;
	if ($refresh || !isset($fscked_gone_drives)) {
		$fscked_gone_drives = get_fsck_gone_drives();
	}
	if (isset($fscked_gone_drives[$target_drive])) {
		return TRUE;
	}
	return FALSE;
}

function get_fsck_gone_drives() {
	global $fscked_gone_drives;
	$query = "SELECT value FROM settings WHERE name = 'Gone-FSCKed-Drives'";
	$result = db_query($query) or gh_log(CRITICAL, "Can't query settings for Gone-FSCKed-Drives: " . db_error());
	$row = db_fetch_object($result);
	if ($row !== FALSE) {
		$fscked_gone_drives = unserialize($row->value);
	} else {
		$query = "INSERT INTO settings (name, value) VALUES ('Gone-FSCKed-Drives', 'a:0:{}')";
		db_query($query) or gh_log(CRITICAL, "Can't insert new settings for Gone-FSCKed-Drives: " . db_error());
		$fscked_gone_drives = array();
	}
	return $fscked_gone_drives;
}

function mark_gone_drive_fscked($target_drive, $action='add') {
	global $fscked_gone_drives;
	$fscked_gone_drives = get_fsck_gone_drives();
	if ($action == 'add') {
		$fscked_gone_drives[$target_drive] = TRUE;
	} else {
		unset($fscked_gone_drives[$target_drive]);
	}

	$query = sprintf("UPDATE settings SET value = '%s' WHERE name = 'Gone-FSCKed-Drives'",
		db_escape_string(serialize($fscked_gone_drives))
	);
	db_query($query) or gh_log(CRITICAL, "Can't save settings for Gone-FSCKed-Drives: " . db_error());
}

function get_graveyards($use_cache=TRUE) {
	global $storage_pool_directories, $graveyard_backup_directories, $global_graveyards;
	if (!isset($global_graveyards) || !$use_cache) {
		$graveyards = array();
		foreach ($storage_pool_directories as $target_drive) {
			if (is_greyhole_owned_dir($target_drive)) {
				$graveyards[] = "$target_drive/.gh_graveyard";
			}
		}
		foreach ($graveyard_backup_directories as $graveyard_backup_directory) {
			if (is_greyhole_owned_dir(str_replace('/.gh_graveyard_backup', '', $graveyard_backup_directory))) {
				$graveyards[] = $graveyard_backup_directory;
			}
		}
		$global_graveyards = $graveyards;
	}
	return $global_graveyards;
}

function get_share_options_from_full_path($full_path) {
	global $shares_options;
	$landing_zone = '';
	$share = FALSE;
	foreach ($shares_options as $share_name => $share_options) {
		if (strpos($full_path, $share_options['landing_zone']) === 0 && strlen($share_options['landing_zone']) > strlen($landing_zone)) {
			$landing_zone = $share_options['landing_zone'];
			$share = $share_options;
		}
	}
	return $share;
}

function gh_get_file_infos($real_path) {
	if ($real_path == null || !file_exists($real_path)) {
		return (object) array(
			'fileowner' => 0,
			'filegroup' => 0,
			'fileperms' => (int) base_convert("0777", 8, 10)
		);
	}
	return (object) array(
		'fileowner' => (int) gh_fileowner($real_path),
		'filegroup' => (int) gh_filegroup($real_path),
		'fileperms' => (int) base_convert(gh_fileperms($real_path), 8, 10)
	);
}

function gh_get_dir_perms($directory) {
	return (int) base_convert(gh_fileperms($directory), 8, 10);
}

function gh_balance() {
	global $storage_pool_directories, $shares_options, $is_sticky;

	// Start with shares that have sticky files, so that subsequent shares will be used to try to balance what moving files into stick_into drives could debalance...
	// Then start with the shares for which we keep the most # copies;
	// That way, if the new drive fails soon, it won't take with it files for which we only have one copy!
	$sorted_shares_options = $shares_options;
	uasort($sorted_shares_options, 'compare_share_balance');
	foreach ($sorted_shares_options as $share_name => $share_options) {
		if ($share_options['num_copies'] == count($storage_pool_directories)) {
			// Files are everywhere; won't be able to use that share to balance available space!
			continue;
		}

 		gh_log(DEBUG, "Balancing share: $share_name");

		// Move files from the drive with the less available space to the drive with the most available space.
		$sorted_pool_drives = sort_storage_dirs_available_space();
		$pool_drives_avail_space = array();
		foreach ($sorted_pool_drives as $available_space => $drive) {
			$pool_drives_avail_space[$drive] = $available_space;
		}

		foreach ($sorted_pool_drives as $source_drive) {
			$target_avail_space = array_sum($pool_drives_avail_space) / count($pool_drives_avail_space);
			gh_log(DEBUG, "Balancing storage pool directory: $source_drive (". bytes_to_human($pool_drives_avail_space[$source_drive]*1024, FALSE) ." available, target: ". bytes_to_human($target_avail_space*1024, FALSE) .")");

			// Files candidate to get moved
			unset($files);
			exec("find ". quoted_form("$source_drive/$share_name") ." -type f -size +10M | head -n 100000", $files);
			gh_log(DEBUG, "Found ". count($files) ." files that can be moved.");
			
			// Repeat until all drives' available space is balanced.
			$file_everywhere_counter = 0;
			foreach ($files as $file) {
				// Let's not try to move locked files!
				if (real_file_is_locked($file) !== FALSE) {
					gh_log(DEBUG, "  File $file is locked by another process. Skipping.");
					continue;
				}

				$filesize = gh_filesize($file)/1024; // KB

				$full_path = substr($file, strlen("$source_drive/$share_name/"));
				list($path, $filename) = explode_full_path($full_path);
				gh_log(DEBUG, "  Working on file: $full_path (". bytes_to_human($filesize*1024, FALSE) .")");

				$target_drives = order_target_drives($filesize, FALSE, $share_name, $path, '  ');

				unset($target_drive);
				if ($is_sticky) {
					$sticky_drives = array_slice($target_drives, 0, get_num_copies($share_name));
					if (array_search($source_drive, $sticky_drives)) {
						// Source drive is a stick_into drive; let's not move that file!
						gh_log(DEBUG, "  Source is sticky. Skipping.");
						continue;
					}
					$already_stuck_copies = 0;
					foreach ($sticky_drives as $drive) {
						if (file_exists("$drive/$share_name/$full_path")) {
							$already_stuck_copies++;
						} else {
							$target_drive = $drive;
						}
					}
				} else {
					while (count($target_drives) > 0) {
						$drive = array_shift($target_drives);
						if (!file_exists("$drive/$share_name/$full_path")) {
							$target_drive = $drive;
							break;
						}
					}
				}
				
				if (!isset($target_drive)) {
					// Can't find a drive that doesn't have this file; skipping.
					if ($is_sticky) {
						gh_log(DEBUG, "  Sticky file is already where it should be. Skipping.");
					}
					continue;
				}

				gh_log(DEBUG, "  Target drive: $target_drive (". bytes_to_human($pool_drives_avail_space[$target_drive]*1024, FALSE) ." available)");

				if ($is_sticky) {
					gh_log(DEBUG, "  Moving sticky file, even if it won't help balancing available space.");
				} else if ($pool_drives_avail_space[$source_drive]+$filesize+1*1024*1024 /*1GB*/ > $pool_drives_avail_space[$target_drive]-$filesize
						|| $pool_drives_avail_space[$source_drive]+$filesize > $target_avail_space
						|| $pool_drives_avail_space[$target_drive] < $target_avail_space) {
					gh_log(DEBUG, "  Moving this file wouldn't help balancing available space. Skipping.");
					continue;
				}

				// Make sure the parent directory exists, before we try moving something there...
				$original_path = clean_dir("$source_drive/$share_name/$path");
				list($target_path, $filename) = explode_full_path("$target_drive/$share_name/$full_path");
				gh_mkdir($target_path, $original_path);

				// Move the file
				$temp_path = get_temp_filename("$target_drive/$share_name/$full_path");
				$file_infos = gh_get_file_infos($file);
				gh_log(DEBUG, "  Moving file copy...");
				$it_worked = rename($file, $temp_path);
				if ($it_worked) {
					rename($temp_path, "$target_drive/$share_name/$full_path");
					gh_chperm("$target_drive/$share_name/$full_path", $file_infos);

					$pool_drives_avail_space[$target_drive] -= $filesize;
					$pool_drives_avail_space[$source_drive] += $filesize;
				} else {
					gh_log(WARN, "    Failed file copy. Skipping.");
					gh_recycle($temp_path);
					continue;
				}

				// Update tombstones
				$existing_tombstones = get_tombstones($share_name, $path, $filename, FALSE, TRUE, FALSE);
				foreach ($existing_tombstones as $key => $tombstone) {
					if ($tombstone->path == $file) {
						$tombstone->path = "$target_drive/$share_name/$full_path";
						unset($existing_tombstones[$key]);
						$tombstone->state = 'OK';
						if ($tombstone->is_linked) {
							// Re-create correct symlink
							$landing_zone = $share_options['landing_zone'];
							if (is_link("$landing_zone/$full_path")) {
								gh_log(DEBUG, "  Updating symlink at $landing_zone/$full_path to point to $tombstone->path");
								if (gh_recycle("$landing_zone/$full_path")) {
			 						@symlink($tombstone->path, "$landing_zone/$full_path");
									// Creating this symlink can fail if the parent dir was removed
								}
							}
						}
						$existing_tombstones[$tombstone->path] = $tombstone;
						save_tombstones($share_name, $path, $filename, $existing_tombstones);
						break;
					}
				}
				
				$target_avail_space = array_sum($pool_drives_avail_space) / count($pool_drives_avail_space);
				gh_log(DEBUG, "Balancing storage pool directory: $source_drive (". bytes_to_human($pool_drives_avail_space[$source_drive]*1024, FALSE) ." available, target: ". bytes_to_human($target_avail_space*1024, FALSE) .")");
			}
			gh_log(DEBUG, "Done balancing storage pool directory: $source_drive (". bytes_to_human($pool_drives_avail_space[$source_drive]*1024, FALSE) ." available)");
		}
		gh_log(DEBUG, "Done balancing share: $share_name");
	}
}

function is_share_sticky($share_name) {
	global $sticky_files;
	if (isset($sticky_files)) {
		foreach ($sticky_files as $share_dir => $stick_into) {
			if (strpos($share_dir, $share_name) === 0) {
				return TRUE;
			}
		}
	}
	return FALSE;
}

function compare_share_balance($a, $b) {
	if (is_share_sticky($a['name']) && !is_share_sticky($b['name'])) {
		return -1;
	}
	if (!is_share_sticky($a['name']) && is_share_sticky($b['name'])) {
		return 1;
	}
	if ($a['num_copies'] != $b['num_copies']) {
		return $a['num_copies'] > $b['num_copies'] ? -1 : 1;
	}
	return strcasecmp($a['name'], $b['name']);
}

function sort_storage_dirs_available_space() {
	global $storage_pool_directories, $minimum_free_space_pool_directories;
	$dfs = get_free_space_in_storage_pool_dirs();
	foreach ($storage_pool_directories as $target_drive) {
		if (!isset($dfs[$target_drive])) {
			continue;
		}
		$free_space = $dfs[$target_drive];
		$minimum_free_space = (float) (isset($minimum_free_space_pool_directories[$target_drive]) ? $minimum_free_space_pool_directories[$target_drive]*1024*1024 : 0.0);
		$available_space = (float) $free_space - $minimum_free_space;
		$sorted_target_drives[$available_space] = $target_drive;
	}
	ksort($sorted_target_drives);
	return $sorted_target_drives;
}

function postpone_task($task_id, $complete='yes') {
	global $sleep_before_task;
	$query = sprintf("INSERT INTO tasks (action, share, full_path, additional_info, complete) SELECT action, share, full_path, additional_info, '%s' FROM tasks WHERE id = %d",
		db_escape_string($complete),
		$task_id
	);
	db_query($query) or gh_log(CRITICAL, "Error inserting postponed task: " . db_error());
	$sleep_before_task[] = db_insert_id();
}

// If running on Amahi, loop until the config works.
// User might configure Greyhole later, and they don't want to show Greyhole 'offline' until then. Users are easy to confused! ;)
function process_config() {
	global $action;
	while (!parse_config()) {
		// Sleep for a while, if running on Amahi.
		if (file_exists('/usr/bin/hdactl') && $action == 'daemon') {
			sleep(600); // 10 minutes
		} else {
			// Otherwise, die.
			gh_log(CRITICAL, "Config file parsing failed. Exiting.");
		}
	}
	// Config is OK; go on!
}

function gh_wild_strpos($haystack, $needle) { 
	$is_wild = (strpos($needle, "*") !== FALSE);
	if (!$is_wild) {
		return strpos($haystack, $needle);
	}
	if (str_replace('*', '', $needle) == $haystack) {
		return FALSE;
	}
	$needles = explode("*", $needle);
	if ($needle[0] == '*') {
		$first_index = 0;
	}
	foreach ($needles as $needle_part) {
		if ($needle_part == '') {
			continue;
		}
		$needle_index = strpos($haystack, $needle_part);
		if (!isset($first_index)) {
			$first_index = $needle_index;
		}
		if ($needle_index === FALSE) {
			return FALSE;
		} else {
			$found = TRUE;
			$haystack = substr($haystack, $needle_index + strlen($needle_part));
		}
	}
	if ($found) {
		return $first_index;
	}
	return FALSE;
}

function str_replace_first($search, $replace, $subject) {
	$firstChar = strpos($subject, $search);
	if ($firstChar !== FALSE) {
		$beforeStr = substr($subject, 0, $firstChar);
		$afterStr = substr($subject, $firstChar + strlen($search));
		return $beforeStr . $replace . $afterStr;
	} else {
		return $subject;
	}
}

function set_graveyard_backup() {
	global $graveyard_backup_directories, $storage_pool_directories;

	$num_graveyard_backups_needed = 2;
	if (count($storage_pool_directories) < 2) {
		$graveyard_backup_directories = array();
		return;
	}

	gh_log(DEBUG, "Loading graveyard backup directories...");
	if (empty($graveyard_backup_directories)) {
		// In the DB ?
		$query = sprintf("SELECT value FROM settings WHERE name = '%s'", 'graveyard_backup_directory');
		$result = db_query($query) or gh_log(CRITICAL, "Can't query settings for 'graveyard_backup_directory': " . db_error());
		$row = db_fetch_object($result);
		db_free_result($result);
		if ($row !== FALSE) {
			$graveyard_backup_directories = unserialize($row->value);
			gh_log(DEBUG, "  Found " . count($graveyard_backup_directories) . " directories in the settings table.");
		}
	}

	// Verify the directories, if any
	if (!empty($graveyard_backup_directories)) {
		foreach ($graveyard_backup_directories as $key => $graveyard_backup_directory) {
			if (!is_greyhole_owned_dir(str_replace('/.gh_graveyard_backup', '', $graveyard_backup_directory))) {
				// Directory is now invalid; stop using it.
				gh_log(DEBUG, "Removing $graveyard_backup_directory from available 'graveyard_backup_directories' - directory isn't a greyhole storage pool directory (anymore?)");
				unset($graveyard_backup_directories[$key]);
			} else if (!is_dir($graveyard_backup_directory)) {
				// Directory is invalid, but needs to be created (was rm'ed?)
				mkdir($graveyard_backup_directory);
			}
		}
	}
	
	if (empty($graveyard_backup_directories) || count($graveyard_backup_directories) < $num_graveyard_backups_needed) {
		gh_log(DEBUG, "  Missing some directories. Need $num_graveyard_backups_needed, currently have " . count($graveyard_backup_directories) . ". Will select more...");
		$graveyard_backup_directories_hash = array();
		if (count($graveyard_backup_directories) > 0) {
			$graveyard_backup_directories_hash[array_shift($graveyard_backup_directories)] = TRUE;
		}

		while (count($graveyard_backup_directories_hash) < $num_graveyard_backups_needed) {
			// Let's pick new one
			$graveyard_backup_directory = clean_dir($storage_pool_directories[array_rand($storage_pool_directories)] . '/.gh_graveyard_backup');
			$graveyard_backup_directories_hash[$graveyard_backup_directory] = TRUE;
			if (!is_dir($graveyard_backup_directory)) {
				mkdir($graveyard_backup_directory);
			}
			gh_log(DEBUG, "    Randomly picked $graveyard_backup_directory");
		}
		$graveyard_backup_directories = array_keys($graveyard_backup_directories_hash);

		// Got 2 directories now; save them in the DB
		$query = "DELETE FROM settings WHERE name = 'graveyard_backup_directory'";
		db_query($query) or gh_log(CRITICAL, "Can't delete settings for graveyard_backup_directory: " . db_error());
		$query = sprintf("INSERT INTO settings (name, value) VALUES ('graveyard_backup_directory', '%s')",
			db_escape_string(serialize($graveyard_backup_directories))
		);
		db_query($query) or gh_log(CRITICAL, "Can't insert new settings for graveyard_backup_directory: " . db_error());
	}
}

function create_attic_share_symlink($filepath_in_attic, $attic_path) {
	global $attic_share;
	if (isset($attic_share)) {
		$filepath_in_attic = clean_dir($filepath_in_attic);
		$filepath_in_attic_share = str_replace($attic_path, $attic_share['landing_zone'], $filepath_in_attic);
		if (file_exists($filepath_in_attic_share)) {
			$new_filepath = $filepath_in_attic_share;
			$i = 1;
			while (file_exists($new_filepath)) {
				if (@readlink($new_filepath) == $filepath_in_attic) {
					// There's already a symlink to that file in the attic share; let's not make a second one!
					return;
				}
				$new_filepath = "$filepath_in_attic_share copy $i";
				$i++;
			}
			$filepath_in_attic_share = $new_filepath;
			list($original_path, $filename) = explode_full_path($filepath_in_attic_share);
		} else {
			list($original_path, $filename) = explode_full_path($filepath_in_attic);
			list($path, $filename) = explode_full_path($filepath_in_attic_share);

			$dir_infos = (object) array(
				'fileowner' => (int) gh_fileowner($original_path),
				'filegroup' => (int) gh_filegroup($original_path),
				'fileperms' => (int) base_convert("0777", 8, 10)
			);
			gh_mkdir($path, $dir_infos);
		}
		symlink($filepath_in_attic, $filepath_in_attic_share);
		gh_log(DEBUG, "  Created symlink to deleted file in {$attic_share['name']} share ($filename).");
	}
}
?>
