#!/usr/bin/php
<?php
/*
Copyright 2009 Guillaume Boudreau

This file is part of Greyhole.

Greyhole is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Greyhole is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Greyhole.  If not, see <http://www.gnu.org/licenses/>.
*/

include('includes/common.php');
include('includes/sql.php');
parse_config();

db_connect() or gh_log(CRITICAL, "Can't connect $db_options->engine to database.");
db_select_db();
db_migrate();

if (@$db_use_mysql) {
	db_query("SET SESSION group_concat_max_len = 1048576");
}

$action = 'unknown';
$options = array();
for ($i=1; $i<$argc; $i++) {
	switch ($argv[$i]) {
		case '--daemon':
		case '--fsck':
		case '--balance':
		case '--prerotate':
		case '--postrotate':
		case '--stats':
		case '--empty-attic':
		$action = substr($argv[$i], 2);
		break;

		case '--email-report':
		case '--disk-usage-report':
		$options[substr($argv[$i], 2)] = TRUE;
		break;
		
		case '--wait-for':
		case '--gone':
		case '--going':
		case '--thaw':
		$action = substr($argv[$i], 2);
		// Fall through --dir to fetch the path to the Gone/Gone-But-OK drive

		case '--dir':
		if (isset($argv[$i+1])) {
			$options['dir'] = $argv[$i+1];
		}
		$i++;
		break;

		case '--debug':
		$action = 'debug';
		if (isset($argv[$i+1])) {
			$options['debug_filename'] = $argv[$i+1];
			$i++;
		}
		break;
		
		default:
		print_usage();
	}
}

if ($action == 'unknown') {
	print_usage();
}

function print_usage() {
	echo "Invalid command line options.\n";
	echo "Usage: Start the daemon:         greyhole --daemon\n";
	echo "       Schedule a fsck:          greyhole --fsck [--email-report] [--dir <path>] [--disk-usage-report]\n";
	echo "       Balance available space \n";
	echo "        on storage pool devices: greyhole --balance\n";
	echo "       Display statistics:       greyhole --stats\n";
	echo "       Empty attic:              greyhole --empty-attic\n";
	echo "       Debug file operations:    greyhole --debug <filename>\n";
	echo "\n";
	echo "       List frozen directories:  greyhole --thaw\n";
	echo "       Thaw a frozen directory:  greyhole --thaw <share/directory>\n";
	echo "\n";
	echo "       Pre-rotate task:          greyhole --prerotate\n";
	echo "       Post-rotate task:         greyhole --postrotate\n";
	echo "\n";
	echo "     When <path>, one of your storage pool directories, is/will become unavailable:\n";
	echo "       <path> will return soon:      greyhole --wait-for <path>\n";
	echo "       <path> is gone for good:      greyhole --gone <path>\n";
	echo "       <path> will be gone for good: greyhole --going <path>\n";
	exit(1);
}

if ($action != 'stats' && $action != 'debug') {
	if (exec("whoami") != 'root') {
		echo "You need to execute this as root.\n";
		exit(1);
	}
}

if ($action == 'thaw') {
	if (!isset($options['dir'])) {
		echo "Frozen directories:\n";
		foreach ($frozen_directories as $frozen_directory) {
			echo "  $frozen_directory\n";
		}
		echo "To thaw any of the above directories, use the following command:\n";
		echo "greyhole --thaw <directory>\n";
		exit(0);
	}
	$path = explode('/', $options['dir']);
	$share = array_shift($path);
	$query = sprintf("UPDATE tasks SET complete = 'thawed' WHERE complete = 'frozen' AND share = '%s' AND full_path LIKE '%s%%'",
		db_escape_string($share),
		db_escape_string(implode('/', $path))
	);
	db_query($query) or die("Can't thaw tasks with query: $query - Error: " . db_error());
	echo $options['dir'] . " directory has been thawed.\n";
	echo "All pasts file operations that occured in this directory will now be processed by Greyhole.\n";
	exit(0);
}

if ($action == 'gone' || $action == 'going') {
	global $storage_pool_directories;
	if (!array_search($options['dir'], $storage_pool_directories)) {
		echo "Directory " . $options['dir'] . " is not one of your defined storage pool directories.\n";
		echo "Please use one of the following with the --$action option:\n  ";
		echo implode("\n  ", $storage_pool_directories) . "\n";
		exit(1);
	}

	if ($action == 'going') {
		gh_log(INFO, "Storage pool directory " . $options['dir'] . " will be removed from the storage pool.");
		echo("Storage pool directory " . $options['dir'] . " will be removed from the storage pool.\n");

		// global $going_dir; // Used in function is_greyhole_owned_dir()
		$going_dir = $options['dir'];

		// fsck shares with only 1 file copy to remove those from $options['dir']
		initialize_fsck_report('Shares with only 1 copy');
		foreach ($shares_options as $share_name => $share_options) {
			if ($share_options['num_copies'] == 1) {
				echo "Moving file copies for share '$share_name'... Please be patient... ";
				gh_fsck($share_options['landing_zone'], $share_name);
				echo "Done.\n";
			}
		}

		unlink("$going_dir/.greyhole_uses_this");

		// Remove $options['dir'] from config file and restart (if it was running)
		$escaped_dir = str_replace('/', '\/', $going_dir);
		exec("/bin/sed --in-place -e 's/^.*storage_pool_directory.*$escaped_dir.*$//' /etc/greyhole.conf");
		exec("/sbin/service greyhole condrestart");
		
		// Schedule fsck for all shares to re-create missing copies on other shares
		db_query("INSERT INTO tasks (action, share, additional_info, complete) VALUES ('fsck', '', NULL, 'yes')") or gh_log(CRITICAL, "Can't insert fsck task: " . db_error());
		echo "All the files that were only on $going_dir have been copied somewhere else.\n";
		echo "A fsck of all shares has been scheduled, to recreate other file copies. It will start after all currently pending tasks have been completed.\n";
	}

	mark_gone_ok($options['dir'], 'remove');
	mark_gone_drive_fscked($options['dir'], 'remove');
	gh_log(INFO, "Storage pool directory " . $options['dir'] . " has been marked Gone");
	echo "Storage pool directory " . $options['dir'] . " has been marked Gone, which means the missing file copies that are in this directory will be re-created during the next fsck.\n";
	exit(0);
}

if ($action == 'debug') {
	if (!isset($options['debug_filename'])) {
		print_usage();
	}
	$filename = $options['debug_filename'];
	
	if (strpos($filename, '/') === FALSE) {
		$filename = "/$filename";
	}

	echo "Debugging file operations for file named \"$filename\"\n";

	echo "\nFrom DB\n=======\n";
	$debug_tasks = array();
	$query = sprintf("SELECT id, action, share, full_path, additional_info, event_date FROM tasks_completed WHERE full_path LIKE '%%%s%%' ORDER BY id ASC",
		db_escape_string($filename)
	);
	$result = db_query($query) or die("Can't query tasks_completed with query: $query - Error: " . db_error());
	while ($row = db_fetch_object($result)) {
		$debug_tasks[$row->id] = $row;
	}

	// Renames
	$query = sprintf("SELECT id, action, share, full_path, additional_info, event_date FROM tasks_completed WHERE additional_info LIKE '%%%s%%' ORDER BY id ASC",
		db_escape_string($filename)
	);
	while (TRUE) {
		$result = db_query($query) or die("Can't query tasks_completed for renames with query: $query - Error: " . db_error());
		while ($row = db_fetch_object($result)) {
			$debug_tasks[$row->id] = $row;
			$query = sprintf("SELECT id, action, share, full_path, additional_info, event_date FROM tasks_completed WHERE additional_info = '%s' ORDER BY id ASC",
				db_escape_string($row->full_path)
			);
		}

		# Is there more?
		$new_query = preg_replace('/SELECT .* FROM/i', 'SELECT COUNT(*) FROM', $query);
		$result = db_query($new_query) or die("Can't query tasks_completed for COUNT of renames with query: $new_query - Error: " . db_error());
		if (db_fetch_object($result) !== FALSE) {
			break;
		}
	}
	
	ksort($debug_tasks);
	$to_grep = array();
	foreach ($debug_tasks as $task) {
		echo "  [$task->event_date] Task ID $task->id: $task->action $task->share/$task->full_path" . ($task->action == 'rename' ? " -> $task->share/$task->additional_info" : '') . "\n";
		$to_grep["$task->share/$task->full_path"] = 1;
		if ($task->action == 'rename') {
			$to_grep["$task->share/$task->additional_info"] = 1;
		}
	}
	if (empty($to_grep)) {
		$to_grep[$filename] = 1;
		if (strpos($filename, '/') !== FALSE) {
			$share = trim(substr($filename, 0, strpos(substr($filename, 1), '/')+1), '/');
			$full_path = trim(substr($filename, strpos(substr($filename, 1), '/')+1), '/');
			$debug_tasks[] = (object) array('share' => $share, 'full_path' => $full_path);
		}
	}

	echo "\nFrom logs\n=========\n";
	$to_grep = array_keys($to_grep);
	$to_grep = implode("|", $to_grep);
	$commands = array();
	$commands[] = "zgrep -E -B 1 -A 1 -h " . quoted_form($to_grep) . " /var/log/greyhole.log-*";
	$commands[] = "grep -E -B 1 -A 1 -h " . quoted_form($to_grep) . " /var/log/greyhole.log";
	foreach ($commands as $command) {
		exec($command, $result);
	}
	foreach ($result as $rline) {
		echo preg_replace('@^/var/log/greyhole.log[0-9\.gz-]*:@', '', $rline) . "\n";
	}
	
	echo "\nFrom filesystem\n===============\n";

	$last_task = array_pop($debug_tasks);
	$share = $last_task->share;
	if ($last_task->action == 'rename') {
		$full_path = $last_task->additional_info;
	} else {
		$full_path = $last_task->full_path;
	}
	list($path, $filename) = explode_full_path($full_path);
	echo "Landing Zone:\n";
	echo "  "; passthru("ls -l " . quoted_form(get_share_landing_zone($share) . "/" . $full_path));

	echo "\nGraveyard:\n";
	foreach ($storage_pool_directories as $target_drive) {
		$graveyard = clean_dir("$target_drive/.gh_graveyard");
		if (file_exists("$graveyard/$share/$full_path")) {
			echo "  "; passthru("ls -l " . quoted_form("$graveyard/$share/$full_path"));
			$data = var_export(unserialize(file_get_contents("$graveyard/$share/$full_path")), TRUE);
			$data = str_replace("\n", "\n    ", $data);
			echo "    $data\n";
		}
	}

	echo "\nFile copies:\n";
	foreach ($storage_pool_directories as $target_drive) {
		if (file_exists("$target_drive/$share/$full_path")) {
			echo "  "; passthru("ls -l " . quoted_form("$target_drive/$share/$full_path"));
		}
	}

	exit(0);
}

if ($action == 'empty-attic') {
	foreach ($storage_pool_directories as $target_drive) {
		$attic_path = clean_dir("$target_drive/.gh_attic");
		if (!file_exists($attic_path)) {
			echo "Attic in $target_drive is empty. Nothing to do.\n";
		} else {
			$attic_size = trim(exec("du -sk " . quoted_form($attic_path) . " | awk '{print $1}'"));
			echo "Attic in $target_drive is " . bytes_to_human($attic_size*1024, FALSE) . ". Emptying... ";
			exec("rm -rf " . quoted_form($attic_path));
			echo "Done\n";
		}
	}
	exit(0);
}

if ($action == 'stats') {
	echo "\nGreyhole Statistics\n===================\n\n";

	$max_drive_strlen = 0;
	foreach ($storage_pool_directories as $target_drive) {
		if (strlen($target_drive) > $max_drive_strlen) {
			$max_drive_strlen = strlen($target_drive);
		}
	}
	$max_drive_strlen++;

	$dfs = get_free_space_in_storage_pool_dirs();
	echo "Storage Pool\n";
	printf("%$max_drive_strlen"."s   Total -  Used =  Free + Attic = Possible\n", '');
	foreach ($storage_pool_directories as $target_drive) {
		printf("  %-$max_drive_strlen"."s ", "$target_drive:");
		if (!isset($dfs[$target_drive])) {
			echo "  N/A -   N/A =   N/A +   N/A =   N/A\n";
			continue;
		}

		$df_command = "df -k " . quoted_form($target_drive) . " | awk '{print \$(NF-4),\$(NF-3)}'";
		unset($responses);
		exec($df_command, $responses);
		$response = explode(' ', $responses[1]);
		$total_space = (float) array_shift($response);
		$used_space = (float) array_shift($response);

		$free_space = $dfs[$target_drive];

		$attic_path = clean_dir("$target_drive/.gh_attic");
		if (!file_exists($attic_path)) {
			$attic_size = 0;
		} else {
			$attic_size = trim(exec("du -sk " . quoted_form($attic_path) . " | awk '{print $1}'"));
		}

		$potential_available_space = (float) $free_space + $attic_size;

		echo sprintf('%4.0f', $total_space/1024/1024) . "G - " . sprintf('%4.0f', $used_space/1024/1024) . "G = " . sprintf('%4.0f', $free_space/1024/1024) . "G + " . sprintf('%4.0f', $attic_size/1024/1024) . "G = " . sprintf('%4.0f', $potential_available_space/1024/1024) . "G\n";
	}
	echo "\n";
	exit(0);
}

if ($action == 'wait-for') {
	if (!mark_gone_ok($options['dir'])) {
		echo "Directory " . $options['dir'] . " is not one of your defined storage pool directories.\n";
		echo "Please use one of the following with the --wait-for option:\n  ";
		echo implode("\n  ", $storage_pool_directories) . "\n";
		exit(1);
	}
	gh_log(INFO, "Storage pool directory " . $options['dir'] . " has been marked Temporarily-Gone");
	echo "Storage pool directory " . $options['dir'] . " has been marked Temporarily-Gone, which means the missing file copies that are in this directory will not be re-created until it reappears.\n";
	exit(0);
}

if ($action == 'prerotate') {
	parse_samba_log(FALSE);
	gh_log(INFO, "Samba log parsed using --prerotate");
	echo "Samba log parsed successfully. You can now rotate the log, then reset the read pointer using --postrotate\n";
	exit(0);
}

repair_tables();

if ($action == 'postrotate') {
	$query = sprintf("UPDATE settings SET value = '0' WHERE name = '%s'", 'last_read_log_smbd_line');
	db_query($query) or gh_log(CRITICAL, "Can't update settings for 'last_read_log_smbd_line': " . db_error());
	gh_log(INFO, "Samba log read pointer reset using --postrotate");
	echo "Samba log read pointer reset to 0.\n";
	exit(0);
}

if ($action == 'balance') {
	$query = "INSERT INTO tasks (action, share, complete) VALUES ('balance', '', 'yes')";
	db_query($query) or gh_log(CRITICAL, "Can't insert balance task: " . db_error());
	echo "A balance has been scheduled. It will start after all currently pending tasks have been completed.\n";
	echo "This operation will try to even the available space on all directories included in your storage pool.\n";
	exit(0);
}

if ($action == 'fsck') {
	$pos = array_search('fsck', $argv);
	$full_path = '';
	if (isset($options['dir'])) {
		$full_path = $options['dir'];
		if (!is_dir($full_path)) {
			echo "$full_path is not a directory. Exiting.\n";
			exit(1);
		}
	}
	$fsck_options = array();
	if (isset($options['email-report'])) {
		$fsck_options[] = 'email';
	}
	if (isset($options['disk-usage-report'])) {
		$fsck_options[] = 'du';
	}
	$query = sprintf("INSERT INTO tasks (action, share, additional_info, complete) VALUES ('fsck', '%s', %s, 'yes')",
		db_escape_string($full_path),
		(!empty($fsck_options) ? "'" . implode('|', $fsck_options) . "'" : "NULL")
	);
	db_query($query) or gh_log(CRITICAL, "Can't insert fsck task: " . db_error());
	if ($full_path == '') {
		$full_path = 'all shares';
	}
	echo "fsck of $full_path has been scheduled. It will start after all currently pending tasks have been completed.\n";
	exit(0);
}

gh_log(INFO, "Greyhole daemon started.");
parse_samba_log();
simplify_tasks();
while (TRUE) {
	parse_samba_log();
	$action = 'check_pool';
	check_storage_pool_dirs();
	execute_next_task();
}

function execute_next_task() {
	global $log_level, $fsck_report, $shares_options, $email_to, $sleep_before_task, $action, $frozen_directories;

	$query = "SELECT id, action, share, full_path, additional_info, complete FROM tasks WHERE complete IN ('yes', 'thawed') ORDER BY id ASC LIMIT 1";
	$result = db_query($query) or gh_log(CRITICAL, "Can't query tasks: " . db_error());
	$task = db_fetch_object($result);
	if ($task === FALSE) {
		$action = 'sleep';
		gh_log(DEBUG, "Nothing to do... Sleeping.");
		sleep($log_level == DEBUG ? 10 : 600);
		db_free_result($result);
		return;
	}
	db_free_result($result);

	# Postpone tasks in frozen directories until a --thaw command is received
	if ($task->complete != 'thawed') {
		foreach ($frozen_directories as $frozen_directory) {
			if (strpos("$task->share/$task->full_path", $frozen_directory) === 0) {
				$action = $task->action;
				gh_log(DEBUG, "Now working on task ID $task->id: $task->action $task->share/$task->full_path" . ($task->action == 'rename' ? " -> $task->share/$task->additional_info" : ''));
				gh_log(DEBUG, "  This directory is frozen. Will postpone this task until it is thawed.");
				postpone_task($task->id, 'frozen');
				archive_task($task->id);
				return;
			}
		}
	}
	
	if (($key = array_search($task->id, $sleep_before_task)) !== FALSE) {
		$action = 'sleep';
		gh_log(DEBUG, "Only locked files operations pending... Sleeping.");
		sleep($log_level == DEBUG ? 10 : 600);
		$sleep_before_task = array();
	}
	
	$action = $task->action;
	gh_log(DEBUG, "Now working on task ID $task->id: $task->action $task->share/$task->full_path" . ($task->action == 'rename' ? " -> $task->share/$task->additional_info" : ''));

	switch ($task->action) {
		case 'balance':
			gh_log(INFO, "Starting available space balancing");
			gh_balance();
			gh_log(INFO, "Available space balancing completed.");
			break;
		case 'fsck':
			gh_log(INFO, "Starting fsck for $task->share");
			initialize_fsck_report($task->share == '' ? 'All shares' : $task->share);
			if (strpos($task->additional_info, 'du') !== FALSE) {
				global $options;
				$options['disk-usage-report'] = TRUE;
			}
			clearstatcache();
			if ($task->share == '') {
				foreach ($shares_options as $share_name => $share_options) {
					gh_fsck($share_options['landing_zone'], $share_name);
				}
				foreach (get_graveyards() as $graveyard) {
					foreach ($shares_options as $share_name => $share_options) {
						gh_fsck_graveyard($graveyard, "/$share_name", $share_name);
					}
				}
			} else {
				$share_options = get_share_options_from_full_path($task->share);
				if ($share_options !== FALSE) {
					$share = $share_options['name'];
					gh_fsck($task->share, $share);
					$subdir = "/$share" . str_replace($share_options['landing_zone'], '', $task->share);
					gh_log(DEBUG, "Starting graveyards fsck for $subdir");
					foreach (get_graveyards() as $graveyard) {
						gh_fsck_graveyard($graveyard, $subdir, $share);
					}
				}
			}
			gh_log(INFO, "fsck for " . ($task->share == '' ? 'All shares' : $task->share) . " completed.");
			if (strpos($task->additional_info, 'email') !== FALSE) {
				// Email report for daily fsck
				$fsck_report = get_fsck_report();
				$hostname = exec('hostname');
				gh_log(DEBUG, "Sending fsck report to $email_to");
				mail($email_to, 'fsck of Greyhole shares on ' . $hostname, $fsck_report);
			}
			if (strpos($task->additional_info, 'du') !== FALSE) {
				// Save disk-usage report to disk
				$fp = fopen('/usr/local/greyhole/gh-disk-usage.log', 'w');
				if ($fp) {
					global $du;
					foreach ($du as $path => $size) {
						$chars_count = count_chars($path, 1);
						fwrite($fp, $chars_count[ord('/')] . " $path $size\n");
					}
					fwrite($fp, "# " . serialize($shares_options) . "\n");
					fclose($fp);
				}
			}
			break;
		case 'mkdir':
			break;
		case 'write':
			gh_write($task->share, $task->full_path, $task->id);
			break;
		case 'rename':
			gh_rename($task->share, $task->full_path, $task->additional_info, $task->id);
			break;
		case 'unlink':
			gh_unlink($task->share, $task->full_path, $task->id);
			break;
		case 'rmdir':
			gh_rmdir($task->share, $task->full_path);
			break;
	}
	if ($task->action != 'write' && $task->action != 'rename') {
		$sleep_before_task = array();
	}
	archive_task($task->id);
}

function archive_task($task_id) {
	$query = sprintf("INSERT INTO tasks_completed SELECT * FROM tasks WHERE id = %d", $task_id);
	db_query($query) or gh_log(CRITICAL, "Can't insert in tasks_completed: " . db_error());

	$query = sprintf("DELETE FROM tasks WHERE id = %d", $task_id);
	db_query($query) or gh_log(CRITICAL, "Can't delete from tasks: " . db_error());
}

function gh_rmdir($share, $full_path) {
	global $storage_pool_directories;
	$landing_zone = get_share_landing_zone($share);
	if (!$landing_zone) {
		return;
	}
	
	gh_log(INFO, "Directory deleted: $landing_zone/$full_path");
	foreach ($storage_pool_directories as $target_drive) {
		if (@rmdir("$target_drive/$share/$full_path/")) {
			gh_log(DEBUG, "  Removed copy at $target_drive/$share/$full_path");
		}
		$graveyard = "$target_drive/.gh_graveyard";
		if (@rmdir("$graveyard/$share/$full_path/")) {
			gh_log(DEBUG, "  Removed tombstones directory $graveyard/$share/$full_path");
		}
	}
}

function gh_unlink($share, $full_path, $task_id) {
	$landing_zone = get_share_landing_zone($share);
	if (!$landing_zone) {
		return;
	}
	
	gh_log(INFO, "File deleted: $landing_zone/$full_path");

	if (gh_file_exists("$landing_zone/$full_path")) {
		gh_log(DEBUG, "  File still exists in landing zone; a new file replaced the one deleted here. Skipping.");
		return;
	}

	list($path, $filename) = explode_full_path($full_path);

	$existing_tombstones = get_tombstones($share, $path, $filename, TRUE);
	foreach ($existing_tombstones as $tombstone) {
		gh_recycle($tombstone->path);
	}
	remove_tombstones($share, $path, $filename);
}

function is_a_graveyard_dir($share, $full_path) {
	foreach (get_graveyards() as $graveyard) {
		if (is_dir("$graveyard/$share/$full_path")) {
			return TRUE;
		}
	}
	return FALSE;
}

function gh_rename($share, $full_path, $target_full_path, $task_id) {
	global $storage_pool_directories, $log_level, $sleep_before_task;
	$landing_zone = get_share_landing_zone($share);
	if (!$landing_zone) {
		return;
	}
	
	if (is_dir("$landing_zone/$target_full_path") || is_a_graveyard_dir($share, $full_path)) {
		gh_log(INFO, "Directory renamed: $landing_zone/$full_path -> $landing_zone/$target_full_path");
		foreach ($storage_pool_directories as $target_drive) {
			list($original_path, $dirname) = explode_full_path(get_share_landing_zone($share) . "/$target_full_path");

			if (is_dir("$target_drive/$share/$full_path")) {
				# Make sure the parent directory of target_full_path exists, before we try moving something there...
				list($path, $dirname) = explode_full_path("$target_drive/$share/$target_full_path");
				gh_mkdir($path, "$target_drive/$share", $original_path);

				rename("$target_drive/$share/$full_path", "$target_drive/$share/$target_full_path");
				gh_log(DEBUG, "  Directory moved: $target_drive/$share/$full_path -> $target_drive/$share/$target_full_path");
			}

			list($path, $dirname) = explode_full_path("$target_drive/.gh_graveyard/$share/$target_full_path");
			gh_mkdir($path, "$target_drive/.gh_graveyard/$share", $original_path);
			$result = @rename("$target_drive/.gh_graveyard/$share/$full_path", "$target_drive/.gh_graveyard/$share/$target_full_path");
			if ($result) {
				gh_log(DEBUG, "  Graveyard directory moved: $target_drive/.gh_graveyard/$share/$full_path -> $target_drive/.gh_graveyard/$share/$target_full_path");
			}
		}
		$existing_tombstones = get_tombstones($share, $target_full_path, null, FALSE, FALSE, FALSE); // $check_symlink=FALSE to prevent symlinks to be handled at this point; they'll be fixed below.
		foreach ($existing_tombstones as $file_path => $file_tombstones) {
			$new_file_tombstones = array();
			$symlinked = FALSE;
			foreach ($file_tombstones as $key => $tombstone) {
				$old_path = $tombstone->path;
				$tombstone->path = str_replace("/$share/$full_path/", "/$share/$target_full_path/", $tombstone->path);
				gh_log(DEBUG, "  Changing tombstone: $old_path -> $tombstone->path");
				$new_file_tombstones[$tombstone->path] = $tombstone;

				// is_linked = is the target of the existing symlink
				if ($tombstone->is_linked) {
					$symlinked = TRUE;
					gh_log(DEBUG, "  Updating symlink at $landing_zone/$target_full_path/$file_path to point to $tombstone->path");
					if (gh_recycle("$landing_zone/$target_full_path/$file_path")) {
 						@symlink($tombstone->path, "$landing_zone/$target_full_path/$file_path");
						// Creating this symlink can fail if the parent dir was removed
					}
				}
			}
			if (!$symlinked && count($file_tombstones) > 0) {
				// None of the tombstones were is_linked; use the last one for the symlink.
				$tombstone->is_linked = TRUE;
				$file_tombstones[$key] = $tombstone;
				gh_log(DEBUG, "  Updating symlink at $landing_zone/$target_full_path/$file_path to point to $tombstone->path");
				if (gh_recycle("$landing_zone/$target_full_path/$file_path")) {
					@symlink($tombstone->path, "$landing_zone/$target_full_path/$file_path");
					// Creating this symlink can fail if the parent dir was removed
				}
			}
			list($path, $filename) = explode_full_path("$target_full_path/$file_path");
			save_tombstones($share, $path, $filename, $new_file_tombstones);
		}
	} else {
		gh_log(INFO, "File renamed: $landing_zone/$full_path -> $landing_zone/$target_full_path");
		
		// Check if another process locked this file before we work on it.
		if (file_is_locked($share, $target_full_path) !== FALSE) {
			gh_log(DEBUG, "  File $landing_zone/$target_full_path is locked by another process. Will wait until it's unlocked to work on it.");
			postpone_task($task_id);
			return;
		}

		list($path, $filename) = explode_full_path($full_path);
		list($target_path, $target_filename) = explode_full_path($target_full_path);

		$existing_tombstones = get_tombstones($share, $path, $filename, FALSE, FALSE, FALSE); // $check_symlink=FALSE to prevent symlink to be handled at this point; it'll be fixed below.

		// There might be old tombstones... for example, when a delete task was skipped.
		// Let's remove the file copies if there are any leftovers; correct copies will be re-created below.
		if (file_exists("$landing_zone/$target_full_path") && (count($existing_tombstones) > 0 || !is_link("$landing_zone/$target_full_path"))) {
			$existing_target_tombstones = get_tombstones($share, $target_path, $target_filename);
			if (count($existing_target_tombstones) > 0) {
				foreach ($existing_target_tombstones as $tombstone) {
					gh_recycle($tombstone->path);
				}
				remove_tombstones($share, $target_path, $target_filename);
			}
		}

		if (count($existing_tombstones) == 0) {
			// Any NOK tombstones that need to be removed?
			$all_existing_tombstones = get_tombstones($share, $path, $filename, TRUE, FALSE, FALSE);
			if (count($all_existing_tombstones) > 0) {
				remove_tombstones($share, $path, $filename);
			}
			// New file
			gh_write($share, $target_full_path, $task_id);
		} else {
			$symlinked = FALSE;
			foreach ($existing_tombstones as $key => $tombstone) {
				$old_path = $tombstone->path;
				$tombstone->path = str_replace("/$share/$full_path", "/$share/$target_full_path", $old_path);
				gh_log(DEBUG, "  Renaming copy at $old_path to $tombstone->path");

				// Make sure the target directory exists
				list($tombstone_dir_path, $tombstone_filename) = explode_full_path($tombstone->path);
				$root_path = str_replace(clean_dir("/$share/$target_full_path"), '', $tombstone->path);
				list($original_path, $dirname) = explode_full_path(get_share_landing_zone($share) . "/$target_full_path");
				gh_mkdir($tombstone_dir_path, "$root_path/$share", $original_path);

				$it_worked = rename($old_path, $tombstone->path);

				if ($it_worked) {
					// is_linked = is the target of the existing symlink
					$symlinked = TRUE;
					if ($tombstone->is_linked) {
						gh_log(DEBUG, "  Updating symlink at $landing_zone/$target_full_path to point to $tombstone->path");
						if (gh_recycle("$landing_zone/$target_full_path")) {
	 						@symlink($tombstone->path, "$landing_zone/$target_full_path");
							// Creating this symlink can fail if the parent dir was removed
						}
					}
				} else {
					gh_log(WARN, "    Warning! An error occured while renaming file copy $old_path to $tombstone->path.");
				}
				$existing_tombstones[$key] = $tombstone;
			}
			if (!$symlinked && count($existing_tombstones) > 0) {
				// None of the tombstones were is_linked; use the last one for the symlink.
				$tombstone->is_linked = TRUE;
				$existing_tombstones[$key] = $tombstone;
				gh_log(DEBUG, "  Updating symlink at $landing_zone/$target_full_path to point to $tombstone->path");
				if (gh_recycle("$landing_zone/$target_full_path")) {
					@symlink($tombstone->path, "$landing_zone/$target_full_path");
					// Creating this symlink can fail if the parent dir was removed
				}
			}
			remove_tombstones($share, $path, $filename);
			save_tombstones($share, $target_path, $target_filename, $existing_tombstones);

			if (is_link("$landing_zone/$full_path") && !file_exists(readlink("$landing_zone/$full_path"))) {
				gh_log(DEBUG, "  Removing deprecated symlink at $landing_zone/$full_path");
				unlink("$landing_zone/$full_path");
			}
		}
	}
	$sleep_before_task = array();
}

function gh_file_exists($real_path, $log_message=null) {
	clearstatcache();
	if (!file_exists($real_path)) {
		if ($log_message != null) {
			eval('$log_message = "' . str_replace('"', '\"', $log_message) . '";');
			gh_log(DEBUG, $log_message);
		}
		return FALSE;
	}
	return TRUE;
}

function get_num_copies($share) {
	global $shares_options, $storage_pool_directories;
	if (!isset($shares_options[$share]['num_copies'])) {
		global $config_file;
		gh_log(CRITICAL, "Found a share ($share_name) with no 'num_copies' value defined in $config_file. You need to edit $config_file to fix this, then restart Greyhole.");
	}
	$num_copies = $shares_options[$share]['num_copies'];
	if ($num_copies < 1) {
		$num_copies = 1;
	}
	if ($num_copies > count($storage_pool_directories)) {
		$num_copies = count($storage_pool_directories);
	}
	return $num_copies;
}

function file_is_locked($share, $full_path) {
	$landing_zone = get_share_landing_zone($share);
	if (!$landing_zone) {
		return FALSE;
	}
	
	$real_fullpath = "$landing_zone/$full_path";
	$result = exec("lsof -M -n -P -l " . quoted_form($real_fullpath) . " 2> /dev/null");
	if (strpos($result, $real_fullpath) !== FALSE) {
		return $result;
	}
	$query = sprintf("SELECT * FROM tasks WHERE complete = 'no' AND action = 'write' AND share = '%s' AND full_path = '%s' LIMIT 1",
		db_escape_string($share),
		db_escape_string($full_path)
	);
	$result = db_query($query) or gh_log(CRITICAL, "Error querying tasks for locked files: " . db_error());
	return db_fetch_object($result) !== FALSE;
}

function real_file_is_locked($real_fullpath) {
	$result = exec("lsof -M -n -P -l " . quoted_form($real_fullpath) . " 2> /dev/null");
	if (strpos($result, $real_fullpath) !== FALSE) {
		return $result;
	}
	return FALSE;
}

function gh_write($share, $full_path, $task_id) {
	global $storage_pool_directories, $log_level, $balance_modified_files, $sleep_before_task;
	
	$landing_zone = get_share_landing_zone($share);
	if (!$landing_zone) {
		return;
	}
	
	if (!gh_file_exists("$landing_zone/$full_path", 'File write: $real_path doesn\'t exist anymore. Skipping.')) {
		if (!gh_file_exists($landing_zone, '  Share "'.$share.'" landing zone "$real_path" doesn\'t exist anymore. Will not process this task until it re-appears...')) {
			postpone_task($task_id);
		}
		return;
	}
	
	$num_copies_required = get_num_copies($share);

	list($path, $filename) = explode_full_path($full_path);

	if (is_link("$landing_zone/$full_path")) {
		$source_file = clean_dir(readlink("$landing_zone/$full_path"));
		gh_log(INFO, "File changed: $share/$full_path", FALSE);
		if ($log_level === DEBUG) {
			clearstatcache();
			$filesize = filesize($source_file);
			gh_log(DEBUG, " - " . bytes_to_human($filesize, FALSE), FALSE);
		}
		gh_log(INFO, "");
		gh_log(DEBUG, "  Will use source file: $source_file");

		$existing_tombstones = get_tombstones($share, $path, $filename);
		
		// Will keep existing copies at their location if balance_modified_files = no
		// This will allow us to use rsync instead of blindly copying the complete files.
		if ($balance_modified_files) {
			// Remove old copies (but not the one that was updated!)
			$keys_to_remove = array();
			$found_source_file = FALSE;
			foreach ($existing_tombstones as $key => $tombstone) {
				$tombstone->path = clean_dir($tombstone->path);
				if ($tombstone->path == $source_file) {
					$tombstone->is_linked = TRUE;
					$tombstone->state = 'OK';
					$found_source_file = TRUE;
				} else {
					gh_log(DEBUG, "  Will remove copy at $tombstone->path");
					$keys_to_remove[] = $tombstone->path;
				}
				// This will make sure the correct key is used in the $existing_tombstones array...
				//   This is important because that key is what is used to check if there's already a copy on that drive.
				unset($existing_tombstones[$key]);
				$existing_tombstones[$tombstone->path] = $tombstone;
			}
			if (!$found_source_file) {
				// This shouldn't happen, but if we're about to remove all copies, let's make sure we keep at least one.
				$key = array_shift($keys_to_remove);
				$source_file = $existing_tombstones[$key]->path;
				gh_log(DEBUG, "  Change of mind... Will use source file: $source_file");
			}
			foreach ($keys_to_remove as $key) {
				if ($existing_tombstones[$key]->path != $source_file) {
					gh_recycle($existing_tombstones[$key]->path);
				}
				unset($existing_tombstones[$key]);
			}
		}
	} else {
		$source_file = clean_dir("$landing_zone/$full_path");
		gh_log(INFO, "File created: $share/$full_path", FALSE);
		if ($log_level === DEBUG) {
			clearstatcache();
			$filesize = filesize($source_file);
			gh_log(DEBUG, " - " . bytes_to_human($filesize, FALSE), FALSE);
		}
		gh_log(INFO, "");

		// There might be old tombstones... for example, when a delete task was skipped.
		// Let's remove the file copies if there are any leftovers; correct copies will be re-created in create_copies_from_tombstones()
		$existing_tombstones = get_tombstones($share, $path, $filename);
		if (count($existing_tombstones) > 0) {
			foreach ($existing_tombstones as $tombstone) {
				gh_recycle($tombstone->path);
			}
			remove_tombstones($share, $path, $filename);
			$existing_tombstones = array();
		}
	}

	// Only need to check for locking if we have something to do!
	if ($num_copies_required > 1 || count($existing_tombstones) == 0) {
		// Check if another process locked this file before we work on it.
		if (($locked_by = file_is_locked($share, $full_path)) !== FALSE) {
			gh_log(DEBUG, "  File is locked by another process. Will wait until it's unlocked to work on it.");
			postpone_task($task_id);
			return;
		}
		$sleep_before_task = array();
	}
	
	$tombstones = create_tombstones($share, $full_path, $num_copies_required, $filesize, $existing_tombstones);

	if (count($tombstones) == 0) {
		gh_log(WARN, "  No tombstones could be created. Will wait until tombstones can be created to work on this file.");
		postpone_task($task_id);
		return;
	}

	if (!is_link("$landing_zone/$full_path")) {
		// Use the 1st tombstone for the symlink; it might be on a sticky drive.
		$i = 0;
		foreach ($tombstones as $tombstone) {
			$tombstone->is_linked = ($i++ == 0);
		}
	}

	save_tombstones($share, $path, $filename, $tombstones);

	create_copies_from_tombstones($tombstones, $share, $full_path, $source_file);
}

function is_greyhole_owned_dir($path) {
	global $going_dir;
	if (isset($going_dir) && $path == $going_dir) {
		return FALSE;
	}
	return file_exists("$path/.greyhole_uses_this");
}

function create_copies_from_tombstones($tombstones, $share, $full_path, $source_file) {
	$landing_zone = get_share_landing_zone($share);
	
	list($path, $filename) = explode_full_path($full_path);

	$link_next = FALSE;
	foreach ($tombstones as $key => $tombstone) {
		if (!gh_file_exists("$landing_zone/$full_path", '  $real_path doesn\'t exist anymore. Aborting.')) { return; }
		
		if ($tombstone->path == $source_file && $tombstone->state == 'OK') {
			gh_log(DEBUG, "  File copy at $tombstone->path is already up to date.");
			continue;
		}

		gh_log(DEBUG, "  Copying file to $tombstone->path");

		$root_path = str_replace(clean_dir("/$share/$full_path"), '', $tombstone->path);
		if (!is_greyhole_owned_dir($root_path)) {
			gh_log(WARN, "  Warning! It seems $root_path is missing it's \".greyhole_uses_this\" file. This either means this mount is currently unmounted, or you forgot to create this file.");
			$tombstone->state = 'Gone';
			$tombstones[$key] = $tombstone;
			continue;
		}

		list($tombstone_dir_path, $tombstone_filename) = explode_full_path($tombstone->path);

		list($original_path, $tombstone_filename) = explode_full_path(get_share_landing_zone($share) . "/$full_path");
		if (!gh_mkdir($tombstone_dir_path, "$root_path/$share", $original_path)) {
			$tombstone->state = 'Gone';
			$tombstones[$key] = $tombstone;
			continue;
		}

		$temp_path = get_temp_filename($tombstone->path);
		$file_infos = gh_get_file_infos("$landing_zone/$full_path");
		
		$it_worked = FALSE;
		if (is_link("$landing_zone/$full_path")) {
			exec("rsync " . quoted_form(readlink("$landing_zone/$full_path")) . " " . quoted_form($temp_path));
			$it_worked = file_exists($temp_path) && filesize($temp_path) == filesize(readlink("$landing_zone/$full_path"));
		} else if (is_file("$landing_zone/$full_path")) {
			exec("rsync " . quoted_form("$landing_zone/$full_path") . " " . quoted_form($temp_path));
			$it_worked = file_exists($temp_path) && filesize($temp_path) == filesize("$landing_zone/$full_path");
			if ($it_worked) {
				unlink("$landing_zone/$full_path");
			}
		}
		
		if ($it_worked) {
			rename($temp_path, $tombstone->path);
			gh_chperm($tombstone->path, $file_infos);
		} else {
			gh_log(WARN, "    Failed file copy. Will mark this tombstone 'Gone', and re-process this write task.");
			@unlink($temp_path);
			if ($tombstone->is_linked) {
				$tombstone->is_linked = FALSE;
				$link_next = TRUE;
			}
			$tombstone->state = 'Gone';
			gh_recycle($tombstone->path);
			$tombstones[$key] = $tombstone;
			save_tombstones($share, $path, $filename, array_values($tombstones));

			// Queue a new write task, to replace the now gone copy.
			// Insert with id = 0 to make sure it's processed right after the current task is complete.
			$query = sprintf("INSERT INTO tasks (id, action, share, full_path, complete) VALUES (0, 'write', '%s', '%s', 'yes')",
				db_escape_string($share),
				db_escape_string(clean_dir("$path/$filename"))
			);
			db_query($query) or gh_log(CRITICAL, "Can't insert write task: " . db_error());

			continue;
		}

		if ($link_next && !$tombstone->is_linked) {
			$tombstone->is_linked = TRUE;
			$tombstones[$key] = $tombstone;
		}
		$link_next = FALSE;
		if ($tombstone->is_linked) {
			gh_log(DEBUG, "    Creating symlink in share pointing to the above file copy.");
			symlink($tombstone->path, "$landing_zone/$path/.gh_$filename");
			if (!file_exists("$landing_zone/$full_path") || gh_recycle("$landing_zone/$full_path")) {
				rename("$landing_zone/$path/.gh_$filename", "$landing_zone/$path/$filename");
			} else {
				unlink("$landing_zone/$path/.gh_$filename");
			}
		}

		if (gh_file_exists($tombstone->path, '  Copy at $real_path doesn\'t exist. Will not mark it OK!')) {
			$tombstone->state = 'OK';
			$tombstones[$key] = $tombstone;
		}
		save_tombstones($share, $path, $filename, array_values($tombstones));
	}
}

function gh_chperm($real_file_path, $file_infos) {
	chmod($real_file_path, $file_infos->fileperms);
	chown($real_file_path, $file_infos->fileowner);
	chgrp($real_file_path, $file_infos->filegroup);
}

function gh_mkdir($directory, $root_path, $original_directory) {
	$root_path = '/' . trim($root_path, '/');
	if (!is_dir($directory)) {
		$dir_infos = gh_get_file_infos($original_directory);
		// Try simple mkdir; will work only if parent dir already exists
		if (!@mkdir($directory, $dir_infos->fileperms)) {
			// Try recursive mkdir
			if (!mkdir($directory, $dir_infos->fileperms, TRUE)) {
				gh_log(WARN, "  Failed to create directory $directory");
				return FALSE;
			}
			// Need to chown/chgrp parent dirs too
			$parent_directory = $directory;
			$original_parent_directory = $original_directory;
			$i = 0;
			while ($i++ < 255) { # Safety net... The real way to exit this loop is the break on ($parent_directory == $root_path)
				$dir_infos = gh_get_file_infos($original_parent_directory);
				if (!chmod($parent_directory, $dir_infos->fileperms)) {
					gh_log(WARN, "  Failed to chmod directory '$parent_directory'");
				}
				if (!chown($parent_directory, $dir_infos->fileowner)) {
					gh_log(WARN, "  Failed to chown directory '$parent_directory'");
				}
				if (!chgrp($parent_directory, $dir_infos->filegroup)) {
					gh_log(WARN, "  Failed to chgrp directory '$parent_directory'");
				}
				if ($parent_directory == $root_path) {
					break;
				}
				list($parent_directory, $directory_name) = explode_full_path($parent_directory);
				list($original_parent_directory, $directory_name) = explode_full_path($original_parent_directory);
			}
		} else {
			// Simple mkdir worked
			chown($directory, $dir_infos->fileowner);
			chgrp($directory, $dir_infos->filegroup);
		}
	}
	return TRUE;
}

function get_temp_filename($full_path) {
	list($path, $filename) = explode_full_path($full_path);
	return "$path/.$filename." . substr(md5($filename), 0, 5);
}

function create_tombstones($share, $full_path, $num_copies_required, $filesize, $tombstones=array()) {
	list($path, $filename) = explode_full_path($full_path);
	
	$num_ok = count($tombstones);
	foreach ($tombstones as $key => $tombstone) {
		if (!file_exists($tombstone->path)) {
			$tombstone->state = 'Gone';
		}
		if ($tombstone->state != 'OK' && $tombstone->state != 'Pending') {
			$num_ok--;
		}
		if ($key != $tombstone->path) {
			unset($tombstones[$key]);
			$key = $tombstone->path;
		}
		$tombstones[$key] = $tombstone;
	}

	// Select drives that have enough free space for this file
	if ($num_ok < $num_copies_required) {
		$local_target_drives = order_target_drives($filesize/1024, FALSE, $share, $path);
	}
	while ($num_ok < $num_copies_required && count($local_target_drives) > 0) {
		$target_drive = array_shift($local_target_drives);
		$clean_target_full_path = clean_dir("$target_drive/$share/$full_path");
		if (isset($tombstones[$clean_target_full_path])) {
			continue;
		}
		// Prepend new target drives, to make sure sticky directories will be used first
		$tombstones = array_reverse($tombstones);
		$tombstones[$clean_target_full_path] = (object) array('path' => $clean_target_full_path, 'is_linked' => count($tombstones) == 0, 'state' => 'Pending');
		$tombstones = array_reverse($tombstones);
		$num_ok++;
	}
	return $tombstones;
}

function get_tombstone_data_filename($share, $path, $filename) {
	foreach (get_graveyards() as $graveyard) {
		$f = "$graveyard/$share/$path/$filename";
		if (file_exists($f)) {
			return $f;
		}
	}
	return FALSE;
}

function get_tombstones_for_dir($share, $path, $load_nok_tombstones, $quiet, $prefix='') {
	$landing_zone = get_share_landing_zone($share);
	
	$tombstones = array();
	
	// Find new files (files with no tombstones yet)
	$handle = @opendir("$landing_zone/$path");
	if ($handle) {
		while (($filename = readdir($handle)) !== FALSE) {
			if ($filename != '.' && $filename != '..') {
				if (is_dir("$landing_zone/$path/$filename")) {
					foreach (get_tombstones_for_dir($share, "$path/$filename", $load_nok_tombstones, $quiet, $prefix.$filename.'/') as $filename => $file_tombstones) {
						$tombstones[$filename] = $file_tombstones;
					}
				} else if (is_file("$landing_zone/$path/$filename") && !is_link("$landing_zone/$path/$filename")) {
					// Found a file in a renamed directory that has no tombstone. Let's queue it for processing.
					gh_log(DEBUG, "$share/$path/$filename is a file (not a symlink). Adding a new 'write' pending task for that file.");
					$query = sprintf("INSERT INTO tasks (action, share, full_path, complete) VALUES ('write', '%s', '%s', 'yes')",
						db_escape_string($share),
						db_escape_string(clean_dir("$path/$filename"))
					);
					db_query($query) or gh_log(CRITICAL, "Can't insert write task: " . db_error());
				}
			}
		}
	}

	foreach (get_graveyards() as $graveyard) {
		$handle = @opendir("$graveyard/$share/$path");
		if (!$handle) {
			#gh_log(DEBUG, "Got 0 tombstones ($graveyard/$share/$path does't exists).");
			continue;
		}
		while (($filename = readdir($handle)) !== FALSE) {
			if ($filename != '.' && $filename != '..') {
				if (is_dir("$graveyard/$share/$path/$filename")) {
					foreach (get_tombstones_for_dir($share, "$path/$filename", $load_nok_tombstones, $quiet, $prefix.$filename.'/') as $filename => $file_tombstones) {
						$tombstones[$filename] = $file_tombstones;
					}
				} else {
					// Found a file
					$tombstones[$prefix.$filename] = get_tombstones($share, $path, $filename, $load_nok_tombstones, $quiet);
					if (count($tombstones[$prefix.$filename]) == 0 && is_file("$landing_zone/$path/$filename") && !is_link("$landing_zone/$path/$filename")) {
						// Found a file in a renamed directory that has no tombstone. Let's queue it for processing.
						gh_log(DEBUG, "$share/$path/$filename is a file (not a symlink). Adding a new 'write' pending task for that file.");
						$query = sprintf("INSERT INTO tasks (action, share, full_path, complete) VALUES ('write', '%s', '%s', 'yes')",
							db_escape_string($share),
							db_escape_string(clean_dir("$path/$filename"))
						);
						db_query($query) or gh_log(CRITICAL, "Can't insert write task: " . db_error());
					}
				}
			}
		}
		closedir($handle);
	}

	return $tombstones;
}

function get_tombstones($share, $path, $filename=null, $load_nok_tombstones=FALSE, $quiet=FALSE, $check_symlink=TRUE) {
	if (!$quiet) {
		gh_log(DEBUG, "Loading tombstones for " . ($filename === null ? '(dir) ' : '') . "$share" . (!empty($path) ? "/$path" : "") . "" . ($filename!== null ? "/$filename" : "") . "... ", FALSE);
		if ($filename === null) {
			gh_log(DEBUG, "");
		}
	}
	if ($filename === null) {
		// Load all tombstones from the specified directory
		$tombstones = get_tombstones_for_dir($share, $path, $load_nok_tombstones, $quiet);
		return $tombstones;
	}
	$tombstones_data_file = get_tombstone_data_filename($share, $path, $filename);
	clearstatcache();
	$tombstones = array();
	if (file_exists($tombstones_data_file)) {
		if (($fp = fopen($tombstones_data_file, 'r'))) {
			$t = '';
			while (!feof($fp)) {
				$t .= fread($fp, 1024);
			}
			$tombstones = unserialize($t);
			fclose($fp);
		}
	}

	if ($check_symlink) {
		// Fix wrong 'is_linked' flags
		$share_file = get_share_landing_zone($share) . "/$path/$filename";
		$share_file_link_to = FALSE;
		if (is_link($share_file)) {
			$share_file_link_to = readlink($share_file);
		}
		foreach ($tombstones as $key => $tombstone) {
			if ($tombstone->state == 'OK' && $share_file_link_to !== FALSE) {
				if ($tombstone->is_linked && $tombstone->path != $share_file_link_to) {
					if (!$quiet) {
						gh_log(DEBUG, 'Changing is_linked to FALSE for ' . $tombstone->path);
					}
					$tombstone->is_linked = FALSE;
					$tombstones[$key] = $tombstone;
					save_tombstones($share, $path, $filename, array_values($tombstones));
				} else if (!$tombstone->is_linked && $tombstone->path == $share_file_link_to) {
					if (!$quiet) {
						gh_log(DEBUG, 'Changing is_linked to TRUE for ' . $tombstone->path);
					}
					$tombstone->is_linked = TRUE;
					$tombstones[$key] = $tombstone;
					save_tombstones($share, $path, $filename, array_values($tombstones));
				}
			}
		}
	}

	$ok_tombstones = array();
	foreach ($tombstones as $key => $tombstone) {
		$valid_path = FALSE;
		global $storage_pool_directories;
		foreach ($storage_pool_directories as $dir) {
			if (strpos($tombstone->path, $dir) === 0) {
				$valid_path = TRUE;
				break;
			}
		}
		if ($valid_path && ($load_nok_tombstones || $tombstone->state == 'OK')) {
			$ok_tombstones[$key] = $tombstone;
		} else {
			if (!$valid_path) {
				gh_log(INFO, "Found a tombstone pointing to a directory not defined in your storage pool: '$tombstone->path'. Will mark it as Gone.");
				$tombstone->state = 'Gone';
				$tombstones[$key] = $tombstone;
				save_tombstones($share, $path, $filename, array_values($tombstones));
			} else {
				gh_log(INFO, "Found a tombstone, pointing to '$tombstone->path', with state = '$tombstone->state'. We just want 'OK' tombstones; will not use this tombstone.");
			}
		}
	}
	$tombstones = $ok_tombstones;
	
	if (!$quiet) {
		gh_log(DEBUG, "Got " . count($tombstones) . " tombstones.");
	}
	return $tombstones;
}

function remove_tombstones($share, $path, $filename) {
	gh_log(DEBUG, "  Removing tombstones for $share" . (!empty($path) ? "/$path" : "") . ($filename!== null ? "/$filename" : ""));
	while (($f = get_tombstone_data_filename($share, $path, $filename)) !== FALSE) {
		@unlink($f);
		gh_log(DEBUG, "    Removed tombstone at $f");
		clearstatcache();
	}
}

function save_tombstones($share, $path, $filename, $tombstones) {
	if (count($tombstones) == 0) {
		remove_tombstones($share, $path, $filename);
		return;
	}

	gh_log(DEBUG, "  Saving " . count($tombstones) . " tombstones for $share" . (!empty($path) ? "/$path" : "") . ($filename!== null ? "/$filename" : ""));
	foreach (get_graveyards() as $graveyard) {
		$target_drive = str_replace('/.gh_graveyard', '', $graveyard);
		$data_filepath = "$graveyard/$share/$path";
		$has_tombstone = FALSE;
		foreach ($tombstones as $tombstone) {
			if (strpos($tombstone->path, $target_drive) === 0) {
				gh_mkdir($data_filepath, "$graveyard/$share", get_share_landing_zone($share) . "/$path");
				gh_log(DEBUG, "    Saving tombstones in $data_filepath/$filename");
				file_put_contents("$data_filepath/$filename", serialize($tombstones));
				$has_tombstone = TRUE;
				break;
			}
		}
		if (!$has_tombstone && file_exists("$data_filepath/$filename")) {
			unlink("$data_filepath/$filename");
		}
	}
}

function simplify_tasks() {
	global $action;
	$action = 'simplify_tasks';
	
	gh_log(DEBUG, "Simplifying pending tasks.");
	
	// Delete duplicate writes/renames
	$query = "SELECT GROUP_CONCAT(id) ids, action, share, full_path, additional_info FROM tasks WHERE action IN ('write', 'rename') GROUP BY action, share, full_path, additional_info HAVING COUNT(*) > 1";
	$result = db_query($query) or gh_log(CRITICAL, "Can't select duplicate tasks: " . db_error());
	while ($row = db_fetch_object($result)) {
		$ids = explode(',', $row->ids);
		sort($ids);
		array_pop($ids);
		gh_log(DEBUG, "  Removing " . count($ids) . " duplicate pending tasks for $row->share/" . (!empty($row->full_path) ? $row->full_path : '') . (!empty($row->additional_info) ? " -> $row->additional_info" : ''));
		
		$ids = implode(',', $ids);
		if ($ids[0] == ',') {
			$ids = substr($ids, 1);
		}
		$query = sprintf("DELETE FROM tasks WHERE id IN (%s)",
			$ids
		);
		db_query($query) or gh_log(CRITICAL, "Can't delete duplicate tasks: " . db_error());
	}
	db_free_result($result);
	
	// Remove locked write tasks
	$query = "SELECT share, full_path FROM tasks WHERE action = 'write' and complete = 'no'";
	$result = db_query($query) or gh_log(CRITICAL, "Can't select locked write tasks: " . db_error());
	while ($row = db_fetch_object($result)) {
		$query = sprintf("DELETE FROM tasks WHERE action = 'write' and complete = 'yes' AND share = '%s' AND full_path = '%s'",
			db_escape_string($row->share),
			db_escape_string($row->full_path)
		);
		db_query($query) or gh_log(CRITICAL, "Can't delete duplicate of locked write task: " . db_error());
	}
}

function parse_samba_log($simplify_after_parse=TRUE) {
	global $samba_log_file, $action;
	$action = 'parse_logs';

	// If we have enough queued tasks (9k+), let's not parse the log at this time, and get some work done.
	// Once we fall below 9k tasks queued, we'll queue at most 1k new tasks, then get back to work.
	// This will effectively 'batch' large file operations to make sure the DB doesn't become a problem because of the number of row,
	//   and this will allow the end-user to see real activity, other that new rows in greyhole.tasks...
	$query = "SELECT COUNT(*) num_rows FROM tasks";
	$result = db_query($query) or gh_log(CRITICAL, "Can't get tasks count: " . db_error());
	$row = db_fetch_object($result);
	db_free_result($result);
	$num_rows = (int) $row->num_rows;
	if ($num_rows >= 9000) {
		return;
	}

	$query = sprintf("SELECT value FROM settings WHERE name = '%s'", 'last_read_log_smbd_line');
	$result = db_query($query) or gh_log(CRITICAL, "Can't query settings for 'last_read_log_smbd_line': " . db_error());
	$row = db_fetch_object($result);
	if ($row === FALSE || db_fetch_object($result) !== FALSE) {
		gh_log(CRITICAL, "Received " . ($row === FALSE ? 'no rows' : 'more than one row') . " when querying settings for 'last_read_log_smbd_line'; expected one.");
	}
	db_free_result($result);

	$f_seek_point = (int) $row->value;

	clearstatcache();
	if ($f_seek_point > filesize($samba_log_file)) {
		gh_log(DEBUG, "Log file size = " . filesize($samba_log_file) . "; forcing seek point to 0.");
		$f_seek_point = 0;
	}

	$fp = fopen($samba_log_file, 'r') or gh_log(CRITICAL, "Can't open Samba log file '$samba_log_file' for reading.");
	fseek($fp, $f_seek_point);

	$new_tasks = 0;
	$last_line = FALSE;
	$act = FALSE;
	while ($line = fgets($fp)) {
		if (($p = strpos($line, ' smbd_greyhole:')) !== FALSE) {
			$line = trim(substr($line, $p+16));

			// Prevent insertion of unneeded duplicates
			if ($line === $last_line) {
				update_last_read_log_smbd_line($fp);
				continue;
			}
			$last_line = $line;

			// Close logs are only processed when no more duplicates are found, so we'll execute this now that a non-duplicate line was found.
			if ($act === 'close') {
				$query = sprintf("UPDATE tasks SET additional_info = NULL, complete = 'yes' WHERE complete = 'no' AND share = '%s' AND additional_info = '%s'",
					db_escape_string($share),
					$fd
				);
				db_query($query) or gh_log(CRITICAL, "Error updating tasks (1): " . db_error() . "; Query: $query");
			}

			$line = explode('*', $line);
			$act = array_shift($line);
			$share = array_shift($line);
			if ($act == 'mkdir') {
				// Nothing to do with those
				update_last_read_log_smbd_line($fp);
				continue;
			}
			$result = array_pop($line);
			if (strpos($result, 'failed') === 0) {
				gh_log(DEBUG, "Failed $act in $share/$line[0]. Skipping.");
				update_last_read_log_smbd_line($fp);
				continue;
			}
			unset($fullpath);
			unset($fullpath_target);
			unset($fd);
			switch ($act) {
				case 'open':
					$fullpath = array_shift($line);
					$fd = array_shift($line);
					$act = 'write';
					break;
				case 'rmdir':
				case 'unlink':
					$fullpath = array_shift($line);
					break;
				case 'rename':
					$fullpath = array_shift($line);
					$fullpath_target = array_shift($line);
					break;
				case 'close':
					$fd = array_shift($line);
					break;
				default:
					$act = FALSE;
			}
			if ($act === FALSE) {
				update_last_read_log_smbd_line($fp);
				continue;
			}

			// Close logs are only processed when no more duplicates are found, so we won't execute it just yet; we'll process it the next time we find a non-duplicate line.
			if ($act != 'close') {
				if (isset($fd) && $fd == -1) {
					update_last_read_log_smbd_line($fp);
					continue;
				}
				$new_tasks++;
				$query = sprintf("INSERT INTO tasks (action, share, full_path, additional_info, complete) VALUES ('%s', '%s', %s, %s, '%s')",
					$act,
					db_escape_string($share),
					isset($fullpath) ? "'".db_escape_string(clean_dir($fullpath))."'" : 'NULL',
					isset($fullpath_target) ? "'".db_escape_string(clean_dir($fullpath_target))."'" : (isset($fd) ? "'$fd'" : 'NULL'),
					$act == 'write' ? 'no' : 'yes'
				);
			}

			db_query($query) or gh_log(CRITICAL, "Error inserting task: " . db_error() . "; Query: $query");
			update_last_read_log_smbd_line($fp);
			
			// If we have enough queued tasks (10k), let's stop parsing the log, and get some work done.
			$query = "SELECT COUNT(*) num_rows FROM tasks";
			$result = db_query($query) or gh_log(CRITICAL, "Can't get tasks count: " . db_error());
			$row = db_fetch_object($result);
			db_free_result($result);
			$num_rows = (int) $row->num_rows;
			if ($num_rows >= 10000) {
				break;
			}
		}
	}
	fclose($fp);

	// Close logs are only processed when no more duplicates are found, so we'll execute this now that we're done parsing the current log.
	if ($act == 'close') {
		$query = sprintf("UPDATE tasks SET additional_info = NULL, complete = 'yes' WHERE complete = 'no' AND share = '%s' AND additional_info = '%s'",
			db_escape_string($share),
			$fd
		);
		db_query($query) or gh_log(CRITICAL, "Error updating tasks (2): " . db_error() . "; Query: $query");
	}
	
	if ($simplify_after_parse && $new_tasks > 0) {
		$query = "SELECT COUNT(*) num_rows FROM tasks";
		$result = db_query($query) or gh_log(CRITICAL, "Can't get tasks count: " . db_error());
		$row = db_fetch_object($result);
		db_free_result($result);
		$num_rows = (int) $row->num_rows;
		if ($num_rows < 1000 || $num_rows % 5 == 0) { // Runs 1/5 of the times when num_rows > 1000
			if ($num_rows < 5000 || $num_rows % 100 == 0) { // Runs 1/100 of the times when num_rows > 5000
				simplify_tasks();
			}
		}
	}
}

function update_last_read_log_smbd_line($fp) {
	$f_seek_point = ftell($fp);
	$query = sprintf("UPDATE settings SET value = '%d' WHERE name = '%s'", $f_seek_point, 'last_read_log_smbd_line');
	db_query($query) or gh_log(CRITICAL, "Can't update settings for 'last_read_log_smbd_line': " . db_error());
}

function get_free_space_in_storage_pool_dirs() {
	global $storage_pool_directories, $df_command, $last_df_time, $last_dfs, $df_cache_time;
	if ($last_df_time > time() - $df_cache_time) {
		return $last_dfs;
	}
	$dfs = array();
	exec($df_command, $responses);
	array_shift($responses); // header
	for ($i=0; $i<count($responses); $i++) {
		$response = explode(' ', $responses[$i]);
		$free_space = (float) array_pop($response);
		$mount = implode(' ', $response);
		$target_dir = '';
		foreach ($storage_pool_directories as $target_drive) {
			if (strpos($target_drive, $mount) === 0 && strlen($target_drive) > strlen($target_dir)) {
				$target_dir = $target_drive;
			}
		}
		$dfs[$target_dir] = $free_space;
	}
	$last_df_time = time();
	$last_dfs = $dfs;
	return $dfs;
}

function order_target_drives($filesize_kb, $include_full_drives, $share, $path, $log_prefix='') {
	global $storage_pool_directories, $minimum_free_space_pool_directories, $dir_selection_algorithm, $last_OOS_notification, $sticky_files;
	$sorted_target_drives = array();
	$last_resort_sorted_target_drives = array();
	$full_drives = array();

	$dfs = get_free_space_in_storage_pool_dirs();

	foreach ($storage_pool_directories as $target_drive) {
		if (!isset($dfs[$target_drive])) {
			continue;
		}
		$free_space = $dfs[$target_drive];
		$minimum_free_space = (float) (isset($minimum_free_space_pool_directories[$target_drive]) ? $minimum_free_space_pool_directories[$target_drive]*1024*1024 : 0.0);
		$available_space = (float) $free_space - $minimum_free_space;
		if ($available_space <= $filesize_kb) {
			if ($free_space > $filesize_kb) {
				while (isset($last_resort_sorted_target_drives[$free_space])) {
					$free_space -= 0.001;
				}
				$last_resort_sorted_target_drives[$available_space] = $target_drive;
			} else {
				while (isset($full_drives[$free_space])) {
					$free_space -= 0.001;
				}
				$full_drives[$free_space] = $target_drive;
			}
			continue;
		}
		while (isset($sorted_target_drives[$available_space])) {
			$available_space -= 0.001;
		}
		$sorted_target_drives[$available_space] = $target_drive;
	}
	if ($dir_selection_algorithm == 'most_available_space') {
		krsort($sorted_target_drives);
		krsort($last_resort_sorted_target_drives);
	}
	
	// Email notification when all dirs are over-capacity
	if (count($sorted_target_drives) == 0) {
		gh_log(WARN, "  Warning! All storage pool directories are over-capacity!");
		if (!isset($last_OOS_notification)) {
			$query = sprintf("SELECT value FROM settings WHERE name = '%s'", 'last_OOS_notification');
			$result = db_query($query) or gh_log(CRITICAL, "Can't query settings for 'last_OOS_notification': " . db_error());
			$row = db_fetch_object($result);
			if ($row === FALSE || db_fetch_object($result) !== FALSE) {
				gh_log(CRITICAL, "Received " . ($row === FALSE ? 'no rows' : 'more than one row') . " when querying settings for 'last_OOS_notification'; expected one.");
			}
			db_free_result($result);
			$last_OOS_notification = $row->value;
		}
		if ($last_OOS_notification < strtotime('-1 day')) {
			global $email_to;

			gh_log(INFO, "  Sending email notification to $email_to");

			$hostname = exec('hostname');
			$body = "This is an automated email from Greyhole.

It appears all the defined storage pool directories are over-capacity.
You probably want to do something about this!

";
			foreach ($last_resort_sorted_target_drives as $free_space => $target_drive) {
				$minimum_free_space = (int) (isset($minimum_free_space_pool_directories[$target_drive]) ? $minimum_free_space_pool_directories[$target_drive] : 0);
				$body .= "$target_drive has " . number_format($free_space/1024/1024, 2) . " GB free; minimum specified in greyhole.conf: $minimum_free_space GB.\n";
			}
			mail($email_to, "Greyhole is out of space on $hostname!", $body);
			
			$last_OOS_notification = time();
			$query = sprintf("UPDATE settings SET value = '%s' WHERE name = '%s'", $last_OOS_notification, 'last_OOS_notification');
			db_query($query) or gh_log(CRITICAL, "Can't update settings for 'last_OOS_notification': " . db_error());
		}
	}

	if ($dir_selection_algorithm == 'random') {
		shuffle($sorted_target_drives);
		shuffle($last_resort_sorted_target_drives);
	}
	
	global $log_level;
	if ($log_level === DEBUG) {
		if (count($sorted_target_drives) > 0) {
			$log = $log_prefix ."Drives with available space: ";
			foreach ($sorted_target_drives as $s => $d) {
				$log .= "$d (" . bytes_to_human($s*1024, FALSE) . " avail) - ";
			}
			gh_log(DEBUG, substr($log, 0, strlen($log)-2));
		}
		if (count($last_resort_sorted_target_drives) > 0) {
			$log = $log_prefix ."Drives with enough free space, but no available space: ";
			foreach ($last_resort_sorted_target_drives as $s => $d) {
				$log .= "$d (" . bytes_to_human($s*1024, FALSE) . " avail) - ";
			}
			gh_log(DEBUG, substr($log, 0, strlen($log)-2));
		}
		if (count($full_drives) > 0) {
			$log = $log_prefix ."Drives full: ";
			foreach ($full_drives as $s => $d) {
				$log .= "$d (" . bytes_to_human($s*1024, FALSE) . " free) - ";
			}
			gh_log(DEBUG, substr($log, 0, strlen($log)-2));
		}
	}
	
	$drives = array_merge($sorted_target_drives, $last_resort_sorted_target_drives);
	if ($include_full_drives) {
		$drives = array_merge($drives, $full_drives);
	}

	if (isset($sticky_files)) {
		foreach ($sticky_files as $share_dir => $stick_into) {
			if (strpos("$share/$path", $share_dir) === 0) {
				$more_drives_needed = FALSE;
				if (count($stick_into) > 0) {
					// Stick files into specific drives: $stick_into
					// Let's check if those drives are listed in the config file!
					foreach ($stick_into as $key => $stick_into_dir) {
						if (array_search($stick_into_dir, $storage_pool_directories) === FALSE) {
							unset($stick_into[$key]);
							$more_drives_needed = TRUE;
						}
					}
				}
				if (count($stick_into) == 0 || $more_drives_needed) {
					// Stick files into any drives
					$query = sprintf("SELECT value FROM settings WHERE name = 'stick_into-%s'",
						db_escape_string($share_dir)
					);
					$result = db_query($query) or gh_log(CRITICAL, "Can't query settings for stick_target-$share_dir: " . db_error());
					$row = db_fetch_object($result);
					if ($row !== FALSE) {
						$stick_into = array_merge($stick_into, unserialize($row->value));
						// Let's check if those drives are listed in the config file!
						$update_needed = FALSE;
						foreach ($stick_into as $key => $stick_into_dir) {
							if (array_search($stick_into_dir, $storage_pool_directories) === FALSE) {
								unset($stick_into[$key]);
								$update_needed = TRUE;
							}
						}
						if ($update_needed) {
							$value = serialize($stick_into);
							$query = sprintf("UPDATE settings SET value = '%s' WHERE name = 'stick_into-%s'",
								db_escape_string($value),
								db_escape_string($share_dir)
							);
							db_query($query) or gh_log(CRITICAL, "Can't update settings for stick_into-$share_dir: " . db_error());
						}
					} else {
						$value = serialize(array_merge($stick_into, $drives));
						$query = sprintf("INSERT INTO settings (name, value) VALUES ('stick_into-%s', '%s')",
							db_escape_string($share_dir),
							db_escape_string($value)
						);
						db_query($query) or gh_log(CRITICAL, "Can't insert new settings for stick_into-$share_dir: " . db_error());
						return array_merge($stick_into, $drives);
					}
				}
				
				// Make sure the drives we want to use are not yet full
				$priority_drives = array();
				foreach ($stick_into as $stick_into_dir) {
					if (array_search($stick_into_dir, $full_drives) === FALSE && array_search($stick_into_dir, $storage_pool_directories) !== FALSE) {
						unset($drives[array_search($stick_into_dir, $drives)]);
						$priority_drives[] = $stick_into_dir;
					}
				}
				$drives = array_merge($priority_drives, $drives);
			}
		}
	}

	return $drives;
}

function gh_fsck($path, $share) {
	global $storage_pool_directories, $fsck_report;
	
	gh_log(DEBUG, "Entering $path");
	$fsck_report['landing_zone']['num_dirs']++;

	$list = array();
	$handle = opendir($path);
	if ($handle === FALSE) {
		gh_log(ERROR, "  Couldn't open $path to list content. Skipping...");
		return;
	}
	while (($filename = readdir($handle)) !== FALSE) {
		if ($filename != '.' && $filename != '..') {
			$full_path = "$path/$filename";
			$file_type = @filetype($full_path);
			if ($file_type == 'dir') {
				gh_fsck($full_path, $share);
			} else {
				$fsck_report['landing_zone']['num_files']++;
				gh_fsck_file($path, $filename, $file_type, 'landing_zone', $share);
			}
		}
	}
	closedir($handle);
}

function gh_fsck_graveyard($root, $path, $share) {
	global $fsck_report;
	
	gh_log(DEBUG, "Entering graveyard $root$path");
	if (!is_dir("$root$path")) {
		gh_log(DEBUG, "  Not a directory... Aborting.");
		return;
	}

	$handle = opendir("$root$path");
	while (($filename = readdir($handle)) !== FALSE) {
		if ($filename != '.' && $filename != '..') {
			if (@is_dir("$root$path/$filename")) {
				$fsck_report['graveyard']['num_dirs']++;
				gh_fsck_graveyard($root, "$path/$filename", $share);
			} else {
				// Found a tombstone
				$fsck_report['graveyard']['num_files']++;
				
				$path_parts = explode('/', $path);
				array_shift($path_parts);
				$share = array_shift($path_parts);
				$landing_zone = get_share_landing_zone($share);
				$local_path = $landing_zone . '/' . implode('/', $path_parts);
				
				// If file exists in landing zone, we already fsck-ed it in gh_fsck(); let's not repeat ourselves, shall we?
				if (!file_exists("$local_path/$filename")) {
					gh_fsck_file($local_path, $filename, FALSE, 'graveyard', $share);
				#} else {
				#	gh_log(DEBUG, "File $local_path/$filename was already checked.");
				}
			}
		}
	}
	closedir($handle);
}

function gh_fsck_file($path, $filename, $file_type, $source, $share) {
	global $storage_pool_directories, $fsck_report, $options;

	$landing_zone = get_share_landing_zone($share);

	$file_path = trim(substr($path, strlen($landing_zone)+1), '/');

	if ($file_type == 'file') {
		// Let's just add a 'write' task for this file; if it's a duplicate of an already pending task, it won't be processed twice, since the simplify function will remove such duplicates.
		gh_log(DEBUG, "$path/$filename is a file (not a symlink). Adding a new 'write' pending task for that file.");
		$query = sprintf("INSERT INTO tasks (action, share, full_path, complete) VALUES ('write', '%s', '%s', 'yes')",
			db_escape_string($share),
			db_escape_string(empty($file_path) ? $filename : clean_dir("$file_path/$filename"))
		);
		db_query($query) or gh_log(CRITICAL, "Can't insert write task: " . db_error());
		return;
	} else {
		if ($file_type == 'link' && !file_exists(readlink("$path/$filename"))) {
			// Link points to now gone copy; let's just remove it, and treat this as if the link was not there in the first place.
			unlink("$path/$filename");
			$file_type = FALSE;
		}
		if ($file_type === FALSE) {
			// Maybe this file was removed after fsck started, and thus shouldn't be re-created here!
			parse_samba_log(); global $action; $action = 'fsck';
			$query = sprintf("SELECT * FROM tasks WHERE action = 'unlink' AND share = '%s' AND full_path = '%s' AND complete = 'yes' LIMIT 1",
				db_escape_string($share),
				db_escape_string(empty($file_path) ? $filename : clean_dir("$file_path/$filename"))
			);
			$result = db_query($query) or gh_log(CRITICAL, "Can't select future unlink tasks: " . db_error());
			if (db_fetch_object($result) === FALSE) {
				gh_log(INFO, "$path/$filename is missing from the share directory. Will try to re-create it, if copies are available.");
				$fsck_report['not_in_landing']++;
			} else {
				// Newly deleted file; let's not do anything with it now.
				return;
			}
		}
	}

	$file_tombstones = array();
	$num_ok = 0;
	$file_copies_inodes = array();

	// Look for this file on all available drives
	foreach ($storage_pool_directories as $target_drive) {
		$clean_full_path = clean_dir("$target_drive/$share/$file_path/$filename");
		$inode_number = @fileinode($clean_full_path);
		if ($inode_number !== FALSE) {
			if (is_dir($clean_full_path)) {
				gh_log(DEBUG, "Found a directory that should be a file! Will try to remove it, if it's empty.");
				@rmdir($clean_full_path);
				continue;
			}

			gh_log(DEBUG, "Found $clean_full_path");

			if (!is_greyhole_owned_dir($target_drive)) {
				gh_log(DEBUG, "  Directory $target_drive is not part of the Greyhole storage pool anymore. The above file will not be counted as a valid file copy, but can be used to create a new valid copy.");
				$file_tombstones[$clean_full_path] = (object) array('path' => $clean_full_path, 'is_linked' => FALSE, 'state' => 'Gone');
			} else {
				$file_tombstones[$clean_full_path] = (object) array('path' => $clean_full_path, 'is_linked' => FALSE, 'state' => 'OK');
				$file_copies_inodes[$inode_number] = $clean_full_path;
				$num_ok++;
			}
			
			// Temp files leftovers of stopped Greyhole executions
			$temp_filename = get_temp_filename($clean_full_path);
			if (file_exists($temp_filename) && is_file($temp_filename)) {
				gh_log(INFO, "  Found temporary file $temp_filename ... deleting.");
				$fsck_report['temp_files'][] = $temp_filename;
				gh_recycle($temp_filename);
			}
		}
	}

	foreach (get_tombstones($share, $file_path, $filename, TRUE) as $tombstone) {
		$inode_number = @fileinode($tombstone->path);
		if ($inode_number === FALSE) {
			$tombstone->state = 'Gone';
			$tombstone->is_linked = FALSE;

			$root_path = str_replace(clean_dir("/$share/$file_path/$filename"), '', $tombstone->path);
			if (gone_ok($root_path)) {
				// Let's not replace this copy yet...
				$file_copies_inodes[$tombstone->path] = $tombstone->path;
				$num_ok++;
				$fsck_report['gone_ok']++;
			}
		} else if (is_dir($tombstone->path)) {
			gh_log(DEBUG, "Found a directory that should be a file! Will try to remove it, if it's empty.");
			@rmdir($tombstone->path);
			$tombstone->state = 'Gone';
			$tombstone->is_linked = FALSE;
			continue;
		} else {
			$tombstone->state = 'OK';
			if (!isset($file_tombstones[$tombstone->path])) {
				$file_copies_inodes[$inode_number] = $tombstone->path;
				$num_ok++;
			}
		}
		$file_tombstones[clean_dir($tombstone->path)] = $tombstone;
	}

	if (count($file_copies_inodes) > 0) {
		// If no tombstone is linked, link the 1st one
		$found_linked_tombstone = FALSE;
		foreach ($file_tombstones as $key => $tombstone) {
			if ($tombstone->is_linked) {
				if (file_exists($tombstone->path)) {
					$found_linked_tombstone = TRUE;
					$expected_file_size = filesize($tombstone->path);
					$original_file_path = $tombstone->path;
					break;
				} else {
					$tombstone->is_linked = FALSE;
					$tombstone->state = 'Gone';
				}
			}
		}
		if (!$found_linked_tombstone) {
			$first_tombstone = reset($file_tombstones);
			$first_tombstone->is_linked = TRUE;
			$expected_file_size = filesize($first_tombstone->path);
			$original_file_path = $first_tombstone->path;
		}
		
		if (isset($options['disk-usage-report'])) {
			global $du;
			$du_path = '/' . trim(clean_dir("/$share/$file_path"), '/');
			do {
				if (!isset($du[$du_path])) {
					$du[$du_path] = 0;
				}
				$du[$du_path] += $expected_file_size;
				$du_path = substr($du_path, 0, strrpos($du_path, '/'));
			} while (!empty($du_path));
		}
		
		// Check that all file copies have the same size
		foreach ($file_copies_inodes as $key => $real_full_path) {
			if (array_search($real_full_path, array_keys($file_copies_inodes)) !== FALSE) {
				// That file isn't available atm, but it's OK.
				continue;
			}
			$file_size = filesize($real_full_path);
			if ($file_size != $expected_file_size && real_file_is_locked($real_full_path) === FALSE && real_file_is_locked($original_file_path) === FALSE) {
				if ($file_size == 0) {
					// Empty file; just delete it.
					gh_log(WARN, "  An empty file copy was found: $real_full_path is 0 bytes. Original: $original_file_path is " . number_format($expected_file_size) . " bytes. This empty copy will be deleted.");
					unlink($real_full_path);
				} else {
					gh_log(WARN, "  A file copy with a different file size than the original was found: $real_full_path is " . number_format($file_size) . " bytes. Original: $original_file_path is " . number_format($expected_file_size) . " bytes.");
					$fsck_report['wrong_file_size'][clean_dir($real_full_path)] = array($file_size, $expected_file_size, $original_file_path);
				}
				// Will not count that copy as a valid copy!
				unset($file_copies_inodes[$key]);
			}
		}
	}

	$num_copies_required = get_num_copies($share);
	
	if (count($file_copies_inodes) == $num_copies_required) {
		if (!$found_linked_tombstone || $file_type != 'link') {
			// Re-create symlink...
			if (!$found_linked_tombstone) {
				// ... the old one points to a drive that was replaced
				gh_log(INFO, '  Symlink target moved. Updating symlink.');
				$fsck_report['symlink_target_moved']++;
			} else {
				// ... it was missing
				gh_log(INFO, '  Symlink was missing. Creating new symlink.');
			}
			foreach ($file_tombstones as $key => $tombstone) {
				if ($tombstone->is_linked) {
					gh_log(DEBUG, "  Updating symlink at $landing_zone/$file_path/$filename to point to $tombstone->path");
					gh_recycle("$landing_zone/$file_path/$filename");
					gh_mkdir("$landing_zone/$file_path", "$landing_zone", null);
					symlink($tombstone->path, "$landing_zone/$file_path/$filename");
					break;
				}
			}
			save_tombstones($share, $file_path, $filename, array_values($file_tombstones));
		}
	} else if (count($file_copies_inodes) == 0 && !isset($original_file_path)) {
		gh_log(WARN, '  WARNING! No copies of this file are available. Deleting from share.');
		gh_recycle("$landing_zone/$file_path/$filename");
		if ($source == 'graveyard') {
			$fsck_report['not_in_landing']--;
		}
		if ($source == 'graveyard' || get_tombstone_data_filename($share, $file_path, $filename) !== FALSE) {
			$fsck_report['no_copies_found_files'][clean_dir("$share/$file_path/$filename")] = TRUE;
		}
		save_tombstones($share, $file_path, $filename, array_values($file_tombstones));
	} else if (count($file_copies_inodes) < $num_copies_required) {
		// Create new copies
		gh_log(INFO, "  Missing file copies. Expected $num_copies_required, got " . count($file_copies_inodes) . ". Will create more copies using $original_file_path");
		$fsck_report['missing_copies']++;
		clearstatcache(); $filesize = filesize("$original_file_path");
		$file_tombstones = create_tombstones($share, "$file_path/$filename", $num_copies_required, $filesize, $file_tombstones);

		// Re-copy the file everywhere, and re-create the symlink
		$symlink_created = FALSE;
		foreach ($file_tombstones as $key => $tombstone) {
			if ($original_file_path != $tombstone->path) {
				list($tombstone_dir_path, $tombstone_filename) = explode_full_path($tombstone->path);

				if ($tombstone->state == 'Gone') {
					foreach ($storage_pool_directories as $target_drive) {
						if (strpos($tombstone_dir_path, $target_drive) === 0 && is_greyhole_owned_dir($target_drive)) {
							$tombstone->state = 'Pending';
							$file_tombstones[$key] = $tombstone;
							break;
						}
					}
				}

				if ($tombstone->state != 'Gone') {
					$root_path = str_replace(clean_dir("/$share/$file_path"), '', $tombstone_dir_path);
					list($original_path, $tombstone_filename) = explode_full_path(get_share_landing_zone($share) . "/$file_path");
					if (!gh_mkdir($tombstone_dir_path, "$root_path/$share", $original_path)) {
						$tombstone->state = 'Gone';
						$file_tombstones[$key] = $tombstone;
						continue;
					}
				}
				
				if (!is_dir($tombstone_dir_path) || $tombstone->state == 'Gone') {
					continue;
				}

				if ($tombstone->state == 'Pending') {
					gh_log(DEBUG, "  Copying file to $tombstone->path");
					$temp_path = get_temp_filename($tombstone->path);
					if (copy($original_file_path, $temp_path)) {
						rename($temp_path, $tombstone->path);
						gh_chperm($tombstone->path, gh_get_file_infos($original_file_path));
						$tombstone->state = 'OK';
					} else {
						gh_log(WARN, "    Failed file copy. Skipping.");
						if ($tombstone->is_linked) {
							$tombstone->is_linked = FALSE;
						}
						$tombstone->state = 'Gone';
					}
					$file_tombstones[$key] = $tombstone;
				}
			}
			if ($tombstone->is_linked) {
				if ($symlink_created /* already */) {
					$tombstone->is_linked = FALSE;
					$file_tombstones[$key] = $tombstone;
					continue;
				}
				gh_log(DEBUG, "  Updating symlink at $landing_zone/$file_path/$filename to point to $tombstone->path");
				gh_recycle("$landing_zone/$file_path/$filename");
				gh_mkdir("$landing_zone/$file_path", "$landing_zone", null);
				symlink($tombstone->path, "$landing_zone/$file_path/$filename");
				$symlink_created = TRUE;
			}
		}
		save_tombstones($share, $file_path, $filename, array_values($file_tombstones));
	} else {
		# Let's not assume that files on missing drives are really there... Removing files here could be dangerous!
		foreach ($file_copies_inodes as $inode => $path) {
			if (!is_numeric($inode)) {
				unset($file_copies_inodes[$inode]);
			}
		}
		if (count($file_copies_inodes) > $num_copies_required) {
			gh_log(INFO, "  Too many file copies. Expected $num_copies_required, got " . count($file_copies_inodes) . ". Will try to remove some.");
			if (file_is_locked($share, "$file_path/$filename") !== FALSE) {
				gh_log(INFO, "  File is locked. Will not remove copies at this time. The next fsck will try to remove copies again.");
				return;
			}
			$fsck_report['too_many_copies']++;
		
			$local_target_drives = array_values(order_target_drives(0, TRUE, $share, $file_path));
			while (count($file_copies_inodes) > $num_copies_required && !empty($local_target_drives)) {
				$target_drive = array_pop($local_target_drives);
				$key = clean_dir("$target_drive/$share/$file_path/$filename");
				gh_log(DEBUG, "  Looking for copy at $key");
				if (isset($file_tombstones[$key]) || gh_file_exists($key)) {
					if (isset($file_tombstones[$key])) {
						$tombstone = $file_tombstones[$key];
					}
					if (gh_file_exists($key) || $tombstone->state == 'OK') {
						gh_log(DEBUG, "    Found file copy at $key, or tombstone is marked OK.");
						if (real_file_is_locked($key) !== FALSE) {
							gh_log(DEBUG, "    File copy is locked. Won't remove it.");
							continue;
						}
						$fsck_report['too_many_files'][] = $key;
						gh_log(DEBUG, "    Removing copy at $key");
						unset($file_copies_inodes[fileinode($key)]);
						gh_recycle($key);
						if (isset($file_tombstones[$key])) {
							unset($file_tombstones[$key]);
						}
						$num_ok--;
					}
				}
			}

			// If no tombstone is linked, link the 1st one
			$found_linked_tombstone = FALSE;
			foreach ($file_tombstones as $key => $tombstone) {
				if ($tombstone->is_linked) {
					$found_linked_tombstone = TRUE;
					break;
				}
			}
			if (!$found_linked_tombstone) {
				$tombstone = reset($file_tombstones);
				gh_log(DEBUG, "  Updating symlink at $landing_zone/$file_path/$filename to point to $tombstone->path");
				gh_recycle("$landing_zone/$file_path/$filename");
				gh_mkdir("$landing_zone/$file_path", "$landing_zone", null);
				symlink($tombstone->path, "$landing_zone/$file_path/$filename");
				reset($file_tombstones)->is_linked = TRUE;
			}

			save_tombstones($share, $file_path, $filename, array_values($file_tombstones));
		}
	}
}

function initialize_fsck_report($what) {
	global $fsck_report;
	$fsck_report = array();
	$fsck_report['start'] = time();
	$fsck_report['what'] = $what;
	$fsck_report['graveyard'] = array();
	$fsck_report['graveyard']['num_dirs'] = 0;
	$fsck_report['graveyard']['num_files'] = 0;
	$fsck_report['landing_zone'] = array();
	$fsck_report['landing_zone']['num_dirs'] = 0;
	$fsck_report['landing_zone']['num_files'] = 0;
	$fsck_report['not_in_landing'] = 0;
	$fsck_report['no_copies_found_files'] = array();
	$fsck_report['symlink_target_moved'] = 0;
	$fsck_report['too_many_copies'] = 0;
	$fsck_report['too_many_files'] = array();
	$fsck_report['missing_copies'] = 0;
	$fsck_report['wrong_file_size'] = array();
	$fsck_report['temp_files'] = array();
	$fsck_report['gone_ok'] = 0;
}

function get_fsck_report() {
	global $fsck_report, $storage_pool_directories, $gone_ok_drives;
	
	$fsck_report['end'] = time();
	
	$displayable_duration = duration_to_human($fsck_report['end'] - $fsck_report['start']);
	
	$report = "fsck report
-----------
Scanned directory: " . $fsck_report['what'] . "

Started:  " . date('Y-m-d H:i:s', $fsck_report['start']) . "
Ended:    " . date('Y-m-d H:i:s', $fsck_report['end']) . "
Duration: $displayable_duration

Graveyard:
  Found " . number_format($fsck_report['graveyard']['num_dirs']) . " directories
  Found " . number_format($fsck_report['graveyard']['num_files']) . " files

Landing Zone (shares):
  Found " . number_format($fsck_report['landing_zone']['num_dirs']) . " directories
  Found " . number_format($fsck_report['landing_zone']['num_files']) . " files

Attic size:\n";

	foreach ($storage_pool_directories as $dir) {
		$attic_path = clean_dir("$dir/.gh_attic");
		if (is_dir($attic_path)) {
			$report .= "  $attic_path = " . trim(exec("du -sh " . quoted_form($attic_path) . " | awk '{print $1}'"))."\n";
		} else {
			$report .= "  $attic_path = empty\n";
		}
	}

	// Errors
	if (empty($fsck_report['no_copies_found_files']) && count($fsck_report['wrong_file_size']) == 0) {
		$report .= "\nNo problems found.\n\n";
	} else {
		$report .= "\nProblems:\n";

		if (!empty($fsck_report['no_copies_found_files'])) {
			ksort($fsck_report['no_copies_found_files']);
			$report .= "  Found " . count($fsck_report['no_copies_found_files']) . " files in the graveyard for which no file copies were found.
    Those files were removed from the Landing Zone. (i.e. those files are now gone!) They will re-appear in your shares if a copy re-appear and fsck is run.
    If you don't want to see those files listed here each time fsck runs, delete the corresponding files from the graveyard.
  Files with no copies:\n";
			$report .= "    " . implode("\n    ", array_keys($fsck_report['no_copies_found_files'])) . "\n\n";
		}

		if (count($fsck_report['wrong_file_size']) > 0) {
			$report .= "  Found " . count($fsck_report['wrong_file_size']) . " file copies with the wrong file size. Those files don't have the same file size as the original files available on your shares. You should manually remove the invalid copies.\n";
			foreach ($fsck_report['wrong_file_size'] as $real_file_path => $info_array) {
				$report .= "    $real_file_path is " . number_format($info_array[0]) . " bytes; should be " . number_format($info_array[1]) . " bytes.\n";
			}
			$report .= "\n\n";
		}
	}

	// Warnings
	if ($fsck_report['too_many_copies'] == 0 && $fsck_report['symlink_target_moved'] == 0 && $fsck_report['not_in_landing'] == 0 && count($fsck_report['temp_files']) == 0 && $fsck_report['gone_ok'] == 0) {
		// Nothing to say...
	} else {
		$report .= "Notices:\n";

		if ($fsck_report['too_many_copies'] > 0) {
			$fsck_report['too_many_files'] = array_unique($fsck_report['too_many_files']);
		
			$report .= "  Found " . $fsck_report['too_many_copies'] . " files for which there was too many file copies. Deleted (or moved in attic) files:\n";
			$report .= "    " . implode("\n    ", $fsck_report['too_many_files']) . "\n\n";
		}

		if ($fsck_report['symlink_target_moved'] > 0) {
			$report .= "  Found " . $fsck_report['symlink_target_moved'] . " files in the Landing Zone that were pointing to a now gone copy.
    Those symlinks were updated to point to the new location of those file copies.\n\n";
		}

		if ($fsck_report['not_in_landing'] > 0) {
			$report .= "  Found " . $fsck_report['not_in_landing'] . " files that were not in the Landing Zone.
    Symlinks were created in the Landing Zone to point to those files.\n\n";
		}
	
		if (count($fsck_report['temp_files']) > 0) {
			$report .= "  Found " . count($fsck_report['temp_files']) . " temporary files, which are leftovers of interrupted Greyhole executions. The following temporary files were deleted (or moved into the attic):\n";
			$report .= "    " . implode("\n    ", $fsck_report['temp_files']) . "\n\n";
		}
	
		if ($fsck_report['gone_ok'] > 0) {
			$report .= "  Found " . $fsck_report['gone_ok'] . " missing files that are in a storage pool directory marked Temporarily-Gone.
  If this directory is gone for good, you should execute the following command, and remove the directory from your configuration file:
    greyhole --gone <path>
  where <path> is one of:\n";
	    	$report .= "    " . implode("\n    ", array_keys($gone_ok_drives)) . "\n\n";
		}
	}

	return $report;
}

function gh_recycle($real_path) {
	$is_symlink = FALSE;
	clearstatcache();
	if (is_link($real_path)) {
		$is_symlink = TRUE;
	} else if (!file_exists($real_path)) {
		return TRUE;
	}

	$should_move_to_attic = FALSE;
	if (!$is_symlink) {
		global $storage_pool_directories, $delete_moves_to_attic, $shares_options;
		
		$share_options = get_share_options_from_full_path($real_path);
		if ($share_options !== FALSE) {
			$full_path = trim($share_options['name'] . "/" . str_replace($share_options['landing_zone'], '', $real_path), '/');
			$share = substr($full_path, 0, strpos($full_path, '/'));
		} else {
			foreach ($storage_pool_directories as $dir) {
				if (strpos($real_path, $dir) === 0) {
					$attic_path = "$dir/.gh_attic";
					$full_path = trim(str_replace($dir, '', $real_path), '/');
					break;
				}
			}

			$share = substr($full_path, 0, strpos($full_path, '/'));

			if (isset($shares_options[$share]['delete_moves_to_attic'])) {
				$should_move_to_attic = $shares_options[$share]['delete_moves_to_attic'];
			} else {
				$should_move_to_attic = $delete_moves_to_attic;
			}
		}
	}
	
	if ($should_move_to_attic) {
		// Move to attic
		if (!isset($attic_path)) {
			gh_log(WARN, "  Warning! Can't find attic for $real_path. Won't delete this file!");
			return FALSE;
		}
		
		$target_path = clean_dir("$attic_path/$full_path");

		list($path, $filename) = explode_full_path($target_path);
		
		list($original_path, $filename) = explode_full_path(get_share_landing_zone($share) . "/$full_path");
		
		gh_mkdir($path, "$attic_path/$share", $original_path);

		if (@rename($real_path, $target_path)) {
			gh_log(DEBUG, "  Moved copy from $real_path to attic: $target_path");
			return TRUE;
		}
	} else {
		if (@unlink($real_path)) {
			if (!$is_symlink) {
				gh_log(DEBUG, "  Deleted copy at $real_path");
			}
			return TRUE;
		}
	}
	return FALSE;
}

function repair_tables() {
	if (@$db_use_mysql) {
		db_query("REPAIR TABLE tasks") or gh_log(CRITICAL, "Can't repair tasks table: " . db_error());
		db_query("REPAIR TABLE tasks_completed") or gh_log(CRITICAL, "Can't repair tasks_completed table: " . db_error());
		db_query("REPAIR TABLE settings") or gh_log(CRITICAL, "Can't repair settings table: " . db_error());
	}
}

function check_storage_pool_dirs() {
	global $storage_pool_directories, $email_to, $gone_ok_drives;
	$hostname = exec('hostname');
	$needs_fsck = FALSE;
	$i = 0; $j = 0;
	foreach ($storage_pool_directories as $target_drive) {
		if (!is_greyhole_owned_dir($target_drive) && !gone_fscked($target_drive, $i++ == 0)) {
			$needs_fsck = 1;
			mark_gone_drive_fscked($target_drive);
			gh_log(WARN, "Warning! It seems $target_drive is missing it's \".greyhole_uses_this\" file. This either means this mount is currently unmounted, or you forgot to create this file.");
			$body = "This is an automated email from Greyhole.

It appears one of your storage pool directory is missing it's \".greyhole_uses_this\" file:
  $target_drive/.greyhole_uses_this: File not found

This either means this mount is currently unmounted, or you forgot to create this file.

Here are your options:

- If you forgot to create this file, you should create it ASAP, as per the INSTALL instructions. Until you do, this directory will not be part of your storage pool.

- If the mount is gone, you should either re-mount it manually (if possible), or remove it from your configuration file, if you know it is gone for good.

- If you know this mount will come back soon, and do NOT want Greyhole to re-create missing file copies for this directory until it reappears, you should execute this command:
  greyhole --wait-for ".quoted_form($target_drive)."

A fsck will now start, to fix the symlinks found in your shares, when possible.
You'll receive a report email once that fsck run completes.
";
			mail($email_to, 'Missing storage pool directory on ' . $hostname . ': ' . $target_drive, $body);
			gh_log(DEBUG, "Email sent for gone dir: $target_drive");
			$gone_ok_drives[$target_drive] = TRUE; // The upcoming fsck should not recreate missing copies just yet
		} else if ((gone_ok($target_drive, $j++ == 0) || gone_fscked($target_drive, $i++ == 0)) && is_greyhole_owned_dir($target_drive)) {
			// $target_drive is now back
			$needs_fsck = 2;
			$body = "This is an automated email from Greyhole.

It appears one of your storage pool directory came back:
  $target_drive was missing; it's now available again.

A fsck will now start, to fix the symlinks found in your shares, when possible.
You'll receive a report email once that fsck run completes.
";
			mail($email_to, 'Storage pool directory now online on ' . $hostname . ': ' . $target_drive, $body);
			gh_log(DEBUG, "Email sent for revived dir: $target_drive");

			mark_gone_ok($target_drive, 'remove');
			mark_gone_drive_fscked($target_drive, 'remove');
			$i = 0; $j = 0;
		}
	}
	
	if ($needs_fsck !== FALSE) {
		global $shares_options;
		if ($needs_fsck === 1) {
			gh_log(INFO, "Starting fsck for all shares - caused by missing drive. Will just recreate symlinks to existing copies when possible; won't create new copies just yet.");
		} else {
			gh_log(INFO, "Starting fsck for all shares - caused by missing drive that came back online.");
		}
		initialize_fsck_report('All shares');
		clearstatcache();

		foreach ($shares_options as $share_name => $share_options) {
			gh_fsck($share_options['landing_zone'], $share_name);
		}
		foreach (get_graveyards() as $graveyard) {
			foreach ($shares_options as $share_name => $share_options) {
				gh_fsck_graveyard($graveyard, "/$share_name", $share_name);
			}
		}
		gh_log(INFO, "fsck for all shares completed.");

		$fsck_report = get_fsck_report();
		gh_log(DEBUG, "Sending fsck report to $email_to");
		mail($email_to, 'fsck of Greyhole shares on ' . $hostname, $fsck_report);

		// Refresh $gone_ok_drives to it's real value (from the DB)
		get_gone_ok_dirs();
	}
}

// Is it OK for a drive to be gone?
function gone_ok($target_drive, $refresh=FALSE) {
	global $gone_ok_drives;
	if ($refresh || !isset($gone_ok_drives)) {
		$gone_ok_drives = get_gone_ok_dirs();
	}
	if (isset($gone_ok_drives[$target_drive])) {
		return TRUE;
	}
	return FALSE;
}

function get_gone_ok_dirs() {
	global $gone_ok_drives;
	$query = sprintf("SELECT value FROM settings WHERE name = 'Gone-OK-Drives'");
	$result = db_query($query) or gh_log(CRITICAL, "Can't query settings for Gone-OK-Drives: " . db_error());
	$row = db_fetch_object($result);
	if ($row !== FALSE) {
		$gone_ok_drives = unserialize($row->value);
	} else {
		$query = "INSERT INTO settings (name, value) VALUES ('Gone-OK-Drives', 'a:0:{}')";
		db_query($query) or gh_log(CRITICAL, "Can't insert new settings for Gone-OK-Drives: " . db_error());
		$gone_ok_drives = array();
	}
	return $gone_ok_drives;
}

function mark_gone_ok($target_drive, $action='add') {
	global $storage_pool_directories;
	if (!array_search($target_drive, $storage_pool_directories)) {
		return FALSE;
	}

	global $gone_ok_drives;
	$gone_ok_drives = get_gone_ok_dirs();
	if ($action == 'add') {
		$gone_ok_drives[$target_drive] = TRUE;
	} else {
		unset($gone_ok_drives[$target_drive]);
	}

	$query = sprintf("UPDATE settings SET value = '%s' WHERE name = 'Gone-OK-Drives'",
		db_escape_string(serialize($gone_ok_drives))
	);
	db_query($query) or gh_log(CRITICAL, "Can't save settings for Gone-OK-Drives: " . db_error());
	return TRUE;
}

function gone_fscked($target_drive, $refresh=FALSE) {
	global $fscked_gone_drives;
	if ($refresh || !isset($fscked_gone_drives)) {
		$fscked_gone_drives = get_fsck_gone_drives();
	}
	if (isset($fscked_gone_drives[$target_drive])) {
		return TRUE;
	}
	return FALSE;
}

function get_fsck_gone_drives() {
	global $fscked_gone_drives;
	$query = sprintf("SELECT value FROM settings WHERE name = 'Gone-FSCKed-Drives'");
	$result = db_query($query) or gh_log(CRITICAL, "Can't query settings for Gone-FSCKed-Drives: " . db_error());
	$row = db_fetch_object($result);
	if ($row !== FALSE) {
		$fscked_gone_drives = unserialize($row->value);
	} else {
		$query = "INSERT INTO settings (name, value) VALUES ('Gone-FSCKed-Drives', 'a:0:{}')";
		db_query($query) or gh_log(CRITICAL, "Can't insert new settings for Gone-FSCKed-Drives: " . db_error());
		$fscked_gone_drives = array();
	}
	return $fscked_gone_drives;
}

function mark_gone_drive_fscked($target_drive, $action='add') {
	global $fscked_gone_drives;
	$fscked_gone_drives = get_fsck_gone_drives();
	if ($action == 'add') {
		$fscked_gone_drives[$target_drive] = TRUE;
	} else {
		unset($fscked_gone_drives[$target_drive]);
	}

	$query = sprintf("UPDATE settings SET value = '%s' WHERE name = 'Gone-FSCKed-Drives'",
		db_escape_string(serialize($fscked_gone_drives))
	);
	db_query($query) or gh_log(CRITICAL, "Can't save settings for Gone-FSCKed-Drives: " . db_error());
}

function get_graveyards() {
	global $storage_pool_directories;
	$graveyards = array();
	foreach ($storage_pool_directories as $target_drive) {
		if (is_greyhole_owned_dir($target_drive)) {
			$graveyards[] = "$target_drive/.gh_graveyard";
		}
	}
	return $graveyards;
}

function get_share_options_from_full_path($full_path) {
	global $shares_options;
	$landing_zone = '';
	$share = FALSE;
	foreach ($shares_options as $share_name => $share_options) {
		if (strpos($full_path, $share_options['landing_zone']) === 0 && strlen($share_options['landing_zone']) > strlen($landing_zone)) {
			$landing_zone = $share_options['landing_zone'];
			$share = $share_options;
		}
	}
	return $share;
}

function gh_get_file_infos($real_path) {
	if ($real_path == null || !file_exists($real_path)) {
		return (object) array(
			'fileowner' => 0,
			'filegroup' => 0,
			'fileperms' => (int) base_convert("0755", 8, 10)
		);
	}
	return (object) array(
		'fileowner' => (int) fileowner($real_path),
		'filegroup' => (int) filegroup($real_path),
		'fileperms' => (int) base_convert(substr(decoct(fileperms($real_path)), -4), 8, 10)
	);
}

function gh_get_dir_perms($directory) {
	return (int) base_convert(substr(decoct(fileperms($directory)), -4), 8, 10);
}

function gh_balance() {
	global $storage_pool_directories, $shares_options;

	// Move files from the share with the less available space to the share with the most available space.
	$sorted_pool_drives = sort_storage_dirs_available_space();
	$pool_drives_avail_space = array();
	foreach ($sorted_pool_drives as $available_space => $drive) {
		$pool_drives_avail_space[$drive] = $available_space;
	}

	foreach ($sorted_pool_drives as $source_drive) {
		$target_avail_space = array_sum($pool_drives_avail_space) / count($pool_drives_avail_space);
		gh_log(DEBUG, "Balancing storage pool directory: $source_drive (". bytes_to_human($pool_drives_avail_space[$source_drive]*1024, FALSE) ." available, target: ". bytes_to_human($target_avail_space*1024, FALSE) .")");

		// Start with the shares for which we keep the most # copies;
		// That way, if the new drive fails soon, it won't take with it files for which we only have one copy!
		$sorted_shares_options = $shares_options;
		uasort($sorted_shares_options, 'compare_share_num_copies');
		foreach ($sorted_shares_options as $share_name => $share_options) {
			if ($share_options['num_copies'] == count($storage_pool_directories)) {
				// Files are everywhere; won't be able to use that share to balance available space!
				continue;
			}

	 		gh_log(DEBUG, "Balancing share: $share_name");

			// Files candidate to get moved
			unset($files);
			exec("find ". quoted_form("$source_drive/$share_name") ." -type f | head -n 100000", $files);
			gh_log(DEBUG, "Found ". count($files) ." files that can be moved.");
			
			// Repeat until all drives' available space is balanced.
			$file_everywhere_counter = 0;
			foreach ($files as $file) {
				$filesize = filesize($file)/1024; // KB

				$full_path = substr($file, strlen("$source_drive/$share_name/"));
				list($path, $filename) = explode_full_path($full_path);
				gh_log(DEBUG, "  Working on file: $full_path (". bytes_to_human($filesize*1024, FALSE) .")");

				$target_drives = order_target_drives($filesize, FALSE, $share_name, $path, '  ');

				unset($target_drive);
				while (count($target_drives) > 0) {
					$drive = array_shift($target_drives);
					if (!file_exists("$drive/$share_name/$full_path")) {
						$target_drive = $drive;
						break;
					}
				}
				if (!isset($target_drive)) {
					// Can't find a drive that doesn't have this file; skipping.
					continue;
				}

				gh_log(DEBUG, "  Target drive: $target_drive (". bytes_to_human($pool_drives_avail_space[$target_drive]*1024, FALSE) ." available)");

				if ($pool_drives_avail_space[$source_drive]+$filesize+1*1024*1024 /*1GB*/ > $pool_drives_avail_space[$target_drive]-$filesize
						|| $pool_drives_avail_space[$source_drive]+$filesize > $target_avail_space
						|| $pool_drives_avail_space[$target_drive] < $target_avail_space) {
					gh_log(DEBUG, "  Moving this file wouldn't help balancing available space. Skipping.");
					continue;
				}

				// Make sure the parent directory exists, before we try moving something there...
				$original_path = clean_dir("$source_drive/$share_name/$path");
				list($target_path, $filename) = explode_full_path("$target_drive/$share_name/$full_path");
				gh_mkdir($target_path, "$target_drive/$share_name", $original_path);

				// Move the file
				$temp_path = get_temp_filename("$target_drive/$share_name/$full_path");
				$file_infos = gh_get_file_infos($file);
				gh_log(DEBUG, "  Moving file copy...");
				$it_worked = rename($file, $temp_path);
				if ($it_worked) {
					rename($temp_path, "$target_drive/$share_name/$full_path");
					gh_chperm("$target_drive/$share_name/$full_path", $file_infos);

					$pool_drives_avail_space[$target_drive] -= $filesize;
					$pool_drives_avail_space[$source_drive] += $filesize;
				} else {
					gh_log(WARN, "    Failed file copy. Skipping.");
					gh_recycle($temp_path);
					continue;
				}

				// Update tombstones
				$existing_tombstones = get_tombstones($share_name, $path, $filename, FALSE, TRUE, FALSE);
				foreach ($existing_tombstones as $key => $tombstone) {
					if ($tombstone->path == $file) {
						$tombstone->path = "$target_drive/$share_name/$full_path";
						unset($existing_tombstones[$key]);
						$tombstone->state = 'OK';
						if ($tombstone->is_linked) {
							// Re-create correct symlink
							$landing_zone = $share_options['landing_zone'];
							if (is_link("$landing_zone/$full_path")) {
								gh_log(DEBUG, "  Updating symlink at $landing_zone/$full_path to point to $tombstone->path");
								if (gh_recycle("$landing_zone/$full_path")) {
			 						@symlink($tombstone->path, "$landing_zone/$full_path");
									// Creating this symlink can fail if the parent dir was removed
								}
							}
						}
						$existing_tombstones[$tombstone->path] = $tombstone;
						save_tombstones($share_name, $path, $filename, $existing_tombstones);
						break;
					}
				}
				
				$target_avail_space = array_sum($pool_drives_avail_space) / count($pool_drives_avail_space);
				gh_log(DEBUG, "Balancing storage pool directory: $source_drive (". bytes_to_human($pool_drives_avail_space[$source_drive]*1024, FALSE) ." available, target: ". bytes_to_human($target_avail_space*1024, FALSE) .")");
			}
			gh_log(DEBUG, "Done balancing share: $share_name");
		}
		gh_log(DEBUG, "Done balancing storage pool directory: $source_drive (". bytes_to_human($pool_drives_avail_space[$source_drive]*1024, FALSE) ." available)");
	}
}

function compare_share_num_copies($a, $b) {
	if ($a['num_copies'] == $b['num_copies']) {
		return 0;
	}
	return $a['num_copies'] > $b['num_copies'] ? -1 : 1;
}

function sort_storage_dirs_available_space() {
	global $storage_pool_directories, $minimum_free_space_pool_directories;
	$dfs = get_free_space_in_storage_pool_dirs();
	foreach ($storage_pool_directories as $target_drive) {
		if (!isset($dfs[$target_drive])) {
			continue;
		}
		$free_space = $dfs[$target_drive];
		$minimum_free_space = (float) (isset($minimum_free_space_pool_directories[$target_drive]) ? $minimum_free_space_pool_directories[$target_drive]*1024*1024 : 0.0);
		$available_space = (float) $free_space - $minimum_free_space;
		$sorted_target_drives[$available_space] = $target_drive;
	}
	ksort($sorted_target_drives);
	return $sorted_target_drives;
}

function postpone_task($task_id, $complete='yes') {
	global $sleep_before_task;
	$query = sprintf("INSERT INTO tasks (action, share, full_path, additional_info, complete) (SELECT action, share, full_path, additional_info, '%s' FROM tasks WHERE id = %d)",
		db_escape_string($complete),
		$task_id
	);
	db_query($query) or gh_log(CRITICAL, "Error inserting postponed task: " . db_error());
	$sleep_before_task[] = db_insert_id();
}
?>
