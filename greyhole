#!/usr/bin/env php
<?php
/*
Copyright 2009-2012 Guillaume Boudreau, Andrew Hopkinson

This file is part of Greyhole.

Greyhole is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Greyhole is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Greyhole.  If not, see <http://www.gnu.org/licenses/>.
*/

include('includes/common.php');

// Tasks
include('includes/Tasks/Task.php');
include('includes/Tasks/BalanceTask.php');
include('includes/Tasks/FsckTask.php');
include('includes/Tasks/FsckFileTask.php');
include('includes/Tasks/MD5Task.php');
include('includes/Tasks/MakeDirectoryTask.php');
include('includes/Tasks/RemoveDirectoryTask.php');
include('includes/Tasks/WriteFileTask.php');
include('includes/Tasks/RenameFileTask.php');
include('includes/Tasks/RemoveFileTask.php');

// Database helpers
include('includes/AbstractDatabaseHelper.php');
include('includes/DatabaseHelperSQLite.php');
include('includes/DatabaseHelperMySQL.php');

// Command line helper (abstract classes, command line definitions & parsing, etc.)
include('includes/CLI/CommandLineHelper.php');

// Other helpers
include('includes/Log.php');
include('includes/SambaHelper.php');
include('includes/Settings.php');
include('includes/MigrationHelper.php');
include('includes/Metastore.php');

// This will parse the command line, and find commands and options.
// It will then instantiate the appropriate class (that extends AbstractRunner), and return it.
$cliHelper = new CommandLineHelper();
$runner = $cliHelper->processCommandLine();

// This will run the runner(!) i.e. what the user asked for will now be executed.
$runner->run();

// The runner has finished; let's clean up before quitting.
$runner->finish();

function gh_file_exists($real_path) {
	clearstatcache();
	return file_exists($real_path);
}

function get_num_copies($share) {
	global $shares_options, $storage_pool_drives;
	if (!isset($shares_options[$share]['num_copies'])) {
		global $config_file;
		Log::warn("Found a task on a share ($share) that disappeared from $config_file. Skipping.");
		return -1;
	}
	$num_copies = $shares_options[$share]['num_copies'];
	if ($num_copies < 1) {
		$num_copies = 1;
	}
	$max_copies = 0;
	foreach ($storage_pool_drives as $sp_drive) {
		if (StoragePoolHelper::is_drive_ok($sp_drive)) {
			$max_copies++;
		}
	}
	if ($num_copies > $max_copies) {
		$num_copies = $max_copies;
	}
	return $num_copies;
}

function file_is_locked($share, $full_path) {
	global $check_for_open_files;
	if (isset($check_for_open_files) && $check_for_open_files === FALSE) {
		Log::debug("  Skipping open file (lock) check.");
		return FALSE;
	}
	
	$landing_zone = get_share_landing_zone($share);
	if (!$landing_zone) {
		return FALSE;
	}
	
	$real_fullpath = "$landing_zone/$full_path";
	if (is_link($real_fullpath)) {
		$real_fullpath = readlink($real_fullpath);
	}
	$result = exec("lsof -M -n -P -l " . escapeshellarg($real_fullpath) . " 2> /dev/null");
	if (mb_strpos($result, $real_fullpath) !== FALSE) {
		return $result;
	}
	$query = sprintf("SELECT * FROM tasks WHERE complete = 'no' AND action = 'write' AND share = '%s' AND full_path = '%s' LIMIT 1",
		DB::escape_string($share),
		DB::escape_string($full_path)
	);
	$result = DB::query($query) or Log::critical("Error querying tasks for locked files: " . DB::error());
	
	if (DB::fetch_object($result) === FALSE) {
		return FALSE;
	}
	
	// Locked, according to DB... But maybe it's not really locked?
	if (!gh_file_exists($real_fullpath)) {
		// File doesn't exists anymore... It can't be really locked... Let's assume this is just Samba that 'forgot' to close the file handle.
		$query = sprintf("UPDATE tasks WHERE SET complete = 'yes' WHERE complete = 'no' AND action = 'write' AND share = '%s' AND full_path = '%s'",
			DB::escape_string($share),
			DB::escape_string($full_path)
		);
		DB::query($query) or Log::critical("Error updating locked files tasks: " . DB::error());
		return FALSE;
	}

	return TRUE;
}

function real_file_is_locked($real_fullpath) {
	if (is_link($real_fullpath)) {
		$real_fullpath = readlink($real_fullpath);
	}
	$result = exec("lsof -M -n -P -l " . escapeshellarg($real_fullpath) . " 2> /dev/null");
	if (mb_strpos($result, $real_fullpath) !== FALSE) {
		return $result;
	}
	return FALSE;
}

function find_future_full_path($share, $full_path, $task_id) {
	$new_full_path = $full_path;
	while ($next_task = find_next_rename_task($share, $new_full_path, $task_id)) {
		if ($next_task->full_path == $full_path) {
			// File was renamed
			$new_full_path = $next_task->additional_info;
		} else {
			// A parent directory was renamed
			$new_full_path = preg_replace("@^$next_task->full_path@", $next_task->additional_info, $new_full_path);
		}
		$task_id = $next_task->id;
	}
	return $new_full_path;
}

function find_next_rename_task($share, $full_path, $task_id) {
	$full_paths = array();
	$full_paths[] = $full_path;
	$parent_full_path = $full_path;
	list($parent_full_path, $basename) = explode_full_path($parent_full_path);
	while (strlen($parent_full_path) > 1) {
		$full_paths[] = $parent_full_path;
		list($parent_full_path, $basename) = explode_full_path($parent_full_path);
	}
	$query = sprintf("SELECT * FROM tasks WHERE complete = 'yes' AND share = '%s' AND action = 'rename' AND full_path IN ('%s') AND id > %s ORDER BY id LIMIT 1",
		DB::escape_string($share),
		implode("','", array_map(array('DB', 'escape_string'), $full_paths)),
		DB::escape_string($task_id)
	);
	$result = DB::query($query) or Log::critical("Can't select to find next task: " . DB::error());
	return DB::fetch_object($result);
}

function gh_chperm($real_file_path, $file_infos) {
	chmod($real_file_path, $file_infos->fileperms);
	chown($real_file_path, $file_infos->fileowner);
	chgrp($real_file_path, $file_infos->filegroup);
}

function gh_mkdir($directory, $original_directory_or_dir_infos) {
	if (!is_dir($directory)) {
		if (is_string($original_directory_or_dir_infos)) {
			$dir_infos = gh_get_file_infos($original_directory_or_dir_infos);
		} else {
			$dir_infos = $original_directory_or_dir_infos;
		}
		
		// Need to mkdir & chown/chgrp all dirs that don't exists, up to the full path ($directory)
		$dir_parts = explode('/', $directory);
		
		$i = 0;
		$parent_directory = clean_dir('/' . $dir_parts[$i++]);
		while (is_dir($parent_directory) && $i < count($dir_parts)) {
			$parent_directory = clean_dir($parent_directory . '/' . $dir_parts[$i++]);
		}
		while ($i <= count($dir_parts)) {
			if (!is_dir($parent_directory) && !@mkdir($parent_directory, $dir_infos->fileperms)) {
				if (gh_is_file($parent_directory)) {
					gh_rename($parent_directory, "$parent_directory (file copy)");
				}
				if (!mkdir($parent_directory, $dir_infos->fileperms)) {
					Log::warn("  Failed to create directory $parent_directory");
					return FALSE;
				}
			}
			if (!chown($parent_directory, $dir_infos->fileowner)) {
				Log::warn("  Failed to chown directory '$parent_directory'");
			}
			if (!chgrp($parent_directory, $dir_infos->filegroup)) {
				Log::warn("  Failed to chgrp directory '$parent_directory'");
			}
			if (!isset($dir_parts[$i])) {
				break;
			}
			$parent_directory = clean_dir($parent_directory . '/' . $dir_parts[$i++]);
		}
	}
	return TRUE;
}

function get_temp_filename($full_path) {
	list($path, $filename) = explode_full_path($full_path);
	return "$path/.$filename." . mb_substr(md5($filename), 0, 5);
}

function is_temp_file($full_path) {
	list($path, $filename) = explode_full_path($full_path);
	if (preg_match("/^\.(.+)\.([0-9a-f]{5})$/", $filename, $regs)) {
		$md5_stem = mb_substr(md5($regs[1]), 0, 5);
		return ($md5_stem == $regs[2]);
	}
	return FALSE;
}

function get_free_space_in_storage_pool_drives() {
	global $storage_pool_drives, $df_command, $last_df_time, $last_dfs, $df_cache_time;
	if ($last_df_time > time() - $df_cache_time) {
		return $last_dfs;
	}
	$dfs = array();
	exec($df_command, $responses);
	$responses_arr = array();
	foreach ($responses as $line) {
		if (preg_match("@\s+[0-9]+\s+([0-9]+)\s+([0-9]+)\s+[0-9]+%\s+(.+)$@", $line, $regs)) {
				$responses_arr[] = array((float) $regs[1], (float) $regs[2], $regs[3]);
		}
	}
	$responses = $responses_arr;
	foreach ($storage_pool_drives as $sp_drive) {
		$target_drive = '';
		for ($i=0; $i<count($responses); $i++) {
			$used_space = $responses[$i][0];
			$free_space = $responses[$i][1];
			$mount = $responses[$i][2];
			if (mb_strpos($sp_drive, $mount) === 0 && mb_strlen($mount) > mb_strlen($target_drive)) {
				$target_drive = $mount;
				$target_freespace = $free_space;
				$target_usedspace = $used_space;
			}
		}
		$dfs[$sp_drive]['free'] = $target_freespace;
		$dfs[$sp_drive]['used'] = $target_usedspace;
	}
	$last_df_time = time();
	$last_dfs = $dfs;
	return $dfs;
}

function order_target_drives($filesize_kb, $include_full_drives, $share, $path, $log_prefix='') {
	global $storage_pool_drives, $minimum_free_space_pool_drives, $last_OOS_notification, $sticky_files, $shares_options;
	$sorted_target_drives = array();
	$last_resort_sorted_target_drives = array();
	$full_drives = array();

	foreach ($shares_options[$share]['drive_selection_algorithm'] as $ds) {
		$algo = $ds->selection_algorithm;
		break;
	}

	$dfs = get_free_space_in_storage_pool_drives();

	$sorted_target_drives = array('available_space' => array(), 'used_space' => array());
	$last_resort_sorted_target_drives = array('available_space' => array(), 'used_space' => array());
	foreach ($storage_pool_drives as $sp_drive) {
		if (!isset($dfs[$sp_drive])) {
			if (!is_dir($sp_drive)) {
				Log::error("The directory at $sp_drive doesn't exist. This drive will never be used!");
				if (file_exists('/usr/bin/hdactl')) {
					Log::error("You should de-select, then re-select this partition in your Amahi dashboard (http://hda), in the Shares > Storage Pool page, to fix this problem.");
				} else {
					Log::error("See the INSTALL file for instructions on how to prepare partitions to include in your storage pool.");
				}
			} else {
				Log::error("Can't find how much free space is left on $sp_drive. This partition will never be used!");
				Log::error("Please report this using the 'Bugs Tracker' link found on http://greyhole.net. You should include the following information in your ticket:");
				Log::error("===== Error report starts here =====");
				Log::error("Unknown free space for partition: $sp_drive");
				global $df_command;
				Log::error("df_command: $df_command");
				unset($responses);
				exec($df_command, $responses);
				Log::error("Result of df_command: " . var_export($responses, TRUE));
				unset($responses);
				exec('df -k 2>&1', $responses);
				Log::error("Result of df -k: " . var_export($responses, TRUE));
				Log::error("===== Error report ends here =====");
			}
			continue;
		}
		if (!StoragePoolHelper::is_drive_ok($sp_drive)) {
			continue;
		}
		$free_space = $dfs[$sp_drive]['free'];
		$used_space = $dfs[$sp_drive]['used'];
		$minimum_free_space = (float) (isset($minimum_free_space_pool_drives[$sp_drive]) ? $minimum_free_space_pool_drives[$sp_drive]*1024*1024 : 0.0);
		$available_space = (float) $free_space - $minimum_free_space;
		if ($available_space <= $filesize_kb) {
			if ($free_space > $filesize_kb) {
				$last_resort_sorted_target_drives['available_space'][$sp_drive] = $available_space;
				$last_resort_sorted_target_drives['used_space'][$sp_drive] = $used_space;
			} else {
				$full_drives[$sp_drive] = $free_space;
			}
			continue;
		}
		$sorted_target_drives['available_space'][$sp_drive] = $available_space;
		$sorted_target_drives['used_space'][$sp_drive] = $used_space;
	}

	foreach ($shares_options[$share]['drive_selection_algorithm'] as $ds) {
		$s = $sorted_target_drives;
		$l = $last_resort_sorted_target_drives;
		$ds->init($s, $l);
	}
	$sorted_target_drives = $s;
	$last_resort_sorted_target_drives = $l;

	$sorted_target_drives = array();
	$last_resort_sorted_target_drives = array();
	$got_all_drives = FALSE;
	while (!$got_all_drives) {
		$num_empty_ds = 0;
		foreach ($shares_options[$share]['drive_selection_algorithm'] as $ds) {
			list($drives, $drives_last_resort) = $ds->draft();
			foreach ($drives as $sp_drive => $space) {
				$sorted_target_drives[$sp_drive] = $space;
			}
			foreach ($drives_last_resort as $sp_drive => $space) {
				$last_resort_sorted_target_drives[$sp_drive] = $space;
			}
			if (count($drives) == 0 && count($drives_last_resort) == 0) {
				$num_empty_ds++;
			}
		}
		if ($num_empty_ds == count($shares_options[$share]['drive_selection_algorithm'])) {
			// All DS are empty; exit.
			$got_all_drives = TRUE;
			break;
		}
	}
	
	// Email notification when all drives are over-capacity
	if (count($sorted_target_drives) == 0) {
		Log::warn("  Warning! All storage pool drives are over-capacity!");
		if (!isset($last_OOS_notification)) {
			$setting = Settings::get('last_OOS_notification');
			if ($setting === FALSE) {
				Log::warn("Received no rows when querying settings for 'last_OOS_notification'; expected one.");
				$setting = Settings::set('last_OOS_notification', 0);
			}
			$last_OOS_notification = $setting;
		}
		if ($last_OOS_notification < strtotime('-1 day')) {
			global $email_to;

			Log::info("  Sending email notification to $email_to");

			$hostname = exec('hostname');
			$body = "This is an automated email from Greyhole.

It appears all the defined storage pool drives are over-capacity.
You probably want to do something about this!

";
			foreach ($last_resort_sorted_target_drives as $sp_drive => $free_space) {
				$minimum_free_space = (int) (isset($minimum_free_space_pool_drives[$sp_drive]) ? $minimum_free_space_pool_drives[$sp_drive] : 0);
				$body .= "$sp_drive has " . number_format($free_space/1024/1024, 2) . " GB free; minimum specified in greyhole.conf: $minimum_free_space GB.\n";
			}
			mail($email_to, "Greyhole is out of space on $hostname!", $body);
			
			$last_OOS_notification = time();
			Settings::set('last_OOS_notification', $last_OOS_notification);
		}
	}
	
	if (Log::$level >= DEBUG) {
		if (count($sorted_target_drives) > 0) {
			$log = $log_prefix ."Drives with available space: ";
			foreach ($sorted_target_drives as $sp_drive => $space) {
				$log .= "$sp_drive (" . bytes_to_human($space*1024, FALSE) . " " . ($algo == 'most_available_space' ? 'avail' : 'used') . ") - ";
			}
			Log::debug(mb_substr($log, 0, mb_strlen($log)-2));
		}
		if (count($last_resort_sorted_target_drives) > 0) {
			$log = $log_prefix ."Drives with enough free space, but no available space: ";
			foreach ($last_resort_sorted_target_drives as $sp_drive => $space) {
				$log .= "$sp_drive (" . bytes_to_human($space*1024, FALSE) . " " . ($algo == 'most_available_space' ? 'avail' : 'used') . ") - ";
			}
			Log::debug(mb_substr($log, 0, mb_strlen($log)-2));
		}
		if (count($full_drives) > 0) {
			$log = $log_prefix ."Drives full: ";
			foreach ($full_drives as $sp_drive => $free_space) {
				$log .= "$sp_drive (" . bytes_to_human($free_space*1024, FALSE) . " free) - ";
			}
			Log::debug(mb_substr($log, 0, mb_strlen($log)-2));
		}
	}
	
	$drives = array_merge(array_keys($sorted_target_drives), array_keys($last_resort_sorted_target_drives));
	if ($include_full_drives) {
		$drives = array_merge($drives, array_keys($full_drives));
	}

	if (isset($sticky_files)) {
		global $is_sticky;
		$is_sticky = FALSE;
		foreach ($sticky_files as $share_dir => $stick_into) {
			if (gh_wild_mb_strpos("$share/$path", $share_dir) === 0) {
				$is_sticky = TRUE;

 				$more_drives_needed = FALSE;
				if (count($stick_into) > 0) {
					// Stick files into specific drives: $stick_into
					// Let's check if those drives are listed in the config file!
					foreach ($stick_into as $key => $stick_into_dir) {
						if (array_search($stick_into_dir, $storage_pool_drives) === FALSE) {
							unset($stick_into[$key]);
							$more_drives_needed = TRUE;
						}
					}
				}
				if (count($stick_into) == 0 || $more_drives_needed) {
					if (mb_strpos($share_dir, '*') !== FALSE) {
						// Contains a wildcard... In this case, we want each directory that match the wildcard to have it's own setting. Let's find this directory...
						// For example, if $share_dir == 'Videos/Movies/*/*' and "$share/$path/" == "Videos/Movies/HD/La Vita e Bella/", we want to save a 'stick_into' setting for 'Videos/Movies/HD/La Vita e Bella/'
						// Files in other subdirectories of Videos/Movies/HD/ could end up in other drives.
						$needles = explode('*', $share_dir);
						$sticky_dir = '';
						$wild_part = "$share/$path/";
						for ($i=0; $i<count($needles); $i++) {
							$needle = $needles[$i];
							if ($i == 0) {
								$sticky_dir = $needle;
								$wild_part = @str_replace_first($needle, '', $wild_part);
							} else {
								if ($needle == '') {
									$needle = '/';
								}
								$small_wild_part = mb_substr($wild_part, 0, mb_strpos($wild_part, $needle)+mb_strlen($needle));
								$sticky_dir .= $small_wild_part;
								$wild_part = str_replace_first($small_wild_part, '', $wild_part);
							}
						}
						$sticky_dir = trim($sticky_dir, '/');
					} else {
						$sticky_dir = $share_dir;
					}

					// Stick files into any drives
					$setting_name = sprintf('stick_into-%s', $sticky_dir);
					$setting = Settings::get($setting_name, TRUE);
					if ($setting) {
						$stick_into = array_merge($stick_into, $setting);
						// Let's check if those drives are listed in the config file!
						$update_needed = FALSE;
						foreach ($stick_into as $key => $stick_into_dir) {
							if (array_search($stick_into_dir, $storage_pool_drives) === FALSE) {
								unset($stick_into[$key]);
								$update_needed = TRUE;
							}
						}
						if ($update_needed) {
							$value = serialize($stick_into);
							Settings::set($setting_name, $value);
						}
					} else {
						$value = array_merge($stick_into, $drives);
						Settings::set($setting_name, $value);
					}
				}
				
				// Make sure the drives we want to use are not yet full
				$priority_drives = array();
				foreach ($stick_into as $stick_into_dir) {
					if (array_search($stick_into_dir, $full_drives) === FALSE && array_search($stick_into_dir, $storage_pool_drives) !== FALSE) {
						unset($drives[array_search($stick_into_dir, $drives)]);
						$priority_drives[] = $stick_into_dir;
					}
				}
				$drives = array_merge($priority_drives, $drives);
				Log::debug($log_prefix . "Reordered drives, per sticky_files config: " . implode(' - ', $drives));
				break;
			}
		}
	}

	return $drives;
}

function gh_fsck($path, $share, $storage_path = FALSE) {
	global $storage_pool_drives, $fsck_report;
	
	Log::debug("Entering $path");
	$fsck_report['landing_zone']['num_dirs']++;

	$list = array();
	$handle = opendir($path);
	if ($handle === FALSE) {
		Log::error("  Couldn't open $path to list content. Skipping...");
		return;
	}
	while (($filename = readdir($handle)) !== FALSE) {
		if ($filename != '.' && $filename != '..') {
			$full_path = "$path/$filename";
			$file_type = @filetype($full_path);
			if ($file_type === FALSE) {
				// Try NFC form [http://en.wikipedia.org/wiki/Unicode_equivalence#Normalization]
				$file_type = @filetype(normalize_utf8_characters($full_path));
				if ($file_type !== FALSE) {
					// Bingo!
					$full_path = normalize_utf8_characters($full_path);
					$path = normalize_utf8_characters($path);
					$filename = normalize_utf8_characters($filename);
				}
			}
			if ($file_type == 'dir') {
				gh_fsck($full_path, $share, $storage_path);
			} else {
				gh_fsck_file($path, $filename, $file_type, 'landing_zone', $share, $storage_path);
			}
		}
	}
	closedir($handle);
}

function gh_fsck_metastore($root, $path, $share) {
	global $fsck_report;
	
	if (!is_dir("$root$path")) {
		return;
	}
	Log::debug("Entering metastore " . clean_dir($root . $path));

	$handle = opendir("$root$path");
	while (($filename = readdir($handle)) !== FALSE) {
		if ($filename != '.' && $filename != '..') {
			if (@is_dir("$root$path/$filename")) {
				$fsck_report['metastore']['num_dirs']++;
				gh_fsck_metastore($root, "$path/$filename", $share);
			} else {
				// Found a metafile
				$path_parts = explode('/', $path);
				array_shift($path_parts);
				$share = array_shift($path_parts);
				$landing_zone = get_share_landing_zone($share);
				$local_path = $landing_zone . '/' . implode('/', $path_parts);
				
				// If file exists in landing zone, we already fsck-ed it in gh_fsck(); let's not repeat ourselves, shall we?
				if (!file_exists("$local_path/$filename")) {
					gh_fsck_file($local_path, $filename, FALSE, 'metastore', $share);
				}
			}
		}
	}
	closedir($handle);
}

function gh_fsck_file($path, $filename, $file_type, $source, $share, $storage_path = FALSE) {
	global $storage_pool_drives, $fsck_report, $options, $shares_options;
	$share_options = $shares_options[$share];
	$landing_zone = get_share_landing_zone($share);
	if($storage_path === FALSE) {
		$file_path = trim(mb_substr($path, mb_strlen($landing_zone)+1), '/');
	}else{
		$file_path = trim(mb_substr($path, mb_strlen("$storage_path/$share")+1), '/');
	}
	if ($file_type === FALSE) {
		clearstatcache();
		// Try NFC form [http://en.wikipedia.org/wiki/Unicode_equivalence#Normalization]
		$file_type = @filetype(normalize_utf8_characters("$path/$filename"));
		if ($file_type !== FALSE) {
			// Bingo!
			$file_path = normalize_utf8_characters($file_path);
			$path = normalize_utf8_characters($path);
			$filename = normalize_utf8_characters($filename);
		}
	}
	if ($source == 'metastore') {
		$fsck_report['metastore']['num_files']++;
	}
	if ($file_type !== FALSE) {
		$fsck_report['landing_zone']['num_files']++;
	}
	if ($file_type == 'file') {
		if($storage_path === FALSE) {
			// Let's just add a 'write' task for this file; if it's a duplicate of an already pending task, it won't be processed twice, since the simplify function will remove such duplicates.
			Log::info("$path/$filename is a file (not a symlink). Adding a new 'write' pending task for that file.");
			$query = sprintf("INSERT INTO tasks (action, share, full_path, complete) VALUES ('write', '%s', '%s', 'yes')",
				DB::escape_string($share),
				DB::escape_string(clean_dir("$file_path/$filename"))
			);
			DB::query($query) or Log::critical("Can't insert write task: " . DB::error());
			return;
		}
	} else {
		if ($source == 'metastore') {
			if ($file_type == 'link' && !file_exists(readlink("$path/$filename"))) {
				// Link points to now gone copy; let's just remove it, and treat this as if the link was not there in the first place.
				unlink("$path/$filename");
				$file_type = FALSE;
			}
			if ($file_type === FALSE) {
				if (!Log::action_equals('fsck_file')) {
					// Maybe this file was removed after fsck started, and thus shouldn't be re-created here!
					// We'll queue this file fsck (to restore the symlink) for when all other file operations have been executed.
					Log::debug("  Queuing a new fsck_file task for " . clean_dir("$share/$file_path/$filename"));
					$query = sprintf("INSERT INTO tasks (action, share, full_path, complete, additional_info) VALUES ('fsck_file', '%s', '%s', 'idle', '%s')",
						DB::escape_string($share),
						DB::escape_string(empty($file_path) ? $filename : clean_dir("$file_path/$filename")),
						@$options['all-fsck-options']
					);
					DB::query($query) or Log::critical("Can't insert write task: " . DB::error());
					return;
				}
			}
		}
	}
	
	if (Metastore::first_metafile_filename_for_file("$share/$file_path/$filename") === FALSE && Metastore::first_metafile_filename_for_file("$share/" . normalize_utf8_characters($file_path) . "/" . normalize_utf8_characters($filename)) === FALSE) {
		$full_path = clean_dir("$path/$filename");

		// Check if this is a temporary file; if so, just delete it.
		if (is_temp_file($full_path)) {
			$fsck_report['temp_files'][] = $full_path;
			gh_recycle($full_path);
			return;
		}

		if ($storage_path !== FALSE) {
			if (@$options['find-orphans']) {
				Log::info("$full_path is an orphaned file; we'll proceed to find all copies and symlink this file appropriately.");
				$fsck_report['orphaned']['num_orphans']++;
			} else {
				Log::info("$full_path is an orphaned file, but we're not looking for orphans. For Greyhole to recognize this file, initiate a fsck with the --find-orphaned-files option.");
				return;
			}
		}
	}

	// Look for this file on all available drives
	$file_metafiles = array();
	$file_copies_inodes = get_file_inodes($share, $file_path, $filename, $file_metafiles);
	if (count($file_metafiles) == 0) {
		// If we found 0 file copies the first time, we normalize the file path (using NFC) and try again.
		// Ref: http://en.wikipedia.org/wiki/Unicode_equivalence#Normalization
		$file_copies_inodes = get_file_inodes($share, normalize_utf8_characters($file_path), normalize_utf8_characters($filename), $file_metafiles);
		if (count($file_metafiles) > 0) {
			// Bingo!
			$file_path = normalize_utf8_characters($file_path);
			$filename = normalize_utf8_characters($filename);
		}
	}
	
	$num_ok = count($file_copies_inodes);
	if ($num_ok == 0 && count($file_metafiles) > 0) {
		// We found 1+ files, but none or them are on a defined storage drive; we can still use them as the source to create additional copies.
		$metadata = reset($file_metafiles);
		$original_file_path = $metadata->path;
	}

	foreach (Metastore::metafiles_for_file($share, $file_path, $filename, METAFILES_OPTION_LOAD_NOK) as $metafile_block) {
		foreach ($metafile_block as $metafile) {
			$root_path = str_replace(clean_dir("/$share/$file_path/$filename"), '', $metafile->path);
			$inode_number = @gh_fileinode($metafile->path);
			if (is_link($metafile->path)) {
				$link_target = readlink($metafile->path);
				if (array_search($link_target, $file_copies_inodes) !== FALSE) {
					// This link points to another file copy. Bad, bad!
					Log::warn("Warning! Found a symlink in your storage pool: $metafile->path -> $link_target. Deleting.");
					gh_recycle($metafile->path);
				}
				$inode_number = FALSE;
			}
			if ($inode_number === FALSE || !StoragePoolHelper::is_drive_ok($root_path)) {
				$metafile->state = 'Gone';
				$metafile->is_linked = FALSE;
				if (gone_ok($root_path)) {
					// Let's not replace this copy yet...
					$file_copies_inodes[$metafile->path] = $metafile->path;
					$num_ok++;
					$fsck_report['gone_ok']++;
				}
			} else if (is_dir($metafile->path)) {
				Log::debug("Found a directory that should be a file! Will try to remove it, if it's empty.");
				@rmdir($metafile->path);
				$metafile->state = 'Gone';
				$metafile->is_linked = FALSE;
				continue;
			} else {
				$metafile->state = 'OK';
				if (!isset($file_metafiles[$metafile->path])) {
					$file_copies_inodes[$inode_number] = $metafile->path;
					$num_ok++;
				}
			}
			$file_metafiles[clean_dir($metafile->path)] = $metafile;
		}
	}

	if (count($file_copies_inodes) > 0) {
		$found_linked_metafile = FALSE;
		foreach ($file_metafiles as $key => $metafile) {
			if ($metafile->is_linked) {
				if (file_exists($metafile->path)) {
					$found_linked_metafile = TRUE;
					$expected_file_size = gh_filesize($metafile->path);
					$original_file_path = $metafile->path;
					break;
				} else {
					$metafile->is_linked = FALSE;
					$metafile->state = 'Gone';
				}
			}
		}
		// If no metafile is linked, link the 1st one (that is OK)
		if (!$found_linked_metafile) {
			foreach ($file_metafiles as $first_metafile) {
				$root_path = str_replace(clean_dir("/$share/$file_path/$filename"), '', $first_metafile->path);
				if ($first_metafile->state == 'OK' && StoragePoolHelper::is_drive_ok($root_path)) {
					$first_metafile->is_linked = TRUE;
					$expected_file_size = gh_filesize($first_metafile->path);
					$original_file_path = $first_metafile->path;
					break;
				}
			}
		}
		
		if (@$options['disk-usage-report']) {
			global $du;
			$du_path = '/' . trim(clean_dir("/$share/$file_path"), '/');
			do {
				if (!isset($du[$du_path])) {
					$du[$du_path] = 0;
				}
				$du[$du_path] += $expected_file_size;
				$du_path = mb_substr($du_path, 0, mb_strrpos($du_path, '/'));
			} while (!empty($du_path));
		}
		
		// Check that all file copies have the same size
		foreach ($file_copies_inodes as $key => $real_full_path) {
			if (array_search($real_full_path, array_keys($file_copies_inodes)) !== FALSE) {
				// That file isn't available atm, but it's OK.
				continue;
			}
			$file_size = gh_filesize($real_full_path);
			if ($file_size != $expected_file_size) {
				// Found a file with a different size than the original...
				// There might be a good reason. Let's look for one!
				if (real_file_is_locked($real_full_path) !== FALSE || real_file_is_locked($original_file_path) !== FALSE) {
					// Write operation in progress
					continue;
				}
				// A pending write transaction maybe?
				SambaHelper::process_spool(FALSE);
				$query = sprintf("SELECT * FROM tasks WHERE action = 'write' AND share = '%s' AND full_path = '%s'",
					DB::escape_string($share),
					DB::escape_string("$file_path/$filename")
				);
				$result = DB::query($query) or Log::critical("Can't select for pending writes" . DB::error());
				if (DB::fetch_object($result) !== FALSE) {
					// Pending write task
					continue;
				}
				// Found no good reason!

				if ($file_size == 0) {
					// Empty file; just delete it.
					Log::warn("  An empty file copy was found: $real_full_path is 0 bytes. Original: $original_file_path is " . number_format($expected_file_size) . " bytes. This empty copy will be deleted.");
					unlink($real_full_path);
				} else {
					Log::warn("  A file copy with a different file size than the original was found: $real_full_path is " . number_format($file_size) . " bytes. Original: $original_file_path is " . number_format($expected_file_size) . " bytes.");
					gh_recycle($real_full_path);
					$fsck_report['wrong_file_size'][clean_dir($real_full_path)] = array($file_size, $expected_file_size, $original_file_path);
				}
				// Will not count that copy as a valid copy!
				unset($file_copies_inodes[$key]);
				unset($file_metafiles[clean_dir($real_full_path)]);
			}
		}
	}

	$num_copies_required = get_num_copies($share);
	
	if (count($file_copies_inodes) == $num_copies_required) {
		// It's okay if the file isn't a symlink so long as we're looking at a storage volume path and not a share path
		if (!$found_linked_metafile || ($file_type != 'link' && $storage_path === FALSE)) {
			// Re-create symlink...
			if (!$found_linked_metafile) {
				// ... the old one points to a drive that was replaced
				Log::info('  Symlink target moved. Updating symlink.');
				$fsck_report['symlink_target_moved']++;
			} else {
				// ... it was missing
				Log::info('  Symlink was missing. Creating new symlink.');
			}
			foreach ($file_metafiles as $key => $metafile) {
				if ($metafile->is_linked) {
					gh_fsck_update_symlink($metafile->path, "$landing_zone/$file_path/$filename", $share, $file_path, $filename);
					break;
				}
			}
			Metastore::save_metafiles($share, $file_path, $filename, $file_metafiles);
		}
	} else if (count($file_copies_inodes) == 0 && !isset($original_file_path)) {
		Log::warn('  WARNING! No copies of this file are available in the Greyhole storage pool. ' . (is_link("$landing_zone/$file_path/$filename") ? 'Deleting from share.' : (gh_is_file("$landing_zone/$file_path/$filename") ? 'Did you copy that file there without using your Samba shares? (If you did, don\'t do that in the future.)' : '')));
		if ($source == 'metastore' || Metastore::first_metafile_filename_for_file("$share/$file_path/$filename") !== FALSE) {
			$fsck_report['no_copies_found_files'][clean_dir("$share/$file_path/$filename")] = TRUE;
		}
		if (is_link("$landing_zone/$file_path/$filename")) {
			gh_recycle("$landing_zone/$file_path/$filename");
		} else if (gh_is_file("$landing_zone/$file_path/$filename")) {
			Log::info("$share/$file_path/$filename is a file (not a symlink). Adding a new 'write' pending task for that file.");
			$query = sprintf("INSERT INTO tasks (action, share, full_path, complete) VALUES ('write', '%s', '%s', 'yes')",
				DB::escape_string($share),
				DB::escape_string(empty($file_path) ? $filename : clean_dir("$file_path/$filename"))
			);
			DB::query($query) or Log::critical("Can't insert write task: " . DB::error());
		}
		if (@$options['del-orphaned-metadata']) {
			Metastore::remove_metafiles($share, $file_path, $filename);
		} else {
			Metastore::save_metafiles($share, $file_path, $filename, $file_metafiles);
		}
	} else if (count($file_copies_inodes) < $num_copies_required) {
		// Create new copies
		Log::info("  Missing file copies. Expected $num_copies_required, got " . count($file_copies_inodes) . ". Will create more copies using $original_file_path");
		if (isset($fsck_report['missing_copies'])) {
			$fsck_report['missing_copies']++;
		}
		clearstatcache(); $filesize = gh_filesize("$original_file_path");
		$file_metafiles = Metastore::create_metafiles($share, "$file_path/$filename", $num_copies_required, $filesize, $file_metafiles);

		// Re-copy the file everywhere, and re-create the symlink
		$symlink_created = FALSE;
		$num_copies_current = 1; # the source file
		global $going_drive;
		if (!empty($going_drive)) {
			// Let's not count the source file here, since it will be gone soon!
			$num_copies_current = 0;
		}
		foreach ($file_metafiles as $key => $metafile) {
			if ($original_file_path != $metafile->path) {
				if ($num_copies_current >= $num_copies_required) {
					$metafile->state = 'Gone';
					$file_metafiles[$key] = $metafile;
					continue;
				}

				list($metafile_dir_path, $metafile_filename) = explode_full_path($metafile->path);

				if ($metafile->state == 'Gone') {
					foreach ($storage_pool_drives as $sp_drive) {
						if (get_storage_volume_from_path($metafile_dir_path) == $sp_drive && StoragePoolHelper::is_drive_ok($sp_drive)) {
							$metafile->state = 'Pending';
							$file_metafiles[$key] = $metafile;
							break;
						}
					}
				}

				if ($metafile->state != 'Gone') {
					$root_path = str_replace(clean_dir("/$share/$file_path"), '', $metafile_dir_path);
					list($original_path, $metafile_filename) = explode_full_path(get_share_landing_zone($share) . "/$file_path");
					if (!gh_mkdir($metafile_dir_path, $original_path)) {
						$metafile->state = 'Gone';
						$file_metafiles[$key] = $metafile;
						continue;
					}
				}
				
				if (!is_dir($metafile_dir_path) || $metafile->state == 'Gone') {
					continue;
				}

				if ($metafile->state == 'Pending') {
					$source_size = gh_filesize($original_file_path);
					Log::debug("  Copying " . bytes_to_human($source_size, FALSE) . " file to $metafile->path");
					$temp_path = get_temp_filename($metafile->path);
					$start_time = time();
					exec(get_copy_cmd($original_file_path, $temp_path));
					$it_worked = file_exists($temp_path) && file_exists($original_file_path) && gh_filesize($temp_path) == gh_filesize($original_file_path);
					if ($it_worked) {
						if (time() - $start_time > 0) {
							$speed = number_format($source_size/1024/1024 / (time() - $start_time), 1);
							Log::debug("    Copy created at $speed MBps.");
						}
						gh_rename($temp_path, $metafile->path);
						gh_chperm($metafile->path, gh_get_file_infos($original_file_path));
						$metafile->state = 'OK';
						$num_copies_current++;
					} else {
						Log::warn("    Failed file copy. Skipping.");
						if ($metafile->is_linked) {
							$metafile->is_linked = FALSE;
						}
						$metafile->state = 'Gone';
					}
					$file_metafiles[$key] = $metafile;
				}
			}
			if ($original_file_path == $metafile->path || $metafile->is_linked) {
				if (!empty($going_drive) && get_storage_volume_from_path($original_file_path) == $going_drive) {
					$metafile->is_linked = FALSE;
					$metafile->state = 'Gone';
					$file_metafiles[$key] = $metafile;
					continue;
				}
				if ($symlink_created /* already */) {
					$metafile->is_linked = FALSE;
					$file_metafiles[$key] = $metafile;
					continue;
				}
				
				gh_fsck_update_symlink($metafile->path, "$landing_zone/$file_path/$filename", $share, $file_path, $filename);
				$symlink_created = TRUE;
			}
		}
		if (!$symlink_created) {
			foreach ($file_metafiles as $key => $metafile) {
				if ($metafile->state == 'OK') {
					$metafile->is_linked = TRUE;
					$file_metafiles[$key] = $metafile;
					gh_fsck_update_symlink($metafile->path, "$landing_zone/$file_path/$filename", $share, $file_path, $filename);
					break;
				}
			}
		}
		Metastore::save_metafiles($share, $file_path, $filename, $file_metafiles);
	} else {
		# Let's not assume that files on missing drives are really there... Removing files here could be dangerous!
		foreach ($file_copies_inodes as $inode => $path) {
			if (mb_strpos($inode, '/') === 0) {
				unset($file_copies_inodes[$inode]);
			}
		}
		if (count($file_copies_inodes) > $num_copies_required) {
			Log::info("  Too many file copies. Expected $num_copies_required, got " . count($file_copies_inodes) . ". Will try to remove some.");
			if (file_is_locked($share, "$file_path/$filename") !== FALSE) {
				Log::info("  File is locked. Will not remove copies at this time. The next fsck will try to remove copies again.");
				return;
			}
			$fsck_report['too_many_copies']++;
		
			$local_target_drives = array_values(order_target_drives(0, TRUE, $share, $file_path));
			while (count($file_copies_inodes) > $num_copies_required && !empty($local_target_drives)) {
				$sp_drive = array_pop($local_target_drives);
				$key = clean_dir("$sp_drive/$share/$file_path/$filename");
				Log::debug("  Looking for copy at $key");
				if (isset($file_metafiles[$key]) || gh_file_exists($key)) {
					if (isset($file_metafiles[$key])) {
						$metafile = $file_metafiles[$key];
					}
					if (gh_file_exists($key) || $metafile->state == 'OK') {
						Log::debug("    Found file copy at $key, or metadata file is marked OK.");
						if (real_file_is_locked($key) !== FALSE) {
							Log::debug("    File copy is locked. Won't remove it.");
							continue;
						}
						$fsck_report['too_many_files'][] = $key;
						Log::debug("    Removing copy at $key");
						unset($file_copies_inodes[gh_fileinode($key)]);
						gh_recycle($key);
						if (isset($file_metafiles[$key])) {
							unset($file_metafiles[$key]);
						}
						$num_ok--;
					}
				}
			}

			// If no metafile is linked, link the 1st one
			$found_linked_metafile = FALSE;
			foreach ($file_metafiles as $key => $metafile) {
				if ($metafile->is_linked) {
					$found_linked_metafile = TRUE;
					break;
				}
			}
			if (!$found_linked_metafile) {
				$metafile = reset($file_metafiles);
				gh_fsck_update_symlink($metafile->path, "$landing_zone/$file_path/$filename", $share, $file_path, $filename);
				reset($file_metafiles)->is_linked = TRUE;
			}

			Metastore::save_metafiles($share, $file_path, $filename, $file_metafiles);
		}
	}
	
	// Queue all file copies checksum calculations, if --checksums was specified
	if (@$options['verify-checksums']) {
		foreach (Metastore::metafiles_for_file($share, $file_path, $filename, METAFILES_OPTION_LOAD_NOK) as $metafile_block) {
			foreach ($metafile_block as $metafile) {
				if ($metafile->state != 'OK') { continue; }
				$inode_number = @gh_fileinode($metafile->path);
				if ($inode_number !== FALSE) {
					// Let's calculate this file's MD5 checksum to validate that all copies are valid.
					$query = sprintf("INSERT INTO tasks (action, share, full_path, additional_info, complete) VALUES ('md5', '%s', '%s', '%s', 'no')",
						DB::escape_string($share),
						DB::escape_string(clean_dir("$file_path/$filename")),
						DB::escape_string($metafile->path)
					);
					DB::query($query) or Log::critical("Can't insert md5 task: " . DB::error());
				}
			}
		}
	}
}

function gh_fsck_update_symlink($target, $symlink, $share, $file_path, $filename) {
	clearstatcache();
	if (!file_exists($symlink)) {
		Log::debug("  Missing symlink... A pending unlink transaction maybe?");
		SambaHelper::process_spool(FALSE);
		$query = sprintf("SELECT * FROM tasks WHERE action = 'unlink' AND share = '%s' AND full_path = '%s'",
			DB::escape_string($share),
			DB::escape_string(trim("$file_path/$filename", '/'))
		);
		$result = DB::query($query) or Log::critical("Can't select for pending unlink" . DB::error());
		if (DB::fetch_object($result) !== FALSE) {
			Log::debug("    Indeed! Pending unlink task found. Will not re-create this symlink.");
			return;
		}
		Log::debug("    No... Found no good reason for the symlink to be missing! Let's re-create it.");
	}
	
	Log::debug("  Updating symlink at $symlink to point to $target");
	gh_recycle($symlink);
	gh_mkdir(dirname($symlink), dirname($target));
	symlink($target, $symlink);
}

function initialize_fsck_report($what) {
	global $fsck_report;
	$fsck_report = array();
	$fsck_report['start'] = time();
	$fsck_report['what'] = $what;
	$fsck_report['metastore'] = array();
	$fsck_report['metastore']['num_dirs'] = 0;
	$fsck_report['metastore']['num_files'] = 0;
	$fsck_report['orphaned']['num_orphans'] = 0;
	$fsck_report['landing_zone'] = array();
	$fsck_report['landing_zone']['num_dirs'] = 0;
	$fsck_report['landing_zone']['num_files'] = 0;
	$fsck_report['no_copies_found_files'] = array();
	$fsck_report['symlink_target_moved'] = 0;
	$fsck_report['too_many_copies'] = 0;
	$fsck_report['too_many_files'] = array();
	$fsck_report['missing_copies'] = 0;
	$fsck_report['wrong_file_size'] = array();
	$fsck_report['temp_files'] = array();
	$fsck_report['gone_ok'] = 0;
}

function get_fsck_report() {
	global $fsck_report, $storage_pool_drives, $gone_ok_drives, $options;
	
	$fsck_report['end'] = time();
	
	$displayable_duration = duration_to_human($fsck_report['end'] - $fsck_report['start']);
	
	$report = "fsck report
-----------
Scanned directory: " . $fsck_report['what'] . "

Started:  " . date('Y-m-d H:i:s', $fsck_report['start']) . "
Ended:    " . date('Y-m-d H:i:s', $fsck_report['end']) . "
Duration: $displayable_duration

Metadata Store:
  Found " . number_format($fsck_report['metastore']['num_dirs']) . " directories
  Found " . number_format($fsck_report['metastore']['num_files']) . " files

Landing Zone (shares):
  Found " . number_format($fsck_report['landing_zone']['num_dirs']) . " directories
  Found " . number_format($fsck_report['landing_zone']['num_files']) . " files
  Found " . number_format($fsck_report['orphaned']['num_orphans']) . " orphans

Trash size:\n";

	foreach ($storage_pool_drives as $sp_drive) {
		$trash_path = clean_dir("$sp_drive/.gh_trash");
		if (is_dir($trash_path)) {
			$report .= "  $trash_path = " . trim(exec("du -sh " . escapeshellarg($trash_path) . " | awk '{print $1}'"))."\n";
		} else if (!file_exists($sp_drive)) {
			$report .= "  $sp_drive = N/A\n";
		} else {
			$report .= "  $trash_path = empty\n";
		}
	}

	// Errors
	if (empty($fsck_report['no_copies_found_files']) && count($fsck_report['wrong_file_size']) == 0) {
		$report .= "\nNo problems found.\n\n";
	} else {
		$report .= "\nProblems:\n";

		if (!empty($fsck_report['no_copies_found_files'])) {
			ksort($fsck_report['no_copies_found_files']);
			$report .= "  Found " . count($fsck_report['no_copies_found_files']) . " files in the metadata store for which no file copies were found.\n";
			if (@$options['del-orphaned-metadata']) {
				$report .= "    Those metadata files have been deleted, since you used the --delete-orphaned-metadata option. They will not re-appear in the future.\n";
			} else {
				$report .= "    Those files were removed from the Landing Zone. (i.e. those files are now gone!) They will re-appear in your shares if a copy re-appear and fsck is run.\n";
				$report .= "    If you don't want to see those files listed here each time fsck runs, delete the corresponding files from the metadata store using \"greyhole --delete-metadata=<path>, where <path> is one of the vsalue listed below.\"\n";
			}
  			$report .= "  Files with no copies:\n";
			$report .= "    " . implode("\n    ", array_keys($fsck_report['no_copies_found_files'])) . "\n\n";
		}

		if (count($fsck_report['wrong_file_size']) > 0) {
			$report .= "  Found " . count($fsck_report['wrong_file_size']) . " file copies with the wrong file size. Those files don't have the same file size as the original files available on your shares. The invalid copies have been moved into the trash.\n";
			foreach ($fsck_report['wrong_file_size'] as $real_file_path => $info_array) {
				$report .= "    $real_file_path is " . number_format($info_array[0]) . " bytes; should be " . number_format($info_array[1]) . " bytes.\n";
			}
			$report .= "\n\n";
		}
	}

	// Warnings
	if ($fsck_report['too_many_copies'] == 0 && $fsck_report['symlink_target_moved'] == 0 && count($fsck_report['temp_files']) == 0 && $fsck_report['gone_ok'] == 0) {
		// Nothing to say...
	} else {
		$report .= "Notices:\n";

		if ($fsck_report['too_many_copies'] > 0) {
			$fsck_report['too_many_files'] = array_unique($fsck_report['too_many_files']);
		
			$report .= "  Found " . $fsck_report['too_many_copies'] . " files for which there was too many file copies. Deleted (or moved in trash) files:\n";
			$report .= "    " . implode("\n    ", $fsck_report['too_many_files']) . "\n\n";
		}

		if ($fsck_report['symlink_target_moved'] > 0) {
			$report .= "  Found " . $fsck_report['symlink_target_moved'] . " files in the Landing Zone that were pointing to a now gone copy.
    Those symlinks were updated to point to the new location of those file copies.\n\n";
		}

		if (count($fsck_report['temp_files']) > 0) {
			$report .= "  Found " . count($fsck_report['temp_files']) . " temporary files, which are leftovers of interrupted Greyhole executions. The following temporary files were deleted (or moved into the trash):\n";
			$report .= "    " . implode("\n    ", $fsck_report['temp_files']) . "\n\n";
		}
	
		if ($fsck_report['gone_ok'] > 0) {
			$report .= "  Found " . $fsck_report['gone_ok'] . " missing files that are in a storage pool drive marked Temporarily-Gone.
  If this drive is gone for good, you should execute the following command, and remove the drive from your configuration file:
    greyhole --gone=path
  where path is one of:\n";
			$report .= "    " . implode("\n    ", array_keys($gone_ok_drives)) . "\n\n";
		}
	}

	return $report;
}

function gh_recycle($real_path) {
	$is_symlink = FALSE;
	clearstatcache();
	if (is_link($real_path)) {
		$is_symlink = TRUE;
	} else if (!file_exists($real_path)) {
		return TRUE;
	}

	$should_move_to_trash = FALSE;
	if (!$is_symlink) {
		global $storage_pool_drives, $delete_moves_to_trash, $shares_options;
		
		$share_options = get_share_options_from_full_path($real_path);
		if ($share_options !== FALSE) {
			$full_path = trim($share_options['name'] . "/" . str_replace($share_options['landing_zone'], '', $real_path), '/');
			$share = $share_options['name'];
		} else {
			$storage_volume = get_storage_volume_from_path($real_path);
			foreach ($storage_pool_drives as $sp_drive) {
				if ($sp_drive == $storage_volume) {
					$trash_path = "$sp_drive/.gh_trash";
					$full_path = trim(substr($real_path, strlen($sp_drive)), '/');
					break;
				}
			}

			$share = mb_substr($full_path, 0, mb_strpos($full_path, '/'));

			$should_move_to_trash = $shares_options[$share]['delete_moves_to_trash'];
		}
	}
	
	if ($should_move_to_trash) {
		// Move to trash
		if (!isset($trash_path)) {
			Log::warn("  Warning! Can't find trash for $real_path. Won't delete this file!");
			return FALSE;
		}
		
		$target_path = clean_dir("$trash_path/$full_path");

		list($path, $filename) = explode_full_path($target_path);
		
		list($original_path, $filename) = explode_full_path(get_share_landing_zone($share) . "/$full_path");
		
		if (@gh_is_file($path)) {
			unlink($path);
		}
		
		$dir_infos = (object) array(
			'fileowner' => 0,
			'filegroup' => 0,
			'fileperms' => (int) base_convert("0777", 8, 10)
		);
		gh_mkdir($path, $dir_infos);

		if (@is_dir($target_path)) {
			exec("rm -rf " . escapeshellarg($target_path));
		}
		if (@gh_rename($real_path, $target_path)) {
			Log::debug("  Moved copy from $real_path to trash: $target_path");
			
			// Create a symlink in the Greyhole Trash share, to allow the user to remove this file using that share
			create_trash_share_symlink($target_path, $trash_path);
			return TRUE;
		}
	} else {
		if (@unlink($real_path)) {
			if (!$is_symlink) {
				Log::debug("  Deleted copy at $real_path");
			}
			return TRUE;
		}
	}
	return FALSE;
}

function get_share_options_from_full_path($full_path) {
	global $shares_options;
	$landing_zone = '';
	$share = FALSE;
	foreach ($shares_options as $share_name => $share_options) {
		if (mb_strpos($full_path, $share_options['landing_zone']) === 0 && mb_strlen($share_options['landing_zone']) > mb_strlen($landing_zone)) {
			$landing_zone = $share_options['landing_zone'];
			$share = $share_options;
			break;
		}
	}
	return $share;
}

function get_storage_volume_from_path($full_path) {
	global $storage_pool_drives;
	$storage_volume = FALSE;
	$longest_path_found = 0;
	foreach ($storage_pool_drives as $sp_drive) {
		if (mb_strpos($full_path, $sp_drive) === 0 && mb_strlen($sp_drive) > $longest_path_found) {
			$storage_volume = $sp_drive;
			$longest_path_found = mb_strlen($sp_drive);
			break;
		} 
	}
	return $storage_volume;
}

function get_share_options_from_storage_volume($full_path,$storage_volume) {
	global $shares_options;
	$landing_zone = '';
	$share = FALSE;
	foreach ($shares_options as $share_name => $share_options) {
		$metastore = Metastore::store_from_path($full_path);
		if($metastore !== FALSE) {
			if (mb_strpos($full_path, "$metastore/$share_name") === 0 && mb_strlen($share_options['landing_zone']) > mb_strlen($landing_zone)) {
				$land_zone = $share_options['landing_zone'];
				$share = $share_options;
				break;
			}
		}else{
			if (mb_strpos($full_path, "$storage_volume/$share_name") === 0 && mb_strlen($share_options['landing_zone']) > mb_strlen($landing_zone)) {
				$landing_zone = $share_options['landing_zone'];
				$share = $share_options;
				break;
			}
		}
	}
	return $share;
}

function gh_get_file_infos($real_path) {
	if ($real_path == null || !file_exists($real_path)) {
		return (object) array(
			'fileowner' => 0,
			'filegroup' => 0,
			'fileperms' => (int) base_convert("0777", 8, 10)
		);
	}
	if (is_link($real_path)) {
		$real_path = readlink($real_path);
	}
	return (object) array(
		'fileowner' => (int) gh_fileowner($real_path),
		'filegroup' => (int) gh_filegroup($real_path),
		'fileperms' => (int) base_convert(gh_fileperms($real_path), 8, 10)
	);
}

function gh_get_dir_perms($directory) {
	return (int) base_convert(gh_fileperms($directory), 8, 10);
}

function gh_balance() {
	global $storage_pool_drives, $shares_options, $is_sticky;

	// Start with shares that have sticky files, so that subsequent shares will be used to try to balance what moving files into stick_into drives could debalance...
	// Then start with the shares for which we keep the most # copies;
	// That way, if the new drive fails soon, it won't take with it files for which we only have one copy!
	$sorted_shares_options = $shares_options;
	uasort($sorted_shares_options, 'compare_share_balance');
	foreach ($sorted_shares_options as $share_name => $share_options) {
		if ($share_options['num_copies'] == count($storage_pool_drives)) {
			// Files are everywhere; won't be able to use that share to balance available space!
			continue;
		}
		
		if (@$skip_stickies && is_share_sticky($share_name)) {
			Log::debug("Skipping sticky share $share_name.");
			continue;
		}

 		Log::debug("Balancing share: $share_name");

		// Move files from the drive with the less available space to the drive with the most available space.
		$sorted_pool_drives = sort_storage_drives_available_space();
		$pool_drives_avail_space = array();
		foreach ($sorted_pool_drives as $available_space => $drive) {
			$pool_drives_avail_space[$drive] = $available_space;
		}
		$num_total_drives = count($sorted_pool_drives);
		
		$balance_direction_asc = array();
		foreach ($sorted_pool_drives as $available_space => $drive) {
			$target_avail_space = array_sum($pool_drives_avail_space) / count($pool_drives_avail_space);
			$balance_direction_asc[$drive] = $pool_drives_avail_space[$drive] < $target_avail_space;
		}

		foreach ($sorted_pool_drives as $source_drive) {
			$target_avail_space = array_sum($pool_drives_avail_space) / count($pool_drives_avail_space);
			Log::debug("Balancing storage pool drive: $source_drive (". bytes_to_human($pool_drives_avail_space[$source_drive]*1024, FALSE) ." available, target: ". bytes_to_human($target_avail_space*1024, FALSE) .")");

			// Files candidate to get moved
			$files = array();
			if (is_dir("$source_drive/$share_name")) {
				exec("find ". escapeshellarg("$source_drive/$share_name") ." -type f -size +10M", $files);
			}
			Log::debug("Found ". count($files) ." files that can be moved.");
			
			// Repeat until all drives' available space is balanced.
			$file_everywhere_counter = 0;
			foreach ($files as $file) {
				// Let's not try to move locked files!
				if (real_file_is_locked($file) !== FALSE) {
					Log::debug("  File $file is locked by another process. Skipping.");
					continue;
				}

				$filesize = gh_filesize($file)/1024; // KB

				$full_path = mb_substr($file, mb_strlen("$source_drive/$share_name/"));
				list($path, $filename) = explode_full_path($full_path);
				Log::debug("  Working on file: $share_name/$full_path (". bytes_to_human($filesize*1024, FALSE) .")");

				$sp_drives = order_target_drives($filesize, FALSE, $share_name, $path, '  ');

				unset($sp_drive);
				if ($is_sticky) {
					if (count($sp_drives) == $num_total_drives - 1 && array_search($source_drive, $sp_drives) === FALSE) {
						// Only drive full is the source drive. Let's move files away from there!
					} else if (count($sp_drives) < $num_total_drives) {
						$skip_stickies = TRUE;
						Log::debug("  Some drives are full. Skipping sticky shares until all drives have some free space.");
						break;
					}
					
					$sticky_drives = array_slice($sp_drives, 0, get_num_copies($share_name));
					if (array_search($source_drive, $sticky_drives)) {
						// Source drive is a stick_into drive; let's not move that file!
						Log::debug("  Source is sticky. Skipping.");
						continue;
					}
					$already_stuck_copies = 0;
					foreach ($sticky_drives as $drive) {
						if (file_exists("$drive/$share_name/$full_path")) {
							$already_stuck_copies++;
						} else {
							$sp_drive = $drive;
						}
					}
				} else {
					while (count($sp_drives) > 0) {
						$drive = array_shift($sp_drives);
						if (!file_exists("$drive/$share_name/$full_path")) {
							$sp_drive = $drive;
							break;
						}
					}
				}
				
				if (!isset($sp_drive)) {
					// Can't find a drive that doesn't have this file; skipping.
					if ($is_sticky) {
						Log::debug("  Sticky file is already where it should be. Skipping.");
					}
					continue;
				}

				Log::debug("  Target drive: $sp_drive (". bytes_to_human($pool_drives_avail_space[$sp_drive]*1024, FALSE) ." available)");

				if ($is_sticky) {
					Log::debug("  Moving sticky file, even if that means it won't help balancing available space.");
				} else if ($pool_drives_avail_space[$source_drive]+$filesize+1*1024*1024 /*1GB*/ > $pool_drives_avail_space[$sp_drive]-$filesize
						|| $pool_drives_avail_space[$source_drive]+$filesize > $target_avail_space
						|| ($balance_direction_asc[$sp_drive] && $pool_drives_avail_space[$sp_drive] > $target_avail_space)
						|| (!$balance_direction_asc[$sp_drive] && $pool_drives_avail_space[$sp_drive] < $target_avail_space)) {
					Log::debug("  Moving this file wouldn't help balancing available space. Skipping.");
					#Log::debug("    Reason 1: " . var_export($pool_drives_avail_space[$source_drive]+$filesize+1*1024*1024 /*1GB*/ > $pool_drives_avail_space[$sp_drive]-$filesize, TRUE));
					#Log::debug("    Reason 2: " . var_export($pool_drives_avail_space[$source_drive]+$filesize > $target_avail_space, TRUE));
					#Log::debug("    Reason 3: " . var_export($balance_direction_asc[$sp_drive] && $pool_drives_avail_space[$sp_drive] > $target_avail_space, TRUE));
					#Log::debug("    Reason 4: " . var_export(!$balance_direction_asc[$sp_drive] && $pool_drives_avail_space[$sp_drive] < $target_avail_space, TRUE));
					#Log::debug("    pool_drives_avail_space[source]+filesize+1GB = " . ($pool_drives_avail_space[$source_drive]+$filesize+1*1024*1024));
					#Log::debug("    pool_drives_avail_space[source]+filesize = " . ($pool_drives_avail_space[$source_drive]+$filesize));
					#Log::debug("    pool_drives_avail_space[target_drive] = " . ($pool_drives_avail_space[$sp_drive]));
					#Log::debug("    pool_drives_avail_space[target_drive]-filesize = " . ($pool_drives_avail_space[$sp_drive]-$filesize));
					#Log::debug("    target_avail_space = " . ($target_avail_space));
					#Log::debug("    balance_direction_asc[target_drive] = " . var_export($balance_direction_asc[$sp_drive], TRUE));
					continue;
				}

				// Make sure the parent directory exists, before we try moving something there...
				$original_path = clean_dir("$source_drive/$share_name/$path");
				list($target_path, $filename) = explode_full_path("$sp_drive/$share_name/$full_path");
				gh_mkdir($target_path, $original_path);

				// Move the file
				$temp_path = get_temp_filename("$sp_drive/$share_name/$full_path");
				$file_infos = gh_get_file_infos($file);
				Log::debug("  Moving file copy...");
				$it_worked = gh_rename($file, $temp_path);
				if ($it_worked) {
					gh_rename($temp_path, "$sp_drive/$share_name/$full_path");
					gh_chperm("$sp_drive/$share_name/$full_path", $file_infos);

					$pool_drives_avail_space[$sp_drive] -= $filesize;
					$pool_drives_avail_space[$source_drive] += $filesize;
				} else {
					Log::warn("    Failed file copy. Skipping.");
					gh_recycle($temp_path);
					continue;
				}

				// Update metafiles
				foreach (Metastore::metafiles_for_file($share_name, $path, $filename, METAFILES_OPTION_QUIET|METAFILES_OPTION_NO_SYMLINK_CHECK) as $existing_metafiles) {
					foreach ($existing_metafiles as $key => $metafile) {
						if ($metafile->path == $file) {
							$metafile->path = "$sp_drive/$share_name/$full_path";
							unset($existing_metafiles[$key]);
							$metafile->state = 'OK';
							if ($metafile->is_linked) {
								// Re-create correct symlink
								$landing_zone = $share_options['landing_zone'];
								if (is_link("$landing_zone/$full_path")) {
									Log::debug("  Updating symlink at $landing_zone/$full_path to point to $metafile->path");
									if (gh_recycle("$landing_zone/$full_path")) {
										@symlink($metafile->path, "$landing_zone/$full_path");
										// Creating this symlink can fail if the parent dir was removed
									}
								}
							}
							$existing_metafiles[$metafile->path] = $metafile;
							Metastore::save_metafiles($share_name, $path, $filename, $existing_metafiles);
							break;
						}
					}
				}	
				$target_avail_space = array_sum($pool_drives_avail_space) / count($pool_drives_avail_space);
				Log::debug("Balancing storage pool drive: $source_drive (". bytes_to_human($pool_drives_avail_space[$source_drive]*1024, FALSE) ." available, target: ". bytes_to_human($target_avail_space*1024, FALSE) .")");
			}
			Log::debug("Done balancing storage pool drive: $source_drive (". bytes_to_human($pool_drives_avail_space[$source_drive]*1024, FALSE) ." available)");
		}
		Log::debug("Done balancing share: $share_name");
	}
	
	if (@$skip_stickies) {
		// We skipped some stickies... Let's re-balance to move those, and continue balancing.
		$arr = debug_backtrace();
		if (count($arr) < 93) {
			Log::debug("Some shares with sticky files were skipped. Balancing will now re-start to continue moving those sticky files as needed, and further balance. Recursion level = " . count($arr));
			gh_balance();
		} else {
			Log::warn("Maximum number of consecutive balance reached. You'll need to re-execute --balance if you want to balance further.");
		}
	}
}

function is_share_sticky($share_name) {
	global $sticky_files;
	if (isset($sticky_files)) {
		foreach ($sticky_files as $share_dir => $stick_into) {
			if (mb_strpos($share_dir, $share_name) === 0) {
				return TRUE;
			}
		}
	}
	return FALSE;
}

function compare_share_balance($a, $b) {
	if (is_share_sticky($a['name']) && !is_share_sticky($b['name'])) {
		return -1;
	}
	if (!is_share_sticky($a['name']) && is_share_sticky($b['name'])) {
		return 1;
	}
	if ($a['num_copies'] != $b['num_copies']) {
		return $a['num_copies'] > $b['num_copies'] ? -1 : 1;
	}
	return strcasecmp($a['name'], $b['name']);
}

function sort_storage_drives_available_space() {
	global $storage_pool_drives, $minimum_free_space_pool_drives;
	$dfs = get_free_space_in_storage_pool_drives();
	foreach ($storage_pool_drives as $sp_drive) {
		if (!isset($dfs[$sp_drive])) {
			continue;
		}
		$free_space = $dfs[$sp_drive]['free'];
		$minimum_free_space = (float) (isset($minimum_free_space_pool_drives[$sp_drive]) ? $minimum_free_space_pool_drives[$sp_drive]*1024*1024 : 0.0);
		$available_space = (float) $free_space - $minimum_free_space;
		while (isset($sorted_target_drives[$available_space])) {
			// In case some drives have the exact same amount of available_space, make sure we return all drives!
			$available_space++;
		}
		$sorted_target_drives[$available_space] = $sp_drive;
	}
	ksort($sorted_target_drives);
	return $sorted_target_drives;
}

// If running on Amahi, loop until the config works.
// User might configure Greyhole later, and they don't want to show Greyhole 'offline' until then. Users are easy to confused! ;)
function process_config() {
	while (!parse_config()) {
		// Sleep for a while, if running on Amahi.
		if (file_exists('/usr/bin/hdactl') && Log::action_equals('daemon')) {
			sleep(600); // 10 minutes
		} else {
			// Otherwise, die.
			Log::critical("Config file parsing failed. Exiting.");
		}
	}
	// Config is OK; go on!
}

function gh_wild_mb_strpos($haystack, $needle) { 
	$is_wild = (mb_strpos($needle, "*") !== FALSE);
	if (!$is_wild) {
		return mb_strpos($haystack, $needle);
	}
	if (str_replace('*', '', $needle) == $haystack) {
		return FALSE;
	}
	$needles = explode("*", $needle);
	if ($needle[0] == '*') {
		$first_index = 0;
	}
	foreach ($needles as $needle_part) {
		if ($needle_part == '') {
			continue;
		}
		$needle_index = mb_strpos($haystack, $needle_part);
		if (!isset($first_index)) {
			$first_index = $needle_index;
		}
		if ($needle_index === FALSE) {
			return FALSE;
		} else {
			$found = TRUE;
			$haystack = mb_substr($haystack, $needle_index + mb_strlen($needle_part));
		}
	}
	if ($found) {
		return $first_index;
	}
	return FALSE;
}

function str_replace_first($search, $replace, $subject) {
	$firstChar = mb_strpos($subject, $search);
	if ($firstChar !== FALSE) {
		$beforeStr = mb_substr($subject, 0, $firstChar);
		$afterStr = mb_substr($subject, $firstChar + mb_strlen($search));
		return $beforeStr . $replace . $afterStr;
	} else {
		return $subject;
	}
}

function create_trash_share_symlink($filepath_in_trash, $trash_path) {
	global $trash_share;
	if (isset($trash_share)) {
		$filepath_in_trash = clean_dir($filepath_in_trash);
		$filepath_in_trash_share = str_replace($trash_path, $trash_share['landing_zone'], $filepath_in_trash);
		if (file_exists($filepath_in_trash_share)) {
			$new_filepath = $filepath_in_trash_share;
			$i = 1;
			while (file_exists($new_filepath)) {
				if (@readlink($new_filepath) == $filepath_in_trash) {
					// There's already a symlink to that file in the trash share; let's not make a second one!
					return;
				}
				$new_filepath = "$filepath_in_trash_share copy $i";
				$i++;
			}
			$filepath_in_trash_share = $new_filepath;
			list($original_path, $filename) = explode_full_path($filepath_in_trash_share);
		} else {
			list($original_path, $filename) = explode_full_path($filepath_in_trash);
			list($path, $filename) = explode_full_path($filepath_in_trash_share);

			$dir_infos = (object) array(
				'fileowner' => (int) gh_fileowner($original_path),
				'filegroup' => (int) gh_filegroup($original_path),
				'fileperms' => (int) base_convert("0777", 8, 10)
			);
			gh_mkdir($path, $dir_infos);
		}
		if (@symlink($filepath_in_trash, $filepath_in_trash_share)) {
			Log::debug("  Created symlink to deleted file in {$trash_share['name']} share ($filename).");
		} else {
			Log::warn("  Warning! Couldn't create symlink to deleted file in {$trash_share['name']} share ($filename).");
		}
	}
}

function get_conf_md5() {
	global $config_file;
	exec("grep -ie 'num_copies\|storage_pool_directory\|storage_pool_drive\|sticky_files' " . escapeshellarg($config_file) . " | grep -v '^#'", $content);
	exec("grep -ie 'path\|vfs objects' " . escapeshellarg(SambaHelper::$config_file) . " | grep -v '^#'", $content);
	return md5(implode("\n", $content));
}

function how_long_ago($past_time) {
	$ago = '';
	$s = time() - $past_time;
	$m = floor($s / 60);
	if ($m > 0) {
		$s -= $m * 60;
		$h = floor($m / 60);
		if ($h > 0) {
			$ago = $h . "h ";
			$m -= $h * 60;
		}
		$ago = $ago . $m . "m ";
	}
	$ago = $ago . $s . "s";
	if ($ago == '0s') {
		return 'just now';
	}
	return "$ago ago";
}

// This unique identifier will be used when Greyhole calls home, to uniquely (and anonymously) identify this Greyhole instance.
function set_uniq_id() {
	$uniq_id = Settings::get('uniq_id');

	if (!$uniq_id) {
		// No uid found in DB; look on filesystem
		global $storage_pool_drives;
		foreach ($storage_pool_drives as $sp_drive) {
			$f = "$sp_drive/.greyhole_uses_this";
			if (file_exists($f) && filesize($f) == 23) {
				// Found a valid uid
				$uniq_id = file_get_contents($f);
				break;
			}
		}

		if (!$uniq_id) {
			// No uid found; generate a new one
			$uniq_id = uniqid('', TRUE);
		}

		Settings::set('uniq_id', $uniq_id);
	}
	
	return $uniq_id;
}

function get_copy_cmd($source, $destination) {
	global $copy_method;
	if (@$copy_method == 'rsync') {
		return "rsync -t " . escapeshellarg($source) . " " . escapeshellarg($destination);
	} else {
		return "cp -p " . escapeshellarg($source) . " " . escapeshellarg($destination);
	}
}

function spawn_thread($action, $arguments) {
	// Don't spawn duplicate threads
	$num_worker_thread = (int) exec('ps ax | grep "/usr/bin/greyhole --' . $action . '" | grep "drive='. implode('" | grep "drive=', $arguments) . '" | grep -v grep | wc -l');
	if ($num_worker_thread > 0) {
		Log::debug("Won't span a duplicate thread; 'greyhole --$action --drive=$arguments[0]' is already running");
		return 1;
	}

	$cmd = "/usr/bin/greyhole --$action --drive=" . implode(' --drive=', array_map('escapeshellarg', $arguments));
	exec("$cmd 1>/var/run/greyhole_m5d_worker.pid 2>&1 &");
	usleep(100000); // 1/10s
	return (int) file_get_contents('/var/run/greyhole_m5d_worker.pid');
}

function gh_check_md5($task) {
	global $shares_options;
	$share_options = $shares_options[$task->share];

	$query = sprintf("SELECT complete, COUNT(*) AS num, GROUP_CONCAT(id) AS ids FROM tasks WHERE action = 'md5' AND share = '%s' AND full_path = '%s' GROUP BY complete ORDER BY complete ASC",
		DB::escape_string($task->share),
		DB::escape_string($task->full_path)
	);
	$result = DB::query($query) or Log::critical("Can't query complete md5 tasks: " . DB::error());
	$complete_tasks = DB::fetch_object($result); // ORDER BY complete ASC in the above query will always return complete='yes' first, and there will always be at least one ($task)
	$incomplete_tasks = DB::fetch_object($result);
	if ($incomplete_tasks === FALSE) {
		$incomplete_tasks = array();
	}
	if (count($incomplete_tasks) > 0) {
		// We don't have all of them yet. Let's post-pone this until we do.
		$query = sprintf("INSERT INTO tasks (action, share, full_path, additional_info, complete) SELECT action, share, full_path, additional_info, complete FROM tasks WHERE id = %d", $task->id);
		DB::query($query) or Log::critical("Can't postpone md5 task: " . DB::error());

		// If there's no worker thread alive, spawn all of them. The idle ones will just die.
		$num_worker_threads = (int) trim(exec("ps x | grep '/usr/bin/greyhole --md5-worker' | grep -v grep | wc -l"));
		if ($num_worker_threads == 0) {
			Log::debug("  Will spawn new worker threads to work on this.");
			global $storage_pool_drives;
			foreach ($storage_pool_drives as $sp_drive) {
				spawn_thread('md5-worker', array($sp_drive));
			}
		} else {
			// Give the worker thread some time to catch up
			Log::debug("  Will wait some to allow for MD5 worker threads to complete.");
			sleep(5);
		}
		return;
	}
	
	// We have all of them; let's check the MD5 checksums
	Log::debug("Checking MD5 checksums for " . clean_dir("$task->share/$task->full_path"));
	$result_tasks = DB::query("SELECT * FROM tasks WHERE id IN ($complete_tasks->ids)") or Log::critical("Can't fetch complete md5 tasks: " . DB::error());
	$md5s = array();
	while ($t = DB::fetch_object($result_tasks)) {
		if (preg_match('/^(.+)=([0-9a-f]{32})$/', $t->additional_info, $regs)) {
			$md5s[$regs[2]][] = clean_dir($regs[1]);
		} else {
			$md5s['unreadable files'][] = clean_dir($t->additional_info);
		}
	}
	if (count($md5s) == 1) {
		$md5s = array_keys($md5s);
		$md5 = reset($md5s);
		
		if ($md5 == 'unreadable files') {
			// Oopsy!
			$logs = array(
				"  The following file is unreadable: " . clean_dir($t->additional_info),
				"  The underlying filesystem probably contains errors. You should unmount that partition, and check it using e2fsck -cfp"
			);
		} else {
			Log::debug("  All copies have the same MD5 checksum: $md5");
		}
	}
	else if (count($md5s) > 1) {
		// Oopsy!
		$logs = array("Mismatch in file copies checksums:");
		foreach ($md5s as $md5 => $file_copies) {
			$files = '';
			foreach ($file_copies as $file_copy) {
				if ($files != '') {
					$files .= ', ';
				}
				$files .= $file_copy;
			}
	
			// Automatically fix this if:
			// - there's only 2 different MD5s for all file copies (i.e. one for all other files copies, and one for this file copy)
			// - the current MD5 is only for one file copy (we assume this copy is in error, not the others)
			// - that file copy isn't used as the share symlink target
			$latest_file_copy = $file_copy;
			$original_file_path = clean_dir(readlink(get_share_landing_zone($task->share) . "/" . $task->full_path));
			if (count($md5s) == 2 && count($file_copies) == 1 && $latest_file_copy != $original_file_path) {
				$original_md5 = 'Unknown';
				foreach ($md5s as $this_md5 => $file_copies) {
					foreach ($file_copies as $file_copy) {
						if ($file_copy == $original_file_path) {
							$original_md5 = $this_md5;
							break;
						}
					}
				}

				Log::warn("  A file copy with a different checksum than the original was found: $latest_file_copy = $md5. Original: $original_file_path = $original_md5");
				Log::warn("  This copy will be deleted, and replaced with a new copy from $original_file_path");
				gh_recycle($latest_file_copy);

				$metafiles = array();
				list($path, $filename) = explode_full_path($task->full_path);
				foreach (Metastore::metafiles_for_file($task->share, $path, $filename, METAFILES_OPTION_LOAD_NOK|METAFILES_OPTION_QUIET|METAFILES_OPTION_NO_SYMLINK_CHECK) as $existing_metafiles) {
					foreach ($existing_metafiles as $key => $metafile) {
						$metafiles[$key] = $metafile;
					}
				}
				WriteFileTask::create_copies_from_metafiles($metafiles, $task->share, $task->full_path, $original_file_path, TRUE);

				Log::debug("  Calculating MD5 for new file copy at $latest_file_copy ...");
				$md5 = md5_file($latest_file_copy);
				Log::debug("    MD5 = $md5");
				if ($md5 == $original_md5) {
					Log::debug("  All copies have the same MD5 checksum: $md5");
					delete_tasks($complete_tasks->ids);
					return;
				}
			}

			$logs[] = "  [$md5] => $files";
			if (count($file_copies) == 1) {
				$logs[] = "    The above file is unreadable.";
				$logs[] = "    The underlying filesystem probably contains errors. You should unmount that partition, and check it using e2fsck -cfp";
			} else {
				$logs[] = "    The above files are unreadable.";
				$logs[] = "    The underlying filesystems probably contains errors. You should unmount those partitions, and check them using e2fsck -cfp";
			}
		}
		
		$logs[] = "You should manually check which file copy is invalid, and delete it. Re-create a valid copy with:";
		$logs[] = "  greyhole --fsck --dir " . escapeshellarg(dirname(clean_dir($share_options['landing_zone'] . "/$task->full_path")));
	}
	
	if (isset($logs)) {
		// Write to greyhole.log
		foreach ($logs as $log) {
			Log::error($log);
		}

		// Write in fsck_checksums.log too
		$flog = fopen(FSCKLogFile::PATH . '/fsck_checksums.log', 'a');
		if (!$flog) {
			Log::critical("Couldn't open log file: " . FSCKLogFile::PATH . "/fsck_checksums.log");
		}
		fwrite($flog, $date = date("M d H:i:s") . ' ' . implode("\n", $logs) . "\n\n");
		fclose($flog);

		unset($logs);
	}
	
	delete_tasks($complete_tasks->ids);
}

function delete_tasks($task_ids) {
	DB::query("DELETE FROM tasks WHERE id IN ($task_ids)") or Log::critical("Can't delete tasks: " . DB::error());

	DB::free_result(Task::$result_set);
	Task::$result_set = null;
}

function set_fsck_options($task) {
	global $options;
	$options['all-fsck-options'] = $task->additional_info;
	$options['disk-usage-report'] = $task->hasOption(OPTION_DU);
	$options['find-orphans'] = $task->hasOption(OPTION_ORPHANED);
	$options['verify-checksums'] = $task->hasOption(OPTION_CHECKSUMS);
	$options['del-orphaned-metadata'] = $task->hasOption(OPTION_DEL_ORPHANED_METADATA);
}

function remove_drive_definition($going_drive) {
	$drives_definitions = Settings::get('sp_drives_definitions', TRUE);
	if (!$drives_definitions) {
		$drives_definitions = convert_sp_drives_tag_files();
	}
	unset($drives_definitions[$going_drive]);
	Settings::set('sp_drives_definitions', $drives_definitions);
}

function get_file_inodes($share, $file_path, $filename, &$file_metafiles) {
	global $storage_pool_drives;
	$file_copies_inodes = array();
	
	foreach ($storage_pool_drives as $sp_drive) {
		$clean_full_path = clean_dir("$sp_drive/$share/$file_path/$filename");
		if (is_link($clean_full_path)) {
			continue;
		}
		$inode_number = @gh_fileinode($clean_full_path);
		if ($inode_number !== FALSE) {
			if (is_dir($clean_full_path)) {
				Log::warn("Warning! Found a directory that should be a file! Will try to remove it, if it's empty.");
				@rmdir($clean_full_path);
				continue;
			}

			Log::debug("Found $clean_full_path");

			if (!StoragePoolHelper::is_drive_ok($sp_drive)) {
				$state = 'Gone';
				Log::info("  Drive $sp_drive is not part of the Greyhole storage pool anymore. The above file will not be counted as a valid file copy, but can be used to create a new valid copy.");
			} else {
				$state = 'OK';
				$file_copies_inodes[$inode_number] = $clean_full_path;
			}
			$file_metafiles[$clean_full_path] = (object) array('path' => $clean_full_path, 'is_linked' => FALSE, 'state' => $state);
			
			// Temp files leftovers of stopped Greyhole executions
			$temp_filename = get_temp_filename($clean_full_path);
			if (file_exists($temp_filename) && gh_is_file($temp_filename)) {
				Log::info("  Found temporary file $temp_filename ... deleting.");
				$fsck_report['temp_files'][] = $temp_filename;
				gh_recycle($temp_filename);
			}
		}
	}

	return $file_copies_inodes;
}

function normalize_utf8_characters($string) {
	// Requires intl PHP extension (php-intl)
	return normalizer_normalize($string);
}
?>
